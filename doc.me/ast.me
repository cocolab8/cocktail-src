.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.EQ
delim off
.EN
.T0

	Ast - A Generator for
	Abstract Syntax Trees


	J. Grosch


.T1
.mc \(bv
.T2 Ast "Ast - A Generator for Abstract Syntax Trees" "Josef Grosch" "Sept. 25, 2008" 15 2008
.mc
.hc @
.bp 1
.sh 1 Introduction
.pp
.i Ast
is a generator for program modules that define the structure of abstract syntax
trees and provide general tree manipulating procedures. The defined trees
may be decorated with attributes of arbitrary types. Besides trees,
graphs can be handled, too. The structure of the trees is specified by a
formalism based on context-free grammars.
The generated module includes procedures to construct
and destroy trees, to read and write trees from (to) files, and to traverse
trees in some commonly used manners. The mentioned readers and writers
process text as well as binary tree representations.
Most procedures work for graphs as well.
.pp
The advantages of this approach are: record aggregates are provided which
allow a concise notation for node creation. It is possible to build trees
by writing terms. An extension mechanism avoids chain rules and allows, for
example lists with elements of different types. Input/output procedures
for records and complete graphs are provided. The output procedures and the
interactive graph browser facilitate the debugging phase as they operate on
a readable level and know the data structure.
The user does not have to care about algorithms for traversing graphs. He/she
is freed from the task of writing large amounts of relatively simple code.
All of these features significantly increase programmer productivity.
.pp
.i Ast
is implemented in Modula-2 as well as in C. The tool generates C, C++, Java, or
Modula-2 source code. Two versions of C++ source code can be generated which
will be called
.i "simple C++"
and
.i "proper C++"
in this document.
Simple C++ uses for the representation of the tree nodes the same data structure
as C: A union type of a set of struct types. Only one class is used whose
members are the data items which are global variables in C.
Proper C++ uses class types and inheritance for the representation of the tree
nodes. Global variables are still used as in C.
.pp
The following sections define the specification language, explain the
generated output, discuss related approaches, and present some examples.
.sh 1 "Specification Language"
.pp
The structure of trees and directed graphs is specified by a
formalism based on context-free grammars.
However, we primarily use the terminology of trees and types in defining the
specification language.
Its relationship to context-free grammars is discussed later.
.sh 2 "Node Types"
.pp
A tree consists of
.i nodes .
A node may be related to other nodes in a so-called
.i parent-child
relation. Then the first node is called a
.i parent
node and the latter nodes are called
.i child
nodes. Nodes without a parent node are usually called
.i root
nodes, nodes without children are called
.i leaf
nodes.
.pp
The structure and the properties of nodes are described by
.i "node types" .
Every node belongs to a node type.
A specification for a tree describes a finite number of node types.
A node type specifies the names of the child nodes and the associated node
types as well as the names of the attributes and the associated attribute types.
A node type is introduced by a name which can be an identifier or a string.
The names of all node types have to be pairwise distinct.
A node type can be regarded as a
.i nonterminal ,
a
.i terminal ,
or an
.i abstract
entity. Nonterminals are characterized by the character '=' following its name,
terminals by the character ':', and abstract node types by the characters ':='.
Undefined node types are implicitly defined to be terminals
without attributes. The distinction between nonterminals and terminals is only of interest if
concrete syntax is described. In the case of abstract syntax this distinction does not make
sense and therefore nonterminal node types and eventually abstract ones suffice.
Abstract node types are explained in section 2.6.
.(b
Example:
.sp 0.5
.FT
   If        = .
   While     = .
   '()'      = .
   Ident     : .
   ":="      : .
   SCOPE     := .
.)b
The example defines the node types
.i If ,
.i While ,
and
.i '()'
to be nonterminals, the node types
.i Ident
and \fI":="\fP to be terminals, and
.i SCOPE
to be an abstract node type.
.pp
The following names are reserved for keywords and can not be used for node types:
.(b
.FT
BEGIN           CLOSE           DECLARE         DEMAND          END
EVAL            EXPORT          FOR             FUNCTION        GLOBAL
IGNORE          IMPORT          IN              INH             INHERITED
INPUT           LEFT            LOCAL           MODULE          NONE
OUT             OUTPUT          PARSER          PREC            PROPERTY
REMOTE          REV             REVERSE         RIGHT           RULE
SCANNER         SELECT          STACK           START           SUBUNIT
SYN             SYNTHESIZED     THREAD          TREE            VIEW
VIRTUAL         VOID
.)b
.sh 2 Children
.pp
Children describe subtrees. They are distinguished by
.i selector
names which have to be unambiguous within one node type.
A child has a certain node type.
.(b
Example:
.sp 0.5
.FT
   If        = Expr: Expr Then: Stats Else: Stats .
   While     = Expr: Expr Stats: Stats .
.)b
The example introduces two node types called
.i If
and
.i While .
A node of type If has three children which are selected by the names
.i Expr ,
.i Then ,
and
.i Else.
The children have the node types
.i Expr ,
.i Stats ,
and
.i Stats .
.pp
If a selector name is equal to the associated name of the node type it can
be omitted. Therefore, the above example can be abbreviated as follows:
.(b
.FT
   If        = Expr Then: Stats Else: Stats .
   While     = Expr Stats .
.)b
.sh 2 Attributes
.pp
Besides children, every node type can specify an arbitrary number of
.i attributes
of arbitrary types. Like children, attributes are characterized by a selector
name and a certain type.
The descriptions of attributes are enclosed in brackets. The types for attributes
are given by names taken from the target language or from the set of node types.
The type of an attribute can be the general tree pointer types tTREE and TREE,
too.
Missing types
are assumed to be int or INTEGER depending on the target language
(C, C++, Java, or Modula-2).
Children and attributes can be given in any order.
.pp
If the type of an attribute is a node type, tTREE, or TREE, the attribute is
called tree-valued, otherwise it is not tree-valued.
By default,
.i ast
does not follow a tree-valued attribute during a graph traversal. All attributes
are considered to be neither tree nor graph structured. Only the user knows
about this fact and therefore he/she should take care. Exceptions are the graph
browser procedure
.i DrawTREE/Draw
which can launch a separate browser on a subtree rooted at a tree-valued
attribute and the tree transformation tool
.i puma
which does type checking for tree-valued attributes.
In some cases this default treatment of tree-valued attributes can be changed in
such a way that they are treated like children (see description of the procedure
ConfigureTREE/Configure).
.(b
Example (in C or C++):
.sp 0.5
.FT
   Binary        = Lop: Expr Rop: Expr [Operator: int] .
   Unary         = Expr [Operator] .
   IntConst      = [Value] .
   RealConst     = [Value: float] .
.)b
.pp
For example the node types
.i IntConst
and
.i RealConst
describe leaf nodes with an attribute named
.i Value
of types int or float respectively.
.i Binary
and
.i Unary
are node types with an attribute called
.i Operator
of type int.
.(b
Example (in C or C++):
.sp 0.5
.FT
   Node          = [a1: Binary] [a2: Tree] [a3: tTree] [a4: int] .
.)b
.pp
The attributes
.i a1 ,
.i a2 ,
and
.i a3
are tree-valued, while the attribute
.i a4
is not tree-valued.
.sh 2 "Declare Clause"
.pp
The DECLARE clause allows the definition of children and attributes for several
node types at one time.
Following the keyword DECLARE, a set of declarations can be given. The syntax is the same as
described above with the exception that several node type names may introduce a declaration.
If there already exists a declaration for a specified node type,
the children and attributes are added to this declaration.
Otherwise a new node type is introduced.
.(b
Example:
.sp 0.5
.FT
DECLARE
   Decls Stats Expr = [Level] [Env: tEnv] .
               Expr = Code [Type: tType] .
.)b
.sh 2 Extensions
.pp
To allow several alternatives for the types of children an
.i extension
mechanism is used. A node type may be associated with several other node types enclosed
in angle brackets. The first node type is called
.i base
or
.i super
type and the latter types are called
.i derived
types or
.i subtypes .
A derived type can in turn be extended with no limitation of the nesting depth.
The extension mechanism induces a subtype relation between node types.
This relation is transitive.
Where a node of a certain node type is required, either a node of this node type or a node of
a subtype thereof is possible.
.(b
Example:
.sp 0.5
.FT
Stats           = <
   If           = Expr Then: Stats Else: Stats .
   While        = Expr Stats .
> .
.)b
.pp
In the above example
.i Stats
is a base type describing nodes with neither children nor attributes.
It has two derived types called
.i If
and
.i While .
Where a node of type Stats is required, nodes of types Stats, If, and While are possible.
Where a node of type If is required, nodes of type If are possible, only.
.pp
Besides extending the set of possible node types, the extension mechanism has
the property of extending the children and attributes of the nodes of the base type.
The derived types possess the children and attributes of the base type.
They may define additional children and attributes.
In other words they
.i inherit
the structure of the base type.
The selector names of all children and attributes in an extension hierarchy have to be
distinct. The syntax of extensions has been designed this way in order to allow
single inheritance, only. Multiple inheritance is available, too. It is described in
the next section.
.(b
Example:
.sp 0.5
.FT
Stats           = Next: Stats [Pos: tPosition] <
   If           = Expr Then: Stats Else: Stats .
   While        = Expr Stats .
> .
.)b
.pp
Nodes of type
.i Stats
have one child selected by the name
.i Next
and one attribute named
.i Pos .
Nodes of type
.i While
have three children with the selector names
.i Next ,
.i Expr ,
and
.i Stats
and one attribute named
.i Pos.
.pp
A node of a base type like
.i Stats
usually does not occur in an abstract syntax tree for a complete program.
Still,
.i ast
defines this node type. It could be used as placeholder for unexpanded
nonterminals in incomplete programs which occur in applications like
syntax directed editors.
.sh 2 "Multiple Inheritance"
.pp
The extension mechanism described in the previous section allows for single inheritance of
children and attributes. The syntax of the extensions has been designed to reflect the
notation of context-free grammars as close as possible. For multiple inheritance a
different syntax and the concept of
.i "abstract node types"
are used.
.pp
Abstract node types are characterized by the definition characters ':=' instead of '=' or ':'
which are used for nonterminals or terminals. They are termed abstract because they
describe only the structure of nodes or parts thereof but nodes of this types do not exist.
Therefore no code is generated by
.i ast
for abstract node types: no constant, no record type, no constructor procedure, etc..
Abstract node types can only be used as base types in combination with multiple inheritance.
.pp
For multiple inheritance the following syntax is used: The name of a node type may be
followed by a left arrow '<-' and a list of names. This construct is available for all three
kinds of node types: nonterminals, terminals, and abstract node types. The names after the
left arrow have to denote abstract node types. The meaning is that the node type inherits
the structure of all listed abstract node types. Multiple inheritance is possible from
abstract node types to non abstract ones and among abstract node types. Among non abstract
node types only single inheritance is allowed.
.lp
.(b
Example:
.sp 0.5
.FT
DECLS              := [Objects: tObjects THREAD] <
  NODECLS          := .
  DECL             := [Ident: tIdent INPUT] Next:DECLS .
> .
.sp 0.5
ENV                := [Env: tEnv INH] .
.sp 0.5
USE   <- ENV       := [Ident: tIdent INPUT] [Object: tObject SYN] .
.sp 0.5
SCOPE <- ENV       := [Objects: tObjects SYN] [NewEnv: tEnv SYN] .
.)b
.(b
.FT
Root               = Proc .
.sp 0.5
Decls <- DECLS ENV = <
  NoDecls          = .
  Decl <- DECL     = <
    Var            = .
    Proc <- SCOPE  = Decls Stats .
  > .
> .
Stats <- ENV       = <
  NoStats          = .
  Stat             = <
    Assign         = Name Expr .
    Call <- USE    = .
  > .
> .
Expr <- ENV        = <
  Plus             = Lop: Expr Rop: Expr .
  Const            = [Value] .
  Name <- USE      = .
> .
.)b
.pp
The above example uses multiple inheritance and abstract node types to describe
the identification problem of programming languages. The node types written with
all upper-case letters represent abstract node types. DECLS specifies lists of
declared objects, SCOPE describes scopes or visibility regions, ENV stands for
environment and is used to distribute scope information, and USE is intended to be
used at the application of identifiers. In the second part of the example, the abstract node
types are connected to nonterminal node types.
.i Decls
is the concrete node type to describe lists of declarations.
.i Decl
represents one declaration and there are two alternatives,
.i Var
and
.i Proc ,
variables and procedures. A procedure introduces a scope and therefore it inherits from
SCOPE.
At the node types
.i Call
and
.i Name
identifiers are used and thus they inherit from USE. Finally, the node types
.i Decls ,
.i Stats ,
and
.i Expr
are regions where the environment information has to be distributed and they inherit from
ENV.
.sh 2 Modules
.pp
The specification of node types can be grouped into an arbitrary number of modules.
The modules allow to combine parts of the specification that logically belong together.
This feature can be used to structure a specification or to extend an existing one.
A module consists of target code sections (see section 2.13.)
and specifications of node types with attribute declarations.
The information given in the modules is merged in the following way:
the target code sections are concatenated.
If a node type has already been declared the given children, attributes,
and subtypes are added to the existing declaration.
Otherwise a new node type is introduced.
This way of modularization offers several possibilities:
.ip -
Context-free grammar and attribute declarations (= node types)
can be combined in one module.
.ip -
The context-free grammar and the attribute declarations
can be placed in two separate modules.
.ip -
The attribute declarations can be subdivided into several modules according
to the tasks of semantic analysis. For example, there would be modules for
scope handling, type determination, and context conditions.
.ip -
The information can be grouped according to language concepts or
nonterminals. For example, there would be modules containing
the grammar rules and the attribute declarations
for declarations, statements, and expressions.
.lp
.(b
Example:
.sp 0.5
.FT
MODULE my_version
.sp 0.5
Stats        = [Env: tEnv] <                    /* add attribute   */
   While     = Init: Stats Terminate: Stats .   /* add children    */
   Repeat    = Stats Expr .                     /* add node type   */
> .
.sp 0.5
END my_version
.)b
.sh 2 Properties
.pp
The description of children and attributes can be refined by the association of so-called
properties. These properties are expressed by the keywords listed in Table 1.
.(z L
.ce
Table 1: Properties for Children and Attributes
.sp 0.5
.TS
center;
l l.
long form	short form
_
.FT
INPUT	IN
OUTPUT	OUT
SYNTHESIZED	SYN
INHERITED	INH
THREAD
REVERSE	REV
IGNORE
VIRTUAL
.TE
.)z
.pp
The properties have the following meanings:
.i Input
attributes (or children) receive a value at node-creation time, whereas non-input
attributes may receive their values at later times.
.i Output
attributes are supposed to hold a value at the end of a node's existence,
whereas non-output
attributes may become undefined or unnecessary earlier.
.i Synthesized
and
.i inherited
describe the kinds of attributes occurring in attribute grammars. They have
no meaning for
.i ast .
The property
.i thread
supports so-called threaded attributes:
An attribute declaration [a THREAD] is equivalent to the declaration of a pair of attributes
with the suffixes In and Out: [aIn] [aOut].
These attributes have to be accessed with their full name including the suffixes.
The property
.i reverse
specifies how lists should be reversed. It is discussed in section 2.12.
The property
.i ignore
instructs
.i ast
to disregard or omit an attribute or a child. It is useful in connection with the concept of
views (see section 2.10.).
The property
.i virtual
is meaningful in attribute grammars. It is used to describe dependencies among attributes.
However, no space will be allocated for those attributes and the attribute computations for
those attributes will be omitted in the generated attribute evaluator.
Within
.i ast
the properties
.i input ,
.i reverse ,
and
.i ignore
are of interest, only.
.pp
Properties are specified either locally or globally. Local properties are valid for one
individual child or attribute. They are listed after the type of this item. Example:
.(b
.FT
Stats = Next: Stats IN REV [Pos: tPosition IN] [Level INH] .
.)b
Global properties are valid for all children and attributes
defined in one or several modules. They are valid in addition to the local properties that
might be specified. In order to describe global properties, a module may contain several
property clauses which are written in the following form:
.(b
.FT
PROPERTY properties [ FOR module_names ]
.)b
The listed properties become valid for the given modules. If the FOR part is missing, the
properties become valid for the module that contains the clause.
.(b
Example:
.sp 0.5
.FT
PROPERTY INPUT
PROPERTY SYN OUT FOR Mapping
.)b
.pp
Input attributes without initializer expression (see section 2.16.)
are included into the parameter list of the
node constructor procedures (see section 3). The global property
.i input
replaces the symbol '->' of former versions of
.i ast .
For compatibility reasons this symbol still works in a restricted way:
The symbol '->' could be included in a
list of children and attributes as a shorthand notation to separate
input from non-input items. In a list without this symbol all children and
attributes are treated as input items.
This meaning of the symbol '->' is still in effect as long as
.i ast
does not encounter a global property clause. After encountering such a clause,
local and global properties are in effect only \(en the symbol '->' is ignored.
.(b
Example:
.sp 0.5
.FT
Stats           = Next: Stats REV [Pos: tPosition] -> [Level INH] <
   If           = Expr Then: Stats Else: Stats .
   While        = -> Expr IN Stats IN .
> .
.)b
The node types of the example possess the children and attributes
listed in Table 2.
.(z L
.ce
Table 2: Example of Properties
.sp 0.5
.TS
center;
l l l l l.
node	selector	associated	kind	properties
type	name	type
_
Stats	Next	Stats	child	IN REV
	Pos	tPosition	attribute	IN
	Level	int	attribute	INH
_
If	Next	Stats	child	IN REV
	Pos	tPosition	attribute	IN
	Level	int	attribute	INH
	Expr	Expr	child	IN
	Then	Stats	child	IN
	Else	Stats	child	IN
_
While	Next	Stats	child	IN REV
	Pos	tPosition	attribute	IN
	Level	int	attribute	INH
	Expr	Expr	child	IN
	Stats	Stats	child	IN
.TE
.)z
.sh 2 "Subunits"
.pp
Usually, an
.i ast
specification is translated into one program module. This module
receives the name that immediately follows the keyword TREE.
If several modules contain a name, the first one is chosen.
If none of the modules contains a name, the default name
.i Tree
is used. For target languages C, C++, and Modula it is possible to generate
several modules out of an
.i ast
specification. Then there is exactly one module called
.i "main unit"
that describes the tree structure and an arbitrary number of modules called
.i subunits .
This is of interest if the generated source code becomes too large for one compilation unit.
Then either some or all desired procedures could be placed into separate subunits. In the
extreme, there might be a subunit for every procedure. It is possible to have two or
more versions of one procedure (e. g. WriteTREE) where every one uses a different view
(see section 2.10.).
.pp
The names of the main unit and the subunits are described in the header of an
.i ast
specification:
.(b
.FT
[ TREE [ Name [ PREFIX Name ] ] ] [ SUBUNIT Name ] [ VIEW Name ]
.)b
The name after the keyword VIEW is necessary if abstract syntax trees are to be processed
by program modules generated with other tools such as e. g.
.i puma
\*([[Groa\*(]] that need to know the definition of the tree structure.
.i Ast
has an option that requests to write a binary version of the tree definition to a file
whose name is derived from the name given after the keyword VIEW by appending the suffix
".TS" (Default: "Tree.TS").
.pp
Every unit has to be generated by a separate run of
.i ast .
If a subunit name is present, then a subunit is generated \(en otherwise a main unit is
generated. The options select the procedures to be included in the units.
It is probably wise not to include the subunit name in an
.i ast
specification. If this name is added "on the fly" with UNIX commands then different
subunits can be generated from one specification without the need to change it.
.(b
Example:
.sp 0.5
.FT
                                      ast -dim spec.ast
echo SUBUNIT read  | cat - spec.ast | ast -dir
echo SUBUNIT write | cat - spec.ast | ast -diw
.FR
or
.FT
echo TREE MyTree               | cat - spec.ast | ast -dim
echo TREE MyTree SUBUNIT read  | cat - spec.ast | ast -dir
echo TREE MyTree SUBUNIT write | cat - spec.ast | ast -diw
.)b
.sh 2 "Views"
.pp
An
.i ast
specification can be roughly seen as a collection of node types and associated children and
attributes. A so-called
.i view
selects a subset of this collection and it may attach further properties to some parts of
this collection. In the current version of
.i ast ,
views are not available if the target language is Java.
.pp
The concept of views is necessary for instance if two programs communicate a common data
structure via a file. Every program might need additional data which should neither appear in
the other program nor in the file. In order to make this work both programs must agree upon
the coding of the node types in the shared part of the data structure. This is accomplished
by using one common
.i ast
specification that contains the description of the complete data structure. Every program
uses a specific view and selects only those parts of the common specification that are of
interest. See Figure 1 for an example.
.(z
.PS
boxht	= .6
boxwid	= 1.2

	down
	box "program A" invis
	box "main unit Tree" "generated" "from A and C"
P:	box "subunit PutTree" "generated" "from C"
	box "other modules"

	right
	arrow at P.e right 0.75
F:	box "file"
	arrow right 0.75
G:	box "subunit GetTree" "generated" "from C"
	box "other modules" at G + (0, - boxht)
	up
	box "main unit Tree" "generated" "from B and C" at G + (0, boxht)
	box "program B" invis

	box "MODULE C" "common data" at F + (0, boxht * 3)
	box "MODULE B" "data specific" "to program B"
	box "MODULE A" "data specific" "to program A"
	box "specification" "file: spec.ast" invis
.PE
.sp
.ce 5
UNIX commands to generate the compilation units:
.sp 0.5
.FT
echo                 SELECT A C | cat - spec.ast | ast -dim
echo SUBUNIT PutTree SELECT   C | cat - spec.ast | ast -dip
echo                 SELECT B C | cat - spec.ast | ast -dim
echo SUBUNIT GetTree SELECT   C | cat - spec.ast | ast -dig
.FR
.sp
.ce
Fig. 1: Programs Sharing a Part of a Data Structure
.)z
.pp
Another need for views arises if several attribute evaluators operate one after the other on
one tree. The output attributes of a preceding evaluator become the input attributes of a
succeeding one. Here it is necessary to be able to change the properties of attributes. In
one view the attributes are regarded as output and in the other one they are regarded as
input. The usage of views for the specification of several attribute evaluators is described
in\*([<\*([[Grob\*(]]\*(>].
.pp
Furthermore, views are necessary if abstract syntax trees are to be processed by program
modules generated with other tools such as e. g.
.i puma
\*([[Groa\*(]] that need to know the definition of the tree structure.
In general, there might be several tree processing modules and every one uses a different
view. In this case, the views have to be communicated to the other tool in a file.
.i ast
has an option that requests to write a binary version of the tree definition to a file
whose name is derived from the name given after the keyword VIEW by appending the suffix
".TS" (Default: "Tree.TS", see section on "Subunits").
.pp
The concept of views is based on the global properties:
.(b
.FT
PROPERTY properties FOR module_names
.)b
allows the dynamic addition of properties.
.(b
.FT
PROPERTY IGNORE FOR module_names
.)b
allows the suppression of all definitions given in the listed modules. Additionally there is
the so-called select clause:
.(b
.FT
SELECT module_names
.)b
This is equivalent to:
.(b
.FT
PROPERTY IGNORE FOR module_names_not_given
.)b
.pp
It is wise to assign names to all modules of an
.i ast
specification, because otherwise they can not be selected with the select clause.
Furthermore, the property or select clauses that express views should probably not be included
in the file containing the
.i ast
specification. The reason is that this form is not flexible, because it is relatively hard to
change. It is better to add the one line that is necessary for views "on the fly" using UNIX
commands like echo and cat (see Figure 1).
.sh 2 "Prefixing"
.pp
A prefix can be added to the generated names that are derived from the names of
the node types. This mechanism for prefixing is available for the languages C
and simple C++. An
.i ast
specification can describe a prefix after the keyword PREFIX in addition to the
name for a tree specification using the following syntax:
.(b
.FT
[ TREE [ Name [ PREFIX Name ] ] ]
.)b
The prefix is added to the following kinds of generated names:
.(b L
.ce
.TS
center;
l l.
generated name	description
_
k<prefix><node type>	named constant to encode a node type in C and C++
<prefix><node type>	name of union member for a node type
n<prefix><node type>	node constructor procedures with attribute initialization
 	according to the type specific operations or an initializer expression
m<prefix><node type>	node constructor procedures with attribute initialization
	from a parameter list for \fIinput\fP attributes without initializer expression
.TE
.)b
.(b
Example:
.sp 0.5
.FT
TREE sql_tree PREFIX sql_ RULE
.sp 0.5
stmt            = <
   declare_stmt = ... .
   select_stmt  = ... .
> .
.)b
.lp
The generated code will include the following declarations:
.(b
.FT
// named constants
# define ksql_declare_stmt      2
# define ksql_select_stmt       3
.sp 0.5
// constructor procedures
extern tTree msql_declare_stmt (...);
extern tTree msql_select_stmt  (...);
.)b
.pp
Note, the tools
.i ag
and
.i puma
are aware of the prefix. Therefore, in the specifications for these tools the
node types are written without prefix. The prefix is generated automatically by
these tools.
.sh 2 "Reversal of Lists"
.pp
Recursive node types like
.i Stats
in the abstract grammar of the example below describe lists of subtrees.
There are at least two cases where it is convenient to be able to easily
reverse the order of the subtrees in a list. The facility provided by
.i ast
is a generalization of an idea presented in\*([<\*([[Par88\*(]]\*(>].
.sh 3 "LR Parsers"
.pp
Using LR parsers, one might be forced to parse a list using a left-recursive
concrete grammar rule because of the limited stack size.
.\" However, for some
.\" reason, the list should be right-recursive in the abstract syntax.
The concrete grammar rules of the following examples are written in the
input language of the parser generator
.i Lark
\*([[Groc\*(]] which is similar to the one of Yacc\*([<\*([[Joh75\*(]]\*(>].
The node constructor procedures within the semantic actions are the ones provided by
.i ast
(see section 3).
.(b
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats:                         {$$ = mStats0 ();      } .
Stats: Stats Stat ';'          {$$ = mStats1 ($2, $1);} .
Stat : WHILE Expr DO Stats END {$$ = mWhile  ($2, $4);} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = <
   Stats0       = .
   Stats1       = Stat Stats .
> .
.)b
A parser using the above concrete grammar would construct statement lists
where the list elements are in the wrong order, because the last statement
in the source would be the first one in the list. The WHILE rule represents a
location where statement lists are used.
.pp
To easily solve this problem
.i ast
can generate a procedure to reverse lists.
The specification has to describe how this should be done.
At most one child of every node type may be given the property
.i reverse .
The child's type has to be the node type itself or an associated base type.
The generated list reversal procedure ReverseTREE then reverses a list with
respect to this indicated child.
The procedure ReverseTREE has to be called exactly once for a list to be
reversed. This is the case at the location where a complete list is included
as subtree (e. g. in a WHILE statement).
.(b
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats:                         {$$ = mStats0 ();      } .
Stats: Stats Stat ';'          {$$ = mStats1 ($2, $1);} .
Stat : WHILE Expr DO Stats END {$$ = mWhile  ($2, ReverseTREE ($4));} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = <
   Stats0       = .
   Stats1       = Stat Stats REVERSE .
> .
.)b
.pp
It is possible to represent lists differently in an abstract syntax.
A more sophisticated solution is given in the next example.
The procedure ReverseTREE handles this variant, too.
.(b
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats:       {$$ = mNoStat ();} .
Stats: Stats IF Expr THEN Stats ELSE Stats END ';'
             {$$ = mIf ($3, ReverseTREE ($5), ReverseTREE ($7), $1);} .
Stats: Stats WHILE Expr DO Stats END ';'
             {$$ = mWhile ($3, ReverseTREE ($5), $1);} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = <
   NoStat       = .
   Stat         = Next: Stats REVERSE <
      If        = Expr Then: Stats Else: Stats .
      While     = Expr Stats .
   > .
> .
.)b
.sh 3 "LL Parsers"
.pp
Using LL parsers a similar problem as in the LR case can arise if extended
BNF is used. Lists are parsed with an iteration which is turned into a
loop statement as follows:
(The identifiers Stats0, Stats1, Stat0, and Stat1 in the concrete grammar
rules denote the symbolic access to the L-attribution mechanism provided by
.i Ell
\*([[GrV\*(]]. These identifiers should not be mixed up with the similar
ones used as node names in the abstract syntax.)
.(b L
Example:
.sp 0.5
concrete grammar (with tree building actions):
.sp 0.5
.FT
Stats: {*Stats0=mStats0 ();} ( Stat ';' {*Stats0=mStats1 (Stat1, Stats0);} ) * .
Stat : WHILE Expr DO Stats END {*Stat0=mWhile (Expr1, ReverseTREE (Stats1));} .
.sp 0.5
.sz +2
.r
abstract grammar:
.sp 0.5
.FT
Stats           = <
   Stats0       = .
   Stats1       = Stat Stats REVERSE .
> .
.)b
The list elements (statements) are inserted in the wrong order within the
first concrete grammar rule. The order is corrected by a call of the
procedure ReverseTREE in the second concrete grammar rule.
.sh 2 "Target Code"
.pp
An
.i ast
specification may include several sections containing so-called
.i "target code" .
These sections follow the keywords TREE or SUBUNIT.
Target code is code written in the target language which is copied unchecked
and unchanged to certain places in the generated module.
It has to be enclosed in braces '{' '}'. Balanced braces
within the target code are allowed. Unbalanced braces have to be escaped by a
preceding '\\' character. In general, the escape character '\\' escapes
everything within target code.
Therefore, especially the escape character itself has to be escaped.
.lp
The meaning of the sections is as follows:
.ip IMPORT: 3c
references to other target language modules, for example to provide definitions
of types for attribute declarations.
.ip EXPORT: 3c
declarations to be included in addition to the declaration of the tree type.
.ip GLOBAL: 3c
declarations to be included in the implementation module at global level. This
is where to put macro definitions to select code generation options.
.ip LOCAL: 3c
same as GLOBAL within
.i ast
for C and Modula. For C++ see below.
.ip BEGIN: 3c
initialization statements.
.ip CLOSE: 3c
finalization statements.
.lp
The exact use of these sections varies according to the target language, as
discussed below.
.sh 3 "C and C++"
.pp
The meaning of the sections is as follows:
.ip IMPORT: 3c
#include directives or typedef declarations to be included in the header file.
.ip EXPORT: 3c
declarations to be included in the header file after the declaration
of the tree type
.i tTREE .
.ip GLOBAL: 3c
declarations to be included in the implementation module at global level.
.ip LOCAL: 3c
In C: the same as GLOBAL.
.nf
In simple C++: member declarations to be included in the class declaration.
In proper C++: declarations to be included at namespace level.
.ip BEGIN: 3c
statements to initialize the declared data structures.
.ip CLOSE: 3c
statements to finalize the declared data structures.
.pp
.(b
Example in C or C++:
.sp 0.5
.FT
TREE SyntaxTree
IMPORT {# include "Idents.h" }
EXPORT {  typedef tSyntaxTree MyTree; }
GLOBAL {# include "Idents.h"
          typedef struct { unsigned Line, Column; } tPosition; }
BEGIN  { ... }
CLOSE  { ... }
.)b
.ne 15
.sh 3 "Modula-2"
.pp
The meaning of the sections is as follows:
.ip IMPORT: 3c
declarations to be included in the definition module at a place where IMPORT
statements are legal.
.ip EXPORT: 3c
declarations to be included in the definition module after the declaration
of the tree type
.i tTREE .
.ip GLOBAL: 3c
declarations to be included in the implementation module at global level.
.ip BEGIN: 3c
statements to initialize the declared data structures.
.ip CLOSE: 3c
statements to finalize the declared data structures.
.pp
.(b
Example in Modula-2:
.sp 0.5
.FT
TREE SyntaxTree
IMPORT { FROM Idents IMPORT tIdent; }
EXPORT { TYPE MyTree = tSyntaxTree; }
GLOBAL { FROM Idents IMPORT tIdent;
         TYPE tPosition = RECORD Line, Column: CARDINAL; END; }
BEGIN  { ... }
CLOSE  { ... }
.)b
.sh 3 "Java"
.pp
The meaning of the sections is as follows:
.ip IMPORT: 3c
'import' statements to allow unqualified reference to classes in other packages.
If no IMPORT sections are present
.i ast
includes import statements for classes in the reuse package.
If an IMPORT section is present then a statement equivalent to the following
should be included:
.(b
.FT
import de.cocolab.reuse.*;
.)b
.ip EXPORT: 3c
additional members to be included in the TREE class.
.ip GLOBAL: 3c
macro definitions to select code generation options.
.ip BEGIN: 3c
statements to be executed when the TREE class is loaded.
.ip CLOSE: 3c
statements to be executed when the TREE.close () method is called.
.pp
.(b
Example in Java:
.sp 0.5
.FT
TREE SyntaxTree
IMPORT { import de.cocolab.reuse.*;
         import com.package.*; }
EXPORT { public int member; }
GLOBAL { # define readMyType(a) ... }
BEGIN  { ... }
CLOSE  { ... }
.)b
.sh 2 "Common Node Fields"
.pp
Sometimes it is desirable to include certain fields into all node types.
For languages except Java this can be done directly by defining the macro
.i TREE_NodeHead
in the IMPORT or EXPORT target code sections. For Java, use the GLOBAL target
code section. In C, simple C++, and Modula these fields become members of the
union member or variant named
.i yyHead .
In proper C++ and Java these fields become members of the common super class.
They can be accessed as shown in the following examples:
.(b
Example in C or simple C++:
.sp 0.5
.FT
# define Tree_NodeHead int MyField1; MyType MyField2;
.sp 0.5
t->yyHead.MyField1 = ... ;
.)b
.(b
Example in proper C++:
.sp 0.5
.FT
# define Tree_NodeHead int MyField1; MyType MyField2;
.sp 0.5
t->MyField1 = ... ;
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
# define Tree_NodeHead MyField1: INTEGER; MyField2: MyType;
.sp 0.5
t^.yyHead.MyField1 := ... ;
.)b
.(b
Example in Java:
.sp 0.5
.FT
# define Tree_NodeHead public int MyField1; public MyType MyField2;
.sp 0.5
t.MyField1 = ... ;
.)b
.pp
Macros may be defined to process these additional fields during tree operations
(see Table 3). These macros are fully implemented only for C, C++, and Java.
They are similar to the type specific operations described in the next section
except that the argument is a reference to the node rather than a reference to
an individual attribute.
.(b L
.ce
Table 3: Node Head Operations
.sp 0.5
.TS
center;
c | c | c
l | l | l.
operation	macro name	purpose
_
initialization	beginNodeHead(a)	initialize values during node creation
finalization	closeNodeHead(a)	finalize values at node destruction
text read	readNodeHead(a)	read values
text write	writeNodeHead(a)	write values
binary read	getNodeHead(a)	get values
binary write	putNodeHead(a)	put values
copy    	copyNodeHead(a, b)	copy values
equal    	equalNodeHead(a, b)	test whether values are equal
.mc \(bv
XML output	writeXMLNodeHead(a)	write values in XML format
.mc
.TE
Note: In Java, the function of binary read/write is achieved via the
serialization facility.
.)b
.sh 2 "Type Specific Operations"
.pp
Procedures generated by
.i ast
apply several operations to attributes: initialization, finalization, text read
.mc \(bv
and write, binary read and write, copy, test for equality, and XML output
(see Table 4).
.mc
.i Initialization
is performed whenever a node is created. It can range from
assigning an initial value to the allocation of dynamic storage or the
construction of complex data structures.
.i Finalization
is performed immediately before a node is deleted and may e. g. release
dynamically allocated space. The
.i read
and
.i write
operations enable the readers and writers to handle the
complete nodes including all attributes, even those of user-defined types.
The operation
.i copy
is needed in order to duplicate values of attributes of user-defined types. By default,
.i ast
just copies the bytes of an attribute in order to duplicate it.
Therefore, pointer semantics is assumed for attributes of a pointer type.
If value semantics is needed, the user has to take care about this operation.
The operation
.i equal
checks whether two attributes are equal. It is used as atomic operation for the procedure
that tests the equality of trees.
.mc \(bv
The operation
.i writeXML
is used for XML output of attributes.
.mc
.(z L
.ce
Table 4: Type Specific Operations
.sp 0.5
.TS
center;
c | c | c | c
l | l | l | l.
operation	macro name	language	default macro
_
initialization	beginTYPE(a)
finalization	closeTYPE(a)
text read	readTYPE(a)	C or C++	yyReadHex (& a, sizeof (a));
		Modula-2	yyReadHex (a);
		Java	a = new TYPE (yyin.readL ());
text write	writeTYPE(a)	C or C++	yyWriteHex (& a, sizeof (a));
		Modula-2	yyWriteHex (a);
		Java	yyout.write (a.toString ());
binary read	getTYPE(a)	C or C++	yyGet (& a, sizeof (a));
		Modula-2	yyGet (a);
		Java	see note
binary write	putTYPE(a)	C or C++	yyPut (& a, sizeof (a));
		Modula-2	yyPut (a);
		Java	see note
copy    	copyTYPE(a, b)	Java	a = (b);
equal    	equalTYPE(a, b)	C or C++	memcmp (& a, & b, sizeof (a)) == 0
		Modula-2	yyIsEqual (a, b)
		Java	(a.equals (b))
.mc \(bv
XML output	writeXMLTYPE(a)	C or C++	yyWriteHex (& a, sizeof (a));
		Modula-2	yyWriteHex (a);
		Java	
.mc
.TE
Note: In Java, the function of binary read/write is achieved via the
serialization facility.
.)z
.pp
The operations are type specific in the sense that every type has its own
set of operations. All attributes having the same type (target type name)
are treated in the same way. If the target language permits type aliases,
choosing different type names for one type
introduces subtypes and allows to treat attributes of different subtypes
differently. Type specific operations for the predefined types of a target
language and for the types defined in the library
.i reuse
\*([[Groa\*(],Grob\*(],Nas\*(]]
are predefined within
.i ast
(see Appendices 9 to 13). For user-defined types,
.i ast
assumes default operations (see Table 4).
The procedures yyReadHex and
yyWriteHex read and write the bytes of an attribute as hexadecimal values.
The procedures yyGet and
yyPut read and write the bytes of an attribute unchanged (without conversion).
The operations are defined by a macro mechanism.
The procedure yyIsEqual checks the bytes of two attributes for equality.
TYPE is replaced by the concrete type name.
.i a
is a formal macro parameter referring to the attribute.
The predefined procedures mentioned in Table 4 use the global variable
.i yyf
of type FILE * (C, C++)\*([<\*([[Grob\*(]]\*(>]
or IO.tFile (Modula-2)\*([<\*([[Groa\*(]]\*(>]
or the static variables yyin of type de.cocolab.reuse.CocktailReader and
yyout of type de.cocolab.reuse.CocktailWriter (Java)\*([<\*([[Nas\*(]]\*(>]
describing the file used by the readers and writers.
.pp
Tree-valued attributes are always of type tTREE in C, C++ and Modula-2 and so the
same set of operations is used regardless of whether the attribute is declared to
be of type tTREE or one of the node types. In Java there is a separate set of
operations for each node type.
.pp
It is possible to redefine the operations by including new macro definitions
in the GLOBAL section. The following example demonstrates the syntax for
doing this. It shows how records of the type tPosition might be handled and
how subtypes can be used to initialize attributes of the same type differently.
Recall that
.i ast
already knows how to handle tPosition \(en what follows is only a demonstration.
.(b
Example in C or C++:
.sp 0.5
.FT
IMPORT {
# include "Sets.h"
typedef struct { unsigned Line, Column; } tPosition;
typedef tSet Set100;
typedef tSet Set1000;
}
.sp 0.5
GLOBAL {
# define begintPosition(a) a.Line = 0; a.Column = 0;
# define readtPosition(a)  fscanf (yyf, "%d,%d", & a.Line, & a.Column);
# define writetPosition(a) fprintf (yyf, "%d, %d", a.Line, a.Column);
.sp 0.5
# define beginSet100(a)    MakeSet    (& a, 100);
# define closeSet100(a)    ReleaseSet (& a);
# define readSet100(a)     ReadSet    (yyf, & a);
# define writeSet100(a)    WriteSet   (yyf, & a);
.sp 0.5
# define beginSet1000(a)   MakeSet    (& a, 1000);
# define closeSet1000(a)   ReleaseSet (& a);
# define readSet1000(a)    ReadSet    (yyf, & a);
# define writeSet1000(a)   WriteSet   (yyf, & a);
}
.)b
.(b
Example in Modula-2:
.sp 0.5
.FT
IMPORT {
   FROM Sets      IMPORT tSet;
   TYPE tPosition = RECORD Line, Column: CARDINAL; END;
   TYPE Set100    = tSet;
   TYPE Set1000   = tSet;
}
.sp 0.5
GLOBAL {
   FROM IO        IMPORT ReadI, WriteI, WriteC;
   FROM Sets      IMPORT MakeSet, ReleaseSet, ReadSet, WriteSet;
.sp 0.5
# define begintPosition(a) a.Line := 0; a.Column := 0;
# define readtPosition(a)  a.Line := ReadI (yyf); a.Column := ReadI (yyf);
# define writetPosition(a) WriteI (yyf, a.Line, 0); WriteC (yyf, ' '); \\
                           WriteI (yyf, a.Column, 0);
.sp 0.5
# define beginSet100(a)    MakeSet    (a, 100);
# define closeSet100(a)    ReleaseSet (a);
# define readSet100(a)     ReadSet    (yyf, a);
# define writeSet100(a)    WriteSet   (yyf, a);
.sp 0.5
# define beginSet1000(a)   MakeSet    (a, 1000);
# define closeSet1000(a)   ReleaseSet (a);
# define readSet1000(a)    ReadSet    (yyf, a);
# define writeSet1000(a)   WriteSet   (yyf, a);
}
.)b
.(b
Example in Java:
.sp 0.5
.FT
IMPORT {
   import de.cocolab.reuse.*; // including Set and Position
   // The C preprocessor is used within ast, so we can define
   // type aliases like this:
   # define Set100 Set
   # define Set1000 Set
}
.sp 0.5
GLOBAL {
// Note in Java we have the type "Position" rather than "tPosition".
# define beginPosition(a)  a = new Position (0, 0);
# define readPosition(a)   a.line = yyin.readI (); a.column = yyin.readI ();
# define writePosition(a)  yyout.write (a.line); yyout.write (' '); \\
                           yyout.write (a.column);
.sp 0.5
# define beginSet100(a)    a = new Set (100);
# define closeSet100(a)    a = null;
# define readSet100(a)     a = readSet (yyin);
# define writeSet100(a)    writeSet    (yyout, a);
.sp 0.5
# define beginSet1000(a)   a = new Set (1000);
# define closeSet1000(a)   a = null;
# define readSet1000(a)    a = readSet (yyin);
# define writeSet1000(a)   writeSet    (yyout, a);
}
.sp 0.5
EXPORT {
.sp 0.5
   private Set readSet (CocktailReader in) {
      // code to read a set
   }
.sp 0.5
   private void writeSet (CocktailWriter out, Set s) {
      // code to write a set
   }
}
.)b
.pp
In the case of C++ the modules
.i Idents
and
.i StringM
of the library
.i reuse
\*([[Grob\*(]] are implemented as
classes. Thus several objects might be created from these classes.
If attributes are declared with the types
.i tIdent
or
.i tStringRef
then
.i ast
will generate code that uses some methods of these classes.
Now it has to be described to which of the objects a method call refers to.
This is handled in the following way. The generated code looks like this:
.(b
.FT
# ifndef Idents_PREFIX
# include "Global.h"
# define Idents_PREFIX gIdents.
# endif
.sp 0.5
# ifndef String_PREFIX
# include "Global.h"
# define String_PREFIX gStringM.
# endif
.sp 0.5
Idents_PREFIX NoIdent;
Idents_PREFIX MakeIdent   (...);
Idents_PREFIX WriteIdent  (...);
.sp 0.5
String_PREFIX PutString   (...);
String_PREFIX WriteString (...);
.)b
By default, the globally created objects
.i gIdents
and
.i gStringM
from the library
.i reuse
are used. This can be changed by providing definitions for the macros
.i Idents_PREFIX
and
.i String_PREFIX
in the GLOBAL section. Example:
.(b
.FT
# include "Idents.h"
# include "StringM.h"
.sp 0.5
# define Idents_PREFIX my_idents_object.
# define String_PREFIX my_string_object->
.sp 0.5
Idents    my_idents_object;
StringM * my_string_object = new StringM;
.)b
.lp
In the case of Java there is a similar consideration with respect to the
.i Ident
type and the associated
.i IdentTable
class\*([<\*([[Nas\*(]]\*(>].
The generated code looks like this:
.(b
.FT
# ifndef Idents_PREFIX
# define Idents_PREFIX Global.idents.
# endif
.sp 0.5
Idents_PREFIX makeIdent (...);
.)b
The prefix is only needed when calling
.i makeIdent
to create an new
.i Ident
instance.  All other operations are simply methods on an
.i Ident
object.  By default, the statically created object
.i idents
from the library class
.i Global
is used. This can be changed by providing a definition for the macro
.i Idents_PREFIX
in the GLOBAL section. Example:
.(b
.FT
GLOBAL {
# define Idents_PREFIX my_idents_object.
}
.sp 0.5
EXPORT {
static IdentTable my_idents_object = new IdentTable (100);
}
.)b
.sh 2 "Attribute Initialization"
.pp
An initial value for an attribute can be specified by a type specific
operation as described in the previous chapter or by an attribute specific
initializer expression. The latter is described by the following notation:
.(b
.FT
[ Name : Type := Expression ]
.)b
The expression is written in the syntax of the implementation language.
It is evaluated at node creation time. Its value is assigned as
initial value to the declared attribute. An attribute specific initializer takes
precedence over a type specific initialization. An attribute specific
initializer implies the property INPUT for this attribute. However, this
attribute is not included in the list of parameters of the constructor
procedure.
.(b
Example:
.sp 0.5
.FT
[ count : int := 0 ]
.)b
.sh 2 "Storage Management"
.pp
The storage management for the nodes to be created is completely automatic,
by default. Usually, the user does not have to care about it.
For Java the operation new is used for node allocation,
deallocation is provided by the garbage collector.
For proper C++ the operation new is used for node allocation, too,
deallocation has to be done by explicit calls of the function
.i ReleaseTREE
which is based on the operation delete.
For the languages C, simple C++, and Modula
the predefined storage management works as follows: Every generated tree
module contains its own heap manager which is designed in favour of speed.
The constructor procedures use an in-line code sequence to obtain storage
(see below). The heap manager does not maintain free lists. It only allows
to free the complete heap of one module using the procedure
.i ReleaseTREEModule .
The procedure
.i ReleaseTREE
does not free the node space (except for proper C++),
it only finalizes the attributes of the nodes.
The predefined behaviour can be changed by including two macro definitions
in the GLOBAL section.
.ne 5
.lp
For C the macros are initialized as follows:
.(b
.FT
# define yyALLOC(size1, size2) \\
  (TREE_PoolFreePtr -= size1) >= TREE_PoolStartPtr ? \\
     (tTREE) TREE_PoolFreePtr : TREE_Alloc (size2)
# define yyFREE(ptr, size)
.ne 5
.)b
For simple C++ the macros are initialized as follows:
.(b
.FT
# define yyALLOC(size1, size2) yyALLOCi (size1, size2)
# define yyFREE(ptr, size)
inline tTREE TREE::yyALLOCi (unsigned long yysize1, unsigned long yysize2)
 { return TREE_PoolFreePtr >= TREE_PoolStartPtr + yysize1 ?
  (tTREE) (TREE_PoolFreePtr -= yysize1) : TREE_Alloc ((unsigned short) yysize2); }
.)b
.ne 5
For Modula-2 the macros are initialized as follows:
.(b
.FT
# define yyALLOC(ptr, size) ptr := yyPoolFreePtr; \\
  IF SYSTEM.ADDRESS (ptr) >= yyPoolMaxPtr THEN ptr := yyAlloc (); END; \\
  INC (yyPoolFreePtr, size);
# define yyFREE(ptr, size)
.)b
The following lines switch the heap manager to a global
storage allocator with free lists:
.(b
.FT
# define yyALLOC(size1, size2) (tTREE) Alloc (size2)
# define yyFREE(ptr, size) Free (size, ptr);
.)b
Now
.i ReleaseTREE
will work as expected whereas
.i ReleaseTREEModule
does not work any more.
.pp
In the cases of C and simple C++, the macro yyALLOC has two size arguments:
While 'size2' specifies the number of bytes needed for the creation
of a tree node, 'size1' specifies the corresponding
.i aligned
size. The aligned size 'size1' might be increased in comparison to 'size2' in
order to fullfill the alignment requirements of the current machine.
yyALLOC has to define an expression which yields a pointer to a storage area
of at least 'size2' bytes.
The macro yyFREE is used to indicate that 'size' bytes at the location 'ptr'
can be released.
.sh 1 "About the Generated Program Module"
.pp
.i Ast
is able to generate code for two types of target languages: procedural and
object-oriented.
For the procedural languages C and Modula-2
node types are mapped to members of a variant or
union type, and the generated prodedures take an argument of this type.
Procedure names are of the form OperationTREE where TREE is replaced by the
tree module name, default Tree.
The mapping for simple C++ is similar to the C mapping,
and so it is described under the heading "Procedural Mapping".
.pp
For the object-oriented languages proper C++ and Java
node types are mapped to classes and in general the
procedures are methods applied to an instance and take no tree argument.
Method names are of the form Operation or operation.
As the names are within a
name scope there is no need to qualify them with the name of the tree module.
.pp
Though the two schemes have much in common, there is enough difference to
warrant separate descriptions.
.sh 2 "Procedural Mapping"
.pp
A specification is translated by
.i ast
into a program module consisting of a definition part and an implementation part.
Only the definition part or header file respectively is sketched here
\(en the Appendices 4, 5, and 7 contain the general schemes.
The definition part contains primarily type declarations describing the
structure of the tree nodes and the headings of the generated procedures.
.pp
Every non-abstract node type is turned into a constant declaration and
a struct or record declaration.
That is quite simple, because node types and record declarations are almost the same
concepts except for the extension mechanism and some shorthand notations.
All these records become members of a union type or a variant record used to describe
tree nodes in general. This variant record has a tag field called
.i Kind
which stores the code of the node type.
A pointer to the variant record is a type representing trees.
Like all generated names, this pointer type is derived from the name of the specification.
Table 5 briefly explains the exported objects (replace TREE by the name of the generated
module (see section 2.9.) and <node type> by all the names of node types).
In Modula-2 the names of the constants to code the node types and the names of the
record variants are identical to the names of the node types.
In other languages only the names of the union members are identical, the constant
names are prefixed with the letter 'k' standing for
.i Kind .
.pp
In simple C++ a class named TREE is generated, additionally.
All exported variables and procedures as well as the internal data structure
are declared as members of this class.
Thus it is possible to create and delete several tree objects which are
independent from each other. This allows for a detailed control of memory
usage, for example.
In proper C++ a class named yyTREE is generated which serves as a base class for
all node types.
.(z L
.ce
Table 5: Generated Objects and Procedures (Class Members)
.sp 0.5
.TS
center;
l l.
object/procedure	description
_
k<node type>	named constant to encode a node type in C and C++
<node type>	named constant to encode a node type in Modula-2
<node type>	name of union member or record variant for a node type
tTREE	pointer type, refers to variant record type describing all node types
TREERoot	variable of type tTREE, can serve as tree root
.\" 	(additional variables can be declared)
TREE_NodeName	array mapping node types to names (strings) in C and C++
.\" TREE_NodeSize	array mapping node types to the size of the nodes in C and C++
.\" yyNodeSize	array mapping node types to the size of the nodes in Modula-2
_
MakeTREE	node constructor procedure without attribute initialization
TREE_IsType	test a node for a certain type
n<node type>	node constructor procedures with attribute initialization
 	according to the type specific operations or an initializer expression
m<node type>	node constructor procedures with attribute initialization
	from a parameter list for \fIinput\fP attributes without initializer expression
ReleaseTREE	node or graph finalization procedure,
	all attributes are finalized, all node space can be deallocated
ReleaseTREEModule	deallocation of all graphs managed by a module
WriteTREENode	text node writer procedure
ReadTREE	text graph reader procedure
WriteTREE	text graph writer procedure
WriteTREEXML	XML graph writer procedure
GetTREE	binary graph reader procedure
PutTREE	binary graph writer procedure
TraverseTREETD	top down graph traversal procedure (reverse depth first)
TraverseTREEBU	bottom up graph traversal procedure (depth first search)
ReverseTREE	procedure to reverse lists
ForallTREE	list traversal procedure
CopyTREE	graph copy procedure
IsEqualTREE	equality test procedure for trees
CheckTREE	graph syntax checker procedure
QueryTREE	graph browser procedure with text user interface
DrawTREE	graph browser procedure with graphic user interface
.\" SetDepthTREE	set drawing depth of graph browser procedure
.\" SetBoxTREE	set geometry for nodes of graph browser procedure
ConfigureTREE	procedure to configure some properties of the tree module
BeginTREE	procedure to initialize user-defined data structures
CloseTREE	procedure to finalize user-defined data structures
.TE
.)z
.pp
The parameters of the procedures
.i m<node type>
have to be given in the order of the
.i input
attributes without initializer expression in the specification.
Attributes of the base type (recursively)
precede the ones of the derived type. The procedure
.i ForallTREE
allows for the execution of a procedure given as parameter for every element (node) of a
list. Lists are indicated by the property REVERSE - the child with this property is the
pointer to the succeeding list element. The procedures
.i TraverseTREETD
and
.i TraverseTREEBU
visit all nodes of a tree or a graph respectively. At every node a procedure given as
parameter is executed. An assignment of a tree or graph to a variable of type
.i tTREE
can be done in two ways: The usual assignment operators '=' or ':=' yield pointer
semantics. The procedure
.i CopyTREE
yields value semantics by duplicating a given graph.
The procedure
.i IsEqualTREE
is used to test structural equivalence of trees. It is not designed to
handle general graphs.
.pp
The construction of the pointer and the union type above does not enforce
the tree typing rules through the types of the target language. In fact, it
is possible to construct trees that violate the specification. The
user is responsible to adhere to the type rules. Most of the generated
procedures do not care about the type rules. Moreover, type violations are
possible and such erroneous trees are handled correctly by all procedures.
The procedure
.i CheckTREE
can be used to check if a tree is properly typed. In case of typing errors
the involved parent and child nodes are printed on
.i "standard error" .
.pp
The binary graph writer procedure
.i PutTREE
produces a binary file containing the graph in linearized form. The nodes are
written according to a depth first traversal. Edges are either represented by
concatenation of nodes or by symbolic (integer) labels.
The following kinds of records specified by C types are written to the output
file:
.br
.ne 14
.(b
.FT
# define yyNil          0374
# define yyNoLabel      0375
# define yyLabelDef     0376
# define yyLabelUse     0377
.sp 0.5
typedef unsigned char  TREE_tKind;   /* less than 252 node types */
typedef unsigned short TREE_tKind;   /* more than 251 node types */
typedef unsigned short TREE_tLabel;
.sp 0.5
struct { char yyNil     ;                               } NoTree;
struct { char yyLabelUse; TREE_tLabel <label>;          } LabelUse;
struct { char yyLabelDef; TREE_tLabel <label>;
                          TREE_tKind Kind; <attributes> } LabelDef;
struct { char yyNoLabel ; TREE_tKind Kind; <attributes> } NoLabel;
struct { char Kind      ; <attributes>                  } Kind;
.)b
Record fields whose name starts with
.i yy
have a constant value as defined.
<label> is an integer representing a certain address.
<attributes> are written with the type specific
.i put
macros which either copy the bytes of an attribute unchanged or do whatever the user
has specified. If the value of the tag field Kind is less than 252 then the format
.i Kind
is used, otherwise the format
.i NoLabel
is used to write unlabeled nodes.
.pp
Graphs that have been written to a file with the procedure
.i PutTREE
can be read from file into memory with the procedure
.i GetTREE .
.pp
The procedures
.i WriteTREE
and
.i ReadTREE
perform input and output of graphs similar to the procedures
.i PutTREE
and
.i GetTREE .
The differences are that a human readable text notation is used which
causes the files to become considerably larger.
The procedure
.i WriteTREEXML
performs output of a graph in XML format.
.pp
The procedure
.i ConfigureTREE
allows the configuration of some parameters of the tree module.
It has two arguments of type string.
The first argument describes the parameter and the second argument
gives its value. Table 6 describes the possible parameters, the possible values,
and the corresponding default values.
.(z L
.ce
Table 6: Parameters for the procedure ConfigureTREE/Configure
.sp 0.5
.TS
center;
l l n l.
Parameter	Value	Default
_
CheckReportNoTree	0/1	1	= true
CheckReportNodes	0/1	1	= true
DrawBoxHeight   	n	20	pixels
DrawBoxWidth      	n	60	pixels
DrawDepth         	n	6	nodes
DrawLength      	n	256	nodes
DrawFileName      	filename
TreatTVAasChild 	0/1	0	= false
.TE
.)z
.pp
By default the procedure CheckTREE complains about children having the value
NoTREE. If the parameter CheckReportNoTree is set to 0 then CheckTREE will
allow children having the value NoTREE. Also, by default the procedure CheckTREE
will output nodes that violate the typing rules using the procedure
WriteTREENode. This can be switched off by setting the parameter
CheckReportNodes to 0.
.pp
The parameters whose names start with the prefix Draw control some aspects of
the graphical tree browser. The parameters DrawBoxHeight and DrawBoxWidth
control the sizes of the rectangles denoting tree nodes.
The horizontal and vertical distances between the nodes as well as
the number of chatacters used to label a node are computed automatically
depending on the size of a rectangle.
The parameter DrawDepth controls to which depth tree nodes should be displayed.
The parameter DrawLength controls to which length nodes in a list should be
displayed.
The parameter DrawFileName can be used to specify the name of the source file
for a tree or graph.
.pp
By default, tree-valued attributes are treated like normal attributes: They are
not traversed during any tree-traversing operations. By setting the parameter
TreatTVAasChild to 1 tree-valued attributes are treated like children in some of
the I/O procedures: They are traversed and processed by the procedures
ReadTREE, WriteTREE, GetTREE, and PutTREE. The support for changing the
treatment of tree-valued attributes during runtime is provided by source code
which is compiled conditionally. If this support for tree-valued attributes is
needed it has to be enabled by defining the preprocessor symbol SUPPORT_TVA.
This can be done either using a compiler option (-DSUPPORT_TVA, /DSUPPORT_TVA)
or by including a directive in the IMPORT section:
.(b
.FT
# define SUPPORT_TVA
.)b
.sh 2 "Object-Oriented Mapping"
.pp
A specification is translated by
.i ast
into a program module consisting of a class declaration for every non-abstract
node type.
Only the public interfaces are sketched here
\(en the Appendices 6 and 8 contain the general schemes.
.pp
Every non-abstract node type is turned into a constant declaration and a class
declaration.
That is quite simple, because node types and classes are the same
concepts as are the extension mechanism and single inheritance (abstract node types
are not mapped to classes and so we do not need multiple inheritance in the
target language).
All these classes have a common base class used to describe
tree nodes in general.
In proper C++, this class has a member called
.i Kind
which holds the code of the node type.
In Java, this class has a method called
.i yyKind
which returns the code of the node type.
A reference to the base class is a type representing trees.
Like all generated names, this class type is derived from the name of the specification.
Table 7 briefly explains the exported objects (replace TREE by the name of the generated
module (see section 2.9.) and <node type> by all the names of node types).
The names of the node classes are the same as in the specification, the constant
names are prefixed with the letter 'k' standing for
.i Kind .
.(z L
.ce
Table 7: Generated Objects and Class Members
.sp 0.5
.TS X
center center;
l s l
l l l.
object/function/method	description
C++	Java
_
k<node type>	k<node type>	named constant to encode a node type
<node type>	<node type>	name of class for a node type
yyTREE	TREE	class type, a supertype of all node types
tp<node type>	-	pointer type for every node class
tTREE	-	pointer type, refers to super class yyTREE
Root	-	variable of type tTREE, can serve as tree root
NodeName	NodeNames	array mapping node types to names (strings)
_
Make	make	node constructor procedure without attribute initialization
IsType	isType	test a node for a certain type
Release	-	node or graph finalization procedure,
		all attributes are finalized, all node space is deallocated
<node type> ()	<node type> ()	node constructor procedures with attribute initialization
 		according to type specific operations or initializer expression
<node type> (...)	<node type> (...)	node constructor procedures with attribute initialization
		from a parameter list for \fIinput\fP attributes w/o initializer expr.
WriteNode	writeNode	text node writer procedure
Read	read	text graph reader procedure
Write	write	text graph writer procedure
WriteXML	-	XML graph writer procedure
Get	get	binary graph reader procedure
Put	put	binary graph writer procedure
TraverseTD	traverseTD	top down graph traversal procedure (reverse depth first)
TraverseBU	traverseBU	bottom up graph traversal procedure (depth first search)
Reverse	reverse	procedure to reverse lists
Forall	forall	list traversal procedure
Copy	copy	graph copy procedure
	clone	same as copy in Java
IsEqual	isEqual	equality test procedure for trees
Check	check	graph syntax checker procedure
Query	query	graph browser procedure with text user interface
Draw	-	graph browser procedure with graphic user interface
Configure	-	procedure to configure some properties of the tree module
Begin	begin	procedure to initialize user-defined data structures
Close	close	procedure to finalize user-defined data structures
.TE
.)z
.pp
The parameters of the constructors have to be given in the order of the
.i input
attributes without initializer expression in the specification.
Attributes of the base type (recursively)
precede the ones of the derived type. The procedure
.i Forall/forall
allows for the execution of a procedure given as parameter for every element (node) of a
list. Lists are indicated by the property REVERSE - the child with this property is the
reference to the succeeding list element. The procedures
.i TraverseTD/traverseTD
and
.i TraverseBU/traverseBU
visit all nodes of a tree or a graph respectively. At every node a procedure given as
parameter is executed.
.pp
In C++, procedure parameters are implemented by function pointers.
In Java, procedure parameters are implemented via an interface TREE.ProcTree which
has a single method
.i "proc (TREE yyt)" .
This method has no `throws' clause, and so it is necessary to catch all exceptions that
might be thrown by the code within the user procedure.  If it is desired to retain the
default action for exceptions thrown within such procedures then the following scheme
may be used to 'hide' the exception from the ProcTree interface.
.br
.ne 20
.(b
.FT
import de.cocolab.reuse.MaskedException;
\&...
Tree t;
try {
  t.traverseTD (new Tree.ProcTree () {
    public void proc (Tree yyt) {
      try {
        // code which might throw an IOException
        yyt.writeNode (out);
      }
      catch (java.io.IOException e) {
        // wrap the exception in a MaskedException, which need not be caught
        throw new MaskedException (e);
      }
    }
  });
} catch (MaskedException e) {
  // unwrap and rethrow exception, to get the usual stack trace and termination
  throw (java.io.IOException) (e.exception);
}
.)b
.pp
An assignment of a tree or graph to a variable of type
.i TREE
can be done in two ways: The usual assignment operator '=' yields reference
semantics. The procedure
.i Copy/copy
yields value semantics by duplicating a given graph.
.pp
The procedure
.i IsEqual/isEqual
is used to test structural equivalence of trees.  It is not designed to
handle general graphs.
.pp
The construction of the node classes enforces
the tree typing rules through the types of the target language. Therefore, it
is not possible to construct trees that violate the specification except by
using
.i NoTREE
or
.i null
as a value for a child or by using type casts.
The procedure
.i Check/check
can be used to check if a tree is properly constructed. In case of typing errors
the involved parent and child nodes are printed on
.i "standard error" .
.pp
The binary graph writer procedure
.i Put/put
produces a binary file containing the graph in linearized form.
In proper C++ the same format is used as in the cases of C and simple C++.
In Java this is implemented by object serialization.
.pp
Graphs that have been written to a file with the procedure
.i Put/put
can be read from file into memory with the procedure
.i Get/get .
.pp
The procedures
.i Write/write
and
.i Read/read
perform input and output of graphs in human readable text notation.
The user is responsible
for making sure that appropriate macros or procedures are defined for converting
any user defined attribute types to and from strings, see
"Type Specific Operations".
.pp
The procedure
.i Configure
allows the configuration of some parameters of the tree module.
For details see the chapter "Procedural Mapping".
.sh 2 "Graph Browsers"
.pp
The procedure
.i QueryTREE/Query/query
allows to browse a tree and to inspect one node at a time using an
(old-fashioned) text user interface. A node including the names and
the values of its attributes is printed on
.i "standard output" .
Then the user is prompted to provide one of the following commands from
.i "standard input" :
.(b
.ta 4c
parent	display parent node
goto <n>	display node at line number <n>
quit	quit procedure
<selector>	display specified child (first match, abbreviation possible)
<selector><space>	display specified child (exact match, no abbreviation)
.)b
All commands can be abbreviated to an unambiguous prefix. Usually, a first match strategy is
used to determine a child from its (abbreviated) selector name. With this search strategy,
children whose name is a prefix of others may not be accessible. If an unabbreviated selector
name is supplied together with a following space character an exact match strategy is used,
which allows to access every child. The empty command behaves like
.i parent .
.(z
.sp
.PSPIC ast-browser.ps
.sp 3
.ce
Screenshot of the graphic browser
.sp 2
.)z
.pp
The procedure
.i DrawTREE/Draw
provides a browser for trees and graphs with a graphic user interface.
Nodes are displayed as labelled rectangles and edges (links to children)
as arrows. A clearly arranged layout is calculated automatically.
Attributes can be viewed similarly to
.i QueryTREE/Query/query .
The graphic browser provides scrolling, zooming, and direct access to the
nodes using menu and mouse operations.
.lp
See the screenshot for an example of the browser window.
It displays the abstract syntax tree (graph) for a sequence of three MiniLax
statements. (The identifier
.i skip
denotes the call of a procedure.)
.(b I
.FT
IF n < 0 THEN n := 1 ELSE skip END;
n := 2;
skip;
.)b
The nodes for the three statements are arranged underneath each other at the
left-hand side. The children of the node If describe the condition, the
THEN part, and the ELSE part of the IF statement. The children of the node
Assign describe the left-hand side and the right-hand side of the assignment
statement. The node Ident with the thick border has been selected.
The attributes and children of this node are shown in a subwindow.
.lp
The procedure
.i DrawTREE/Draw
can be generated for the languages C, C++, and Modula-2.
For compilation and linking
the public domain package tcl/tk version 8.3 or higher is required.
Under Unix linking is done with commands such as for example:
.(b
.FT
cc -L$X11/lib -ltk83 -ltcl83 -lX11 -lm -ldl .../libreuse.a   or
cc -L$X11/lib -ltk8.3 -ltcl8.3 -lX11 -lm .../libreuse.a -lc
.)b
.ne 30
.lp
The following is the online help
information describing the meaning of the mouse actions and menu buttons:
.(l L
.FT
 ----------------------------------------------------------------------------
 Mouse actions in browser window          Meaning
 ----------------------------------------------------------------------------
 single click with any    button on node  select this node
 single click with left   button on edge  select node at arrow head
 single click with right  button on edge  select node at arrow tail
 single click with any    button on folding indicator
                                          select node at arrow tail

 double click with left   button on node  select and open  this node =
                                             show attributes in a subwindow
 double click with middle button on node  select and open  this node =
                                             show attributes in new subwindow
 double click with right  button on node  select and close this node =
                                             dismiss subwindow with attributes
 double click with left   button on edge  select and open node at arrow head =
                                             show attributes in a subwindow
 double click with middle button on edge  select and open node at arrow head =
                                             show attributes in new subwindow
 double click with right  button on edge  select and open node at arrow tail =
                                             show attributes in a subwindow
 double click with any    button on folding indicator
                                          select node at arrow tail and
                                             start new browser at selected node

 press, move, and release middle button   move graph at high speed
 ----------------------------------------------------------------------------
 Mouse actions in attribute window        Meaning
 ----------------------------------------------------------------------------
 single click with left button on child   select and open child node =
    (indicated by an asterisk '*')           show attributes in a subwindow
 single click with left button on attribute (tree-valued)
    (indicated by a plus '+')             start new browser at attribute value
 single click with left button on attribute (not tree-valued)
                                             trigger application specific action

 press, move, and release middle button   move attribute display at high speed
 ----------------------------------------------------------------------------
 Mouse actions in source window           Meaning
 ----------------------------------------------------------------------------
 single click with left button on line    select node corresponding to line and
                                             position selected node at center

 press, move, and release middle button   move source at high speed
 ----------------------------------------------------------------------------
 Menu actions in main window              Meaning
 ----------------------------------------------------------------------------
 goto                                     select node at certain line number
 root                                     select root node
 home                                     position selected node at home
 top                                      position selected node at top
 center                                   position selected node at center
 open                                     open selected node =
                                             show attributes in a subwindow
 push                                     open selected node =
                                             show attributes in new subwindow
 close                                    dismiss subwindow with attributes
 draw                                     start a new browser at selected node
 source                                   display source file with highlighting
 print                                    dump window in Postscript to a file
 help                                     display this help information
 config                                   configure tree browser
 exit                                     exit tree browser
 ----------------------------------------------------------------------------
 Zoom with the scale in the menu bar. Zooming is performed relative to the
 center of the window. Zooming is logarithmic:

     2.0 = 400 %
     1.0 = 200 %
     0.0 = 100 %
    -1.0 =  50 %
    -2.0 =  25 %

 The labels of the nodes are the names of the node types.
 They are truncated to the first characters in order to fit.
 After opening a node the full information becomes visible in a subwindow.
 Arrows at the right-hand side of a node or without a target node indicate
 omitted subtrees. These arrows are called folding indicators.
 By default, nodes to a maximal depth of 6 are shown.
 For nodes in lists another limit with a default of 256 is valid.
 These limits can be changed with the operation 'config' from the menu.
 The new limits will be effective for all subsequent 'draw' operations.
.)l
.pp
The tree browser provides a call-back mechanism for the attributes
shown in a subwindow. There are tree-valued attributes and non-tree-valued
attributes. Tree-valued attributes are marked with the character '+'.
A mouse click on a tree-valued attribute starts a new copy of the tree browser
on this subtree. A mouse click on a non-tree-valued attribute calls the macro
.i DrawAttr
with two arguments: a pointer to the current node and a string giving the name
of the selected attribute. By default, this macro does nothing. It can be
defined to execute arbitrary code. In the following example the macro
.i DrawAttr
is defined to call the procedure
.i draw_attr .
This procedure decides upon its arguments what to do and it may call for example
another tree browser procedure named
.i Drawmy_tree .
.(b
.FT
GLOBAL {
# include "my_tree.h"
.sp 0.5
# define DrawAttr(addr, name) draw_attr (addr, name)
.sp 0.5
static void draw_attr (tTree tree, char * name)
{
   switch (tree->Kind) {
   case knode:
      if (strcmp (name, "attribute") == 0)
         Drawmy_tree (tree->node.attribute);
   }
}
}
.)b
.if 0 \{\
.pp
The procedure
.i SetDepthTREE
sets the default drawing depth for the graph browser
.i DrawTREE/Draw .
Trees and graphs are not drawn completely. Only certain levels of nodes are
shown and the rest is suppressed. By default, 6 levels of nodes are shown, only.
This number can be changed using the procedure
.i SetDepthTREE
or interactively when the browser is running. Setting the level to a high number
such as e. g. 999 yields a complete picture of even large graphs.
This feature of suppressing parts of the tree is not applied to lists of nodes.
All elements of lists are shown. Lists are specified using the property REVERSE.
.pp
The procedure
.i SetBoxTREE
sets the geometry of the rectangles that represent nodes. The two arguments give
the width and the height of the rectangles in pixels. The default values are
60 and 20. The horizontal and vertical distances between the nodes as well as
the number of chatacters used to label a node are computed automatically
depending on the size of a rectangle.
.\}
.sh 1 "Using the Generated Program Module"
.pp
This section explains how to use the objects of the generated program module.
Trees or graphs are created by successively creating their nodes. The easiest
way is to call the constructor procedures m<node_type> or the constructor
methods called <node_type>. These procedures and methods
combine node creation, storage allocation, and attribute assignment.
They provide a mechanism similar to record aggregates. Nested calls of
constructor procedures allow programming with (ground) terms as in Prolog or LISP.
In general, a node can be created by a call of one of the procedures
.(b
MakeTREE, n<node type>, or m<node type>.
.)b
or by invoking methods
.(b
TREE.make (k<node type>), <node type> (), <node type> (...).
.)b
The type of a node can be retrieved by
examination of the predefined tag field/member variable called
.i Kind/kind .
Alternatively the function/member function
.i TREE_IsType/isType
can be used to test whether a node has a certain type or a subtype thereof.
In the procedural languages children and attributes can be accessed using two
record selections. The first one states the node type and the
second one gives the selector name of the desired item.
In object-oriented languages children and attributes are accessed directly,
possibly after applying a type cast.
.pp
The following sections contain examples for the different implementation
languages:
.br
.ne 40
.sh 2 C
.(b L
abstract syntax:
.sp 0.5
.FT
Expr         = [Pos: tPosition] <
   Binary    = Lop: Expr Rop: Expr [Operator: int] .
   Unary     = Expr [Operator] .
   IntConst  = [Value] .
   RealConst = [Value: float] .
> .
.)b
.(b L
tree construction by a term:
.sp 0.5
.FT
# define Plus 1
# include "TREE.h"
tTREE t;
tPosition Pos;
.sp 0.5
t = mBinary (Pos, mIntConst (Pos, 2), mIntConst (Pos, 3), Plus);
.)b
.(b L
tree construction during parsing:
.sp 0.5
.FT
Expr: Expr '+' Expr {$$.Tree = mBinary ($2.Pos, $1.Tree, $3.Tree, Plus);} .
Expr:      '-' Expr {$$.Tree = mUnary  ($1.Pos, $2.Tree, Minus);        } .
Expr: IntConst      {$$.Tree = mIntConst ($1.Pos, $1.IntValue);         } .
Expr: RealConst     {$$.Tree = mRealConst ($1.Pos, $1.RealValue);       } .
.)b
.(b L
tree construction using a statement sequence:
.sp 0.5
.FT
t = MakeTREE (kBinary);
t->Binary.Pos.Line            = 0;
t->Binary.Pos.Column          = 0;
t->Binary.Lop                 = MakeTREE (kIntConst);
t->Binary.Lop->IntConst.Pos   = Pos;
t->Binary.Lop->IntConst.Value = 2;
t->Binary.Rop                 = MakeTREE (kIntConst);
t->Binary.Rop->IntConst.Pos   = Pos;
t->Binary.Rop->IntConst.Value = 3;
t->Binary.Operator            = Plus;
.)b
.(b L
access of tag field, children, and attributes:
.sp 0.5
.FT
switch (t->Kind) {
case kExpr  : ... t->Expr.Pos             ...
case kBinary: ... t->Binary.Operator      ...
              ... t->Binary.Lop           ...
case kUnary : ... t->Unary.Expr->Expr.Pos ...
}
.)b
.ne 10
.sh 2 "Simple C++"
.(b L
abstract syntax:
.sp 0.5
.FT
Expr         = [Pos: tPosition] <
   Binary    = Lop: Expr Rop: Expr [Operator: int] .
   Unary     = Expr [Operator] .
   IntConst  = [Value] .
   RealConst = [Value: float] .
> .
.)b
.(b L
tree construction by a term:
.sp 0.5
.FT
# define Plus 1
# include "TREE.h"
TREE  o;                // create a tree object (manager)
tTREE t;                // declare a pointer to tree nodes
tPosition Pos;
.sp 0.5
t = o.mBinary (Pos, o.mIntConst (Pos, 2), o.mIntConst (Pos, 3), Plus);
.)b
.(b L
tree construction during parsing:
.sp 0.5
.FT
Expr: Expr '+' Expr {$$.Tree = o.mBinary ($2.Pos, $1.Tree, $3.Tree, Plus);} .
Expr:      '-' Expr {$$.Tree = o.mUnary  ($1.Pos, $2.Tree, Minus);        } .
Expr: IntConst      {$$.Tree = o.mIntConst ($1.Pos, $1.IntValue);         } .
Expr: RealConst     {$$.Tree = o.mRealConst ($1.Pos, $1.RealValue);       } .
.)b
.(b L
tree construction using a statement sequence:
.sp 0.5
.FT
t = o.MakeTREE (kBinary);
t->Binary.Pos.Line            = 0;
t->Binary.Pos.Column          = 0;
t->Binary.Lop                 = o.MakeTREE (kIntConst);
t->Binary.Lop->IntConst.Pos   = Pos;
t->Binary.Lop->IntConst.Value = 2;
t->Binary.Rop                 = o.MakeTREE (kIntConst);
t->Binary.Rop->IntConst.Pos   = Pos;
t->Binary.Rop->IntConst.Value = 3;
t->Binary.Operator            = Plus;
.)b
.(b L
access of tag field, children, and attributes:
.sp 0.5
.FT
switch (t->Kind) {
case kExpr  : ... t->Expr.Pos             ...
case kBinary: ... t->Binary.Operator      ...
              ... t->Binary.Lop           ...
case kUnary : ... t->Unary.Expr->Expr.Pos ...
}
.)b
.ne 10
.sh 2 "Proper C++"
.(b L
abstract syntax:
.sp 0.5
.FT
Expr         = [Pos: tPosition] <
   Binary    = Lop: Expr Rop: Expr [Operator: int] .
   Unary     = Expr [Operator] .
   IntConst  = [Value] .
   RealConst = [Value: float] .
> .
.)b
.(b L
tree construction by a term:
.sp 0.5
.FT
# define Plus 1
# include "TREE.h"
using namespace TREE;   // allows IntConst instead of TREE::IntConst etc.
tTREE t;                // declare a pointer to tree nodes of any type
Binary * b;             // declare a pointer to tree nodes of type Binary
tPosition Pos;
.sp 0.5
b = new Binary (Pos, new IntConst (Pos, 2), new IntConst (Pos, 3), Plus);
.)b
.(b L
tree construction during parsing:
.sp 0.5
.FT
Expr: Expr '+' Expr {$$.tree = new Binary ($2.Pos, $1.tree, $3.tree, Plus);} .
Expr:      '-' Expr {$$.tree = new Unary  ($1.Pos, $2.tree, Minus);        } .
Expr: IntConst      {$$.tree = new IntConst ($1.Pos, $1.IntValue);         } .
Expr: RealConst     {$$.tree = new RealConst ($1.Pos, $1.RealValue);       } .
.)b
.(b L
tree construction using a statement sequence:
.sp 0.5
.FT
b = (tpBinary) Make (kBinary);
b->Pos.Line                  = 0;
b->Pos.Column                = 0;
b->Lop                       = (IntConst *) Make (kIntConst);
b->Lop->Pos                  = Pos;
((IntConst *) b->Lop)->Value = 2;
b->Rop                       = new IntConst ();
b->Rop->Pos                  = Pos;
((tpIntConst) b->Rop)->Value = 3;
b->Operator                  = Plus;
.)b
.(b L
access of tag field, children, and attributes:
.sp 0.5
.FT
switch (t->Kind) {
case kExpr  : ... ((tpExpr  ) t)->Pos       ...
case kBinary: ... ((tpBinary) t)->Operator  ...
              ... ((tpBinary) t)->Lop       ...
case kUnary : ... ((tpUnary ) t)->Expr->Pos ...
}
.)b
.ne 10
.sh 2 Modula-2
.(b L
abstract syntax:
.sp 0.5
.FT
Expr         = [Pos: tPosition] <
   Binary    = Lop: Expr Rop: Expr [Operator: INTEGER] .
   Unary     = Expr [Operator] .
   IntConst  = [Value] .
   RealConst = [Value: REAL] .
> .
.)b
.(b L
tree construction by a term:
.sp 0.5
.FT
CONST Plus = 1;
VAR t  : tTREE;
    Pos: tPosition;
.sp 0.5
t := mBinary (Pos, mIntConst (Pos, 2), mIntConst (Pos, 3), Plus);
.)b
.(b L
tree construction during parsing:
.sp 0.5
.FT
Expr: Expr '+' Expr {$$.Tree := mBinary ($2.Pos, $1.Tree, $3.Tree, Plus);} .
Expr:      '-' Expr {$$.Tree := mUnary  ($1.Pos, $2.Tree, Minus);        } .
Expr: IntConst      {$$.Tree := mIntConst ($1.Pos, $1.IntValue);         } .
Expr: RealConst     {$$.Tree := mRealConst ($1.Pos, $1.RealValue);       } .
.)b
.(b L
tree construction using a statement sequence:
.sp 0.5
.FT
t := MakeTREE (Binary);
t^.Binary.Pos.Line            := 0;
t^.Binary.Pos.Column          := 0;
t^.Binary.Lop                 := MakeTREE (IntConst);
t^.Binary.Lop^.IntConst.Pos   := Pos;
t^.Binary.Lop^.IntConst.Value := 2;
t^.Binary.Rop                 := MakeTREE (IntConst);
t^.Binary.Rop^.IntConst.Pos   := Pos;
t^.Binary.Rop^.IntConst.Value := 3;
t^.Binary.Operator            := Plus;
.)b
.(b L
access of tag field, children, and attributes:
.sp 0.5
.FT
CASE t^.Kind OF
| Expr  : ... t^.Expr.Pos             ...
| Binary: ... t^.Binary.Operator      ...
          ... t^.Binary.Lop           ...
| Unary : ... t^.Unary.Expr^.Expr.Pos ...
END;
.)b
.ne 15
.sh 2 Java
.(b L
abstract syntax:
.sp 0.5
.FT
Expr         = [Pos: Position] <
   Binary    = Lop: Expr Rop: Expr [Operator: int] .
   Unary     = Expr [Operator] .
   IntConst  = [Value] .
   RealConst = [Value: float] .
> .
.)b
.(b L
tree construction by a term:
.sp 0.5
.FT
import TREE.*;            // allows IntConst instead of TREE.IntConst etc.
static final int Plus = 1;
de.cocolab.reuse.Position Pos;
.sp 0.5
Tree t = new Binary (Pos, new IntConst (Pos, 2), new IntConst (Pos, 3), Plus);
.)b
.(b L
tree construction during parsing:
.sp 0.5
.FT
Expr: Expr '+' Expr {$$ = new Binary ($2.position (), $1.asExpr (), $3.asExpr (),
                                      Plus);                                      }.
Expr:      '-' Expr {$$ = new Unary  ($1.position (), $2.asExpr (), Minus);       }.
Expr: IntConst      {$$ = new IntConst ($1.position (), $1.asIntValue ().value);  }.
Expr: RealConst     {$$ = new RealConst ($1.position (), $1.asRealValue ().value);}.
.)b
.(b L
tree construction using a statement sequence:
.sp 0.5
.FT
Binary b    = new Binary ();
b.Pos       = new Position (0, 0);
b.Lop       = new IntConst ();
b.Lop.Pos   = Pos;
b.Lop.Value = 2;
b.Rop       = new IntConst ();
b.Rop.Pos   = Pos;
b.Rop.Value = 3;
b.Operator  = Plus;
.)b
.(b L
access of tag field, children, and attributes:
.sp 0.5
.FT
switch (t.kind) {
case TREE.Expr  : Expr   e = (Expr)   t; ... e.Pos      ...
case TREE.Binary: Binary b = (Binary) t; ... b.Operator ...
                                         ... b.Lop      ...
case TREE.Unary : Unary  u = (Unary)  t; ... u.Expr.Pos ...
}
.)b
.ne 5
.sh 1 "Related Research"
.sh 2 "Variant Records"
.pp
.i Ast
specifications and variant record types like in Pascal or Modula-2 are very
similar. Every node type in an
.i ast
specification corresponds to a single variant. In the generated code every
node type is translated into a record type. All record types become members
of a variant record type representing the type for the trees.
.pp
The differences are the following:
.i Ast
specifications are shorter than directly hand-written variant record types.
.i Ast
specifications are based on the formalism of context-free grammars (see
section 5.3.). The generator
.i ast
automatically provides operations on record types which would be simple but
voluminous to program by hand. The node constructor procedures allow to
write record aggregates and provide dynamic storage management. The reader
and writer procedures supply input and output for record types and even for
complete linked data structures such as trees and graphs.
Even when the target language is an object-oriented language such as Java,
.i ast
still provides important advantages over hand coding.
.sh 2 "Type Extensions"
.pp
Type extensions have been introduced with the language Oberon
\*([[Wir88a\*(],Wir88b\*(],Wir88c\*(]].
The extension mechanism of
.i ast
is basically the same as in Oberon.
The notions extension, base type, and derived type are equivalent.
Type extension is equivalent to inheritance in object-oriented languages
such as C++ and Java.
.i "Type tests"
and
.i "type guards"
can be easily programmed by inspecting the tag field of a node.
.i Ast
does not provide assignment of subtypes to base types in the sense of value semantics or a
projection, respectively.
The tool can be seen as a preprocessor providing type extensions for C, C++,
and Modula-2.
.pp
The second example in section 2.5. illuminates the relationship between
.i ast
and Oberon. The node type Stats is a base type with two fields, a child and an attribute.
It is extended e. g. by the node type While with two more fields which are children.
.sh 2 "Context-Free Grammars"
.pp
As already mentioned,
.i ast
specifications are based on context-free grammars.
.i Ast
specifications extend context-free grammars by selector names for right-hand
side symbols, attributes, the extension mechanism, and modules. If these
features are
omitted, we basically arrive at context-free grammars. This holds from the
syntactic as well as from the semantic point of view. The names of the node
types represent both terminal or nonterminal symbols and rule names.
Node types correspond to grammar rules. The notions of derivation and
derivation tree can be used similarly in both cases. The selector names can
be seen as syntactic sugar and the attributes as some kind of terminal
symbols. The extension mechanism is equivalent to a shorthand notation for
factoring out common rule parts in combination with implicit chain rules.
.(b
Example:
.sp 0.5
\fIast\fP specification:
.sp 0.5
.FT
Stats           = Next: Stats <
   If           = Expr Then: Stats Else: Stats .
   While        = Expr Stats .
> .
.)b
.(b
corresponding context-free grammar:
.sp 0.5
.FT
Stats           = Stats .
Stats           = Stats If .
Stats           = Stats While .
If              = Expr Stats Stats .
While           = Expr Stats .
.)b
.pp
In the example above, Stats corresponds to a nonterminal.
There are two rules or right-hand sides for Stats which are named If and While.
The latter would be regarded as nonterminals, too, if a child of types If or While would be
specified.
.sh 2 "Attribute Grammars"
.pp
Attribute grammars\*([<\*([[Knu68\*(],Knu71\*(]]\*(>]
and
.i ast
specifications are based on context-free grammars and associate attributes with terminal
and nonterminals symbols. Additionally
.i ast
allows attributes which are local to rules.
As the structure of the tree itself is known and transparent, subtrees can be
accessed or created dynamically and used as attribute values. The access of
the right-hand side symbols uses the selector names for symbolic access
instead of the grammar symbol with an additional subscript if needed.
There is no need to map chain rules
to tree nodes because of the extension mechanism offered by
.i ast.
Attribute evaluation is outside the scope of
.i ast .
This can be done either with the attribute evaluator generator
.i ag
\*([[Grob\*(]] which understands
.i ast
specifications extended by attribute computation rules and processes the
trees generated by
.i ast
or by hand-written programs that use an
.i ast
generated module. In the latter case attribute computations do not have to
obey the single assignment restriction for attributes. They can assign a
value to an attribute zero, one, or several times.
.sh 2 "Interface Description Language (IDL)"
.pp
The approach of
.i ast
is similar to the one of IDL\*([<\*([[Lam87\*(],NNG89\*(]]\*(>].
Both specify attributed trees as well as graphs.
Node types without extensions are called nodes in IDL and node types with
extensions (base types) are called classes.
.i Ast
has simplified this to the single notion of a node type.
Attributes are treated similarly in both systems.
Children and attributes are both regarded as attributes, as
structural and non-structural ones, with only little difference in between.
Both systems allow multiple inheritance of attributes,
.i ast
has a separate syntax for single inheritance and uses the notion extension instead
\*([[Wir88a\*(]].
IDL knows the predefined types INTEGER, RATIONAL, BOOLEAN, STRING, SEQ OF,
and SET OF. It offers special operations for the types SEQ OF and SET OF.
.i Ast
really has no built in types at all, it uses the ones of the target language
and has a table containing the type specific operations e.\ g. for reading
and writing.
Both
.i ast
and IDL allow attributes of user-defined types. In
.i ast ,
the type specific operations for predefined or user-defined
types are easily expressed by macros using the target language directly.
IDL offers an assertion language whereas
.i ast
does not. IDL provides a mechanism to modify existing specifications.
The module feature of
.i ast
can be used to extend existing specifications.
From
.i ast ,
readers and writers are requested with simple command line options instead of
complicated syntactic constructs.
.i Ast
does not support representation specifications, because representations are
much more easily expressed using the types of the target language directly.
Summarizing, we consider
.i ast
to have a simpler specification method and to generate more powerful
features like aggregates, reversal of lists, and graph browsers.
.sh 2 "Attribute Coupled Grammars"
.pp
Attribute coupled grammars (ACG's)\*([<\*([[Gie88\*(]]\*(>] or algebraic
specifications\*([<\*([[HHK88\*(]]\*(>] have only very little in common with
.i ast
specifications. They all view node types or rules as signatures of
functions. The name of the node type plays the role of the function name and
describes the result type. The types of the children and attributes
correspond to the type of the function arguments.
The constructor procedures generated by
.i ast
reflect this view best.
.sh 2 "Object-Oriented Languages"
.pp
The extension mechanism of
.i ast
is exactly the same as single inheritance in object-oriented languages like
e. g. Simula\*([<\*([[DMN70\*(]]\*(>] or Smalltalk\*([<\*([[Gol84\*(]]\*(>].
The hierarchy introduced by the extension mechanism corresponds
directly to the class hierarchy of object-oriented languages.
The notions base type and super class both represent the same concept.
Messages and virtual procedures are out of the scope of
.i ast.
Virtual procedures might be simulated with procedure-valued attributes.
Table 8 summarizes the corresponding notions of trees
(\fIast\fP), type extensions, and object-oriented programming.
.(z L
.sp 0.5
.ce
Table 8: Comparison of notions from the areas of trees, types, and object-oriented programming
.sp 0.5
.TS
center;
l | l | l.
trees	types	object-oriented programming
_
node type	record type	class
-	base type	superclass
-	derived type	subclass
attribute, child	record field	instance variable
tree node	record variable	object, instance
-	extension	inheritance
.TE
.)z
.sh 2 "Tree Grammars"
.pp
Conventional tree grammars are characterized by the fact that all
right-hand sides start with a terminal symbol. They are used for the
description of string languages that represent trees in prefix form.
.i Ast
specifications describe trees  which are represented by (absolute) pointers
from parent to child nodes. If we shift the names of node types of
.i ast
specifications to the beginning of the right-hand side and interpret them as
terminals we arrive at conventional tree grammars. That is exactly what is done by
the
.i ast
tree/graph writers. They write a tree in prefix form and prepend every node
with the name of its node type.
That is necessary to be able to perform the read operations.
.sh 1 "Hints on Specifying Abstract Syntax"
.ip -
Keep the abstract syntax as short and simple as possible.
.ip -
Try to normalize by representing only the most general form.
.ip -
Normalize to the general form e. g. by adding default values.
.ip -
Normalize several concrete representations to one abstract construct.
.ip -
Map concrete to abstract syntax by disregarding the concrete syntax
rules and by concentrating on the semantic structure of the abstract syntax.
.ip -
Map several concrete nonterminals to one abstract node type (e. g. Expr,
Term, and Factor \(-> Expr)
.ip -
Allow all lists to be empty regardless of the concrete syntax.
Otherwise you have to process the list element at two places in exactly the
same way. This causes programming overhead and violates the law of
singularity: "One thing only once!"
.ip -
Operators can be represented by different node types (e. g. Plus, Minus,
Mult, ...) or by one node type with an
attribute describing the operator (e. g. Binary).
.ip -
Lists can be represented by separate nodes for the list and the elements
(e. g. Stats and Stat) or by nodes for the elements where every node has
a child that refers to the next list element (see last example in section 2.12.1.).
.sh 1 Examples
.pp
The Appendices 1 to 3 contain examples of
.i ast
specifications.
.pp
Appendix 1 contains the concrete syntax of
.i ast's
specification language. The node types enclosed in quotes or starting with
the character 't' constitute the terminals for
.i ast's
parser. The extensions and the node types used for the latter describe the lexical grammar.
.pp
Appendix 2 contains the concrete syntax of a small example programming
language called
.i MiniLAX
\*([[GrK88\*(]].
The attributes specified are the ones a parser would evaluate during parsing.
The Appendices 1 and 2 show how concrete grammars can be described with
.i ast .
.pp
Appendix 3 contains an abstract syntax for MiniLAX.
The attributes specified are input or intrinsic ones whose values would be provided
by the scanner and parser.
The definition follows the hints of the previous section.
Terminal symbols without attributes are omitted.
All binary and unary operators are expressed by two nodes having one
attribute to represent the operator.
To simplify things as much as possible all lists are allowed to be empty and
procedure declarations as well as calls always have a parameter list.
The specification tries to keep the tree as small as possible.
The inheritance mechanism allows to avoid all chain rules. There are no
nodes for sequences of declarations, statements, etc.. Instead every node
for a declaration or a statement has a field named
.i Next
describing the successor entity. Except for expressions no separate nodes
are used for identifiers. The information is included as attribute in the
node types
.i "Proc, Var, Formal" ,
and
.i Call .
The source position is stored only at the nodes where it might be needed
during semantic analysis. The above measures not only reduce the amount of
storage but they also reduce run time because less information has to be
produced and processed.
.sh 1 "Experiences"
.pp
.i Ast
can be used not only for abstract syntax trees in compilers but for every
tree or graph like data structure. In general the data structure can serve
as interface between phases within a program or between separate programs.
In the latter case it would be communicated via a file using the generated
reader and writer procedures.
.pp
Generated tree respectively graph modules have successfully been used in
compilers e.\ g. for MiniLAX\*([<\*([[WGS89\*(]]\*(>] and UNITY
\*([[Bie89\*(]] as well as for a Modula to C translator\*([<\*([[Mar90\*(]]\*(>].
The modules for the internal data structure of
.i ast
itself and the attribute evaluator generator
.i ag
\*([[Grob\*(]] have also been generated by
.i ast .
Moreover, the symbol table module of the Modula to C translator has been generated.
.pp
The advantage of this approach is that it saves considerably hand-coding of
trivial declarations and operations. Table 9 lists the sizes (numbers of
lines) of some specifications and the generated modules.
Sums in the specification column are composed of the sizes for
the definition of node types and for user-supplied target code.
Sums in the tree module column are composed of the sizes for the
definition part and for the implementation part.
The reason for the large sizes of the tree modules comes from the numerous
node constructor procedures and from the graph browser in the case of
.i ag .
These procedures proved to be very helpful for debugging purposes
as they provide readable output of complex data structures. The constructor
procedures allow to write record aggregates. Therefore, node creation and
assignment of values to the components can be written very compact.
It is even possible to write (ground) terms as in Prolog or LISP by
nested calls of the constructor procedures.
.(b L
.sp 0.5
.ce
Table 9: Examples of Ast Applications
.sp 0.5
.TS
center;
l | r | r.
application	specification	tree module
_
MiniLAX 	56      	202 + \0835 = 1037
Modula-2	240      	583 + 3083 = 3666
UNITY   	210      	207 + \0962 = 1169
Ag      	78 + 347 = 425	317 + 1317 = 1634
Definition table	82 + 900 = 982	399 + 1431 = 1830
.TE
.)b
.sh 1 "Usage"
.pp
.de TH
..
.lf 1 ./ast.1
.TH AST 1 "" "CoCoLab Germany"
.SH NAME
ast - generator for abstract syntax trees
.SH SYNOPSIS
ast [ -options ] ... [ +options ] [ -l\fIdirectory\fP ] [ \fIfiles\fP ]
.SH DESCRIPTION
.I Ast
generates a program module to handle arbitrary attributed trees and graphs.
A typical application is the abstract syntax tree in a compiler.
The input
.I file
contains a specification which describes the structure of all
possible trees or nodes respectively and the attributes of the nodes.
.I Ast
generates type declarations to implement the tree and several procedures for
tree manipulation including text and binary readers and writers
(see options below). If
.I file
is omitted the specification is read from standard input.
.SH OPTIONS
.ta 2.5i
.IP a
generate all except -ceh (default)
.IP n
generate node constructors	procedures n<node> (node)
.IP m
generate node constructors	procedures m<node> (make)
.IP f
generate node/graph destroyer	procedure ReleaseTREE (free)
.IP F
generate general destroyer	procedure ReleaseTREEModule (FREE)
.IP o
generate text node writer	procedure WriteTREENode (output)
.IP r
generate text graph reader	procedure ReadTREE
.IP w
generate text graph writer	procedure WriteTREE
.IP +X
generate XML graph writer	procedure WriteTREEXML
.IP g
generate binary graph reader	procedure GetTREE
.IP p
generate binary graph writer	procedure PutTREE
.IP t
generate top down traversal	procedure TraverseTREETD
.br
(reverse depth first)
.IP b
generate bottom up traversal	procedure TraverseTREEBU
.br
(depth first)
.IP R
generate list reverser	procedure ReverseTREE
.IP R
generate list iterator	procedure ForallTREE
.IP y
generate graph copy	procedure CopyTREE
.IP =
generate tree equality test	procedure IsEqualTREE
.IP k
generate graph type checker	procedure CheckTREE
.IP q
generate text graph browser	procedure QueryTREE
.IP e
generate graphic graph browser	procedure DrawTREE
.IP _
generate array TREE_NodeName
.IP d
generate header file or definition module
.IP i
generate implementation part or module
.IP s
generate import statements
.IP :
generate lines not longer than 80 characters
.IP 4
generate tree/graph description in file TREE.TS
.IP 6
generate # line directives
.IP 7
touch output files only if necessary
.IP 8
report storage consumption
.IP c
generate C source code (default: Modula-2)
.IP c+
generate simple C++ source code (using C data structure: union)
.IP c++
generate proper C++ source code (using C++ data structure: class)
.IP J
generate Java source code
.IP h
print help information
.IP -l\fIdir\fP
specify the directory dir where ast finds its tables
.IP +H
print advanced help
.IP +E
generate tree equality test procedure IsEqualTREE
.IP +I
suppress informations
.IP +P
generate empty bodies for procedures not selected
.SH FILES
.nf
.ta 2i
if output is in C:
.sp 0.5
<module>.h	header file of the generated graph module
<module>.c	body of the generated graph module
yy<module>.h	macro file defining type specific operations
Tree.tcl	procedure definitions for procedure DrawTREE
.sp 0.5
if output is in C++:
.sp 0.5
<module>.h	header file of the generated graph module
<module>.cxx	body of the generated graph module
yy<module>.h	macro file defining type specific operations
Tree.tcl	procedure definitions for procedure DrawTREE
.sp 0.5
if output is in Modula-2:
.sp 0.5
<module>.md	definition module of the generated graph module
<module>.mi	implementation module of the generated graph module
<module>.imp	import statements
Tree.tcl	procedure definitions for procedure DrawTREE
.sp 0.5
if output is in Java:
.sp 0.5
<module>.java	classes of the generated graph module
.fi
.SH SEE\ ALSO
.sp 0.5
J. Grosch: "Ast - A Generator for Abstract Syntax Trees",
CoCoLab Germany, Document No. 15
.sp 0.5
J. Grosch: "Tool Support for Data Structures",
Structured Programming, 12, 31-38 (1991)
.sp 0.5
J. Grosch: "Tool Support for Data Structures",
CoCoLab Germany, Document No. 17
.lf 3255 /tmp/.doc
.sz 12
.[]
.[-
.ds [F Bie89
.ds [A F\*(p] Bieler
.ds [T An Interpreter for Chandy/Misra's UNITY
.ds [R internal paper
.ds [I GMD Forschungsstelle an der Universit\\*at Karlsruhe
.ds [D 1989
.][
.[-
.ds [F DMN70
.ds [A O\*(p] Dahl
.as [A \*(c]B\*(p] Myrhaug
.as [A \*(m]K\*(p] Nygaard
.ds [T SIMULA 67 Common Base Language - Publication S-22
.ds [I Norwegian Computing Center
.ds [C Oslo
.ds [D 1970
.][
.[-
.ds [F Gie88
.ds [A R\*(p] Giegerich
.ds [T Composition and Evaluation of Attribute Coupled Grammars
.ds [J Acta Inf.
.ds [V 25
.nr [P 1
.ds [P 355-423
.ds [D 1988
.][
.[-
.ds [F Gol84
.ds [A A\*(p] Goldberg
.ds [T Smalltalk-80: The Interactive Programming Environment
.ds [I Addison Wesley
.ds [C Reading, M\&A
.ds [C Reading, MA
.ds [D 1984
.][
.[-
.ds [F GrK88
.ds [A J\*(p] Grosch
.as [A \*(n]E\*(p] Klein
.ds [T \\*Ubersetzerbau-Praktikum
.ds [I GMD Forschungsstelle an der Universit\\*at Karlsruhe
.ds [R Compiler Generation Report No. 9
.ds [N 9
.ds [D June 1988
.][
.[-
.ds [F Groa
.ds [A J\*(p] Grosch
.ds [T Puma - A Generator for the Transformation of Attributed Trees
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 26
.ds [N 26
.][
.[-
.ds [F Grob
.ds [A J\*(p] Grosch
.ds [T Ag - An Attribute Evaluator Generator
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 16
.ds [N 16
.][
.[-
.ds [F Groc
.ds [A J\*(p] Grosch
.ds [T Lark - An LR(1) Parser Generator With Backtracking
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 32
.ds [N 32
.][
.[-
.ds [F GrV
.ds [A J\*(p] Grosch
.as [A \*(n]B\*(p] Vielsack
.ds [T The Parser Generators Lalr and Ell
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 8
.ds [N 8
.][
.[-
.ds [F Groa
.ds [A J\*(p] Grosch
.ds [T Reusable Software - A Collection of Modula-Modules
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 4
.ds [N 4
.][
.[-
.ds [F Grob
.ds [A J\*(p] Grosch
.ds [T Reusable Software - A Collection of C-Modules
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 30
.ds [N 30
.][
.[-
.ds [F HHK88
.ds [A J\*(p] Heering
.as [A \*(c]P\*(p]\*(a]R\*(p]\*(a]H\*(p] Hendriks
.as [A \*(c]P\*(p] Klint
.as [A \*(m]J\*(p] Rekers
.ds [T The Syntax Definition Formalism SDF - Reference Manual
.ds [I ESPRIT Project GIPE
.ds [D Dec. 1988
.][
.[-
.ds [F Joh75
.ds [A S\*(p]\*(a]C\*(p] Johnson
.ds [T Yacc \(em  Yet Another Compiler-Compiler
.ds [R Computer Science Technical Report 32
.ds [I Bell Telephone Laboratories
.ds [C Murray Hill, NJ
.ds [D July 1975
.][
.[-
.ds [F Knu68
.ds [A D\*(p]\*(a]E\*(p] Knuth
.ds [T Semantics of Context-Free Languages
.nr [P 1
.ds [P 127-146
.ds [J Mathematical Systems Theory
.ds [V 2
.ds [D June 1968
.ds [N 2
.][
.[-
.ds [F Knu71
.ds [A D\*(p]\*(a]E\*(p] Knuth
.ds [T Semantics of Context-free Languages: Correction
.nr [P 1
.ds [P 95-96
.ds [J Mathematical Systems Theory
.ds [V 5
.ds [D Mar. 1971
.][
.[-
.ds [F Lam87
.ds [A D\*(p]\*(a]A\*(p] Lamb
.ds [T IDL: Sharing Intermediate Representations
.nr [P 1
.ds [P 297-318
.ds [J ACM Trans. Prog. Lang. and Systems
.ds [V 9
.ds [N 3
.ds [D July 1987
.][
.[-
.ds [F Mar90
.ds [A M\*(p] Martin
.ds [T Entwurf und Implementierung eines \\*Ubersetzers von Modula-2 nach C
.ds [R Diplomarbeit
.ds [I GMD Forschungsstelle an der Universit\\*at Karlsruhe
.ds [D Feb. 1990
.][
.[-
.ds [F Nas
.ds [A T\*(p] Nash
.ds [T Reusable Software - A Java Package
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 36
.ds [N 36
.][
.[-
.ds [F NNG89
.ds [A J\*(p]\*(a]R\*(p] Nestor
.as [A \*(c]J\*(p]\*(a]M\*(p] Newcomer
.as [A \*(c]P\*(p] Giannini
.as [A \*(m]D\*(p]\*(a]L\*(p] Stone
.ds [T IDL: The Language and its Implementation
.ds [I Prentice Hall
.ds [C Englewood Cliffs, NJ
.ds [C Englewood Cliffs
.ds [D 1989
.][
.[-
.ds [F Par88
.ds [A J\*(p]\*(a]C\*(p]\*(a]H\*(p] Park
.ds [T y+: A Yacc Preprocessor for Certain Semantic Actions
.ds [J SI\&GPLAN Notices
.ds [V 23
.ds [N 6
.nr [P 1
.ds [P 97-106
.ds [D 1988
.][
.[-
.ds [F WGS89
.ds [A W\*(p]\*(a]M\*(p] Waite
.as [A \*(c]J\*(p] Grosch
.as [A \*(m]F\*(p]\*(a]W\*(p] Schr\\*oer
.ds [T Three Compiler Specifications
.ds [R GMD-Studie Nr. 166
.ds [I GMD Forschungsstelle an der Universit\\*at Karlsruhe
.ds [D Aug. 1989
.][
.[-
.ds [F Wir88a
.ds [A N\*(p] Wirth
.ds [T Type Extensions
.ds [J ACM Trans. Prog. Lang. and Systems
.ds [V 10
.ds [N 2
.ds [D Apr. 1988
.nr [P 1
.ds [P 204-214
.][
.[-
.ds [F Wir88b
.ds [A N\*(p] Wirth
.ds [T From Modula to Oberon
.ds [J Software\(emPractice & Experience
.ds [V 18
.ds [N 7
.ds [D July 1988
.nr [P 1
.ds [P 661-670
.][
.[-
.ds [F Wir88c
.ds [A N\*(p] Wirth
.ds [T The Programming Language Oberon
.ds [J Software\(emPractice & Experience
.ds [V 18
.ds [N 7
.ds [D July 1988
.nr [P 1
.ds [P 671-690
.][
.bp
.uh "Appendix 1: Syntax of the Specification Language"
.sp
.nf
.FT
RULE                                    /* Ast: concrete syntax */

/* parser grammar */

Specification    = <
                 =               TreeCodes PropPart DeclPart RulePart Modules .
                 = 'MODULE' Name TreeCodes PropPart DeclPart RulePart
                   'END' Name Modules .
> .
TreeCodes        = <
                 =                                 SubUnit .
                 = 'TREE'                          SubUnit Codes .
                 = 'TREE' DottedName               SubUnit Codes .
                 = 'TREE' DottedName          Name SubUnit Codes .
                 = 'TREE' DottedName 'PREFIX' Name SubUnit Codes .
> .
Codes            = <
                 = .
                 = Codes 'EXPORT' tTargetCode .
                 = Codes 'IMPORT' tTargetCode .
                 = Codes 'GLOBAL' tTargetCode .
                 = Codes 'LOCAL'  tTargetCode .
                 = Codes 'BEGIN'  tTargetCode .
                 = Codes 'CLOSE'  tTargetCode .
> .
SubUnit          = <
                 = .
                 = SubUnit 'SUBUNIT' Name .
                 = SubUnit 'VIEW'    Name .
> .
PropPart         = Props .

Props            = <
                 =
                 = Props 'PROPERTY' Properties
                 = Props 'PROPERTY' Properties 'FOR' Names
                 = Props 'SELECT' Names
> .
DeclPart         = <
                 = .
                 = 'DECLARE' Decls .
> .
Decls            = <
                 = .
   MoreNonterms  = Decls Names '=' AttrDecls '.' .
   MoreTerminals = Decls Names ':' AttrDecls '.' .
> .
Names            = <
                 = .
                 = Names Name .
                 = Names ',' .
> .
RulePart         = <
                 = .
                 = 'RULE' Types .
> .
Types            = <
                 = .
   Nonterminal   = Types Name BaseTypes '='  AttrDecls Extensions '.' .
   Terminal      = Types Name BaseTypes ':'  AttrDecls Extensions '.' .
   Abstract      = Types Name BaseTypes ':=' AttrDecls Extensions '.' .
> .
BaseTypes        = <
                 = .
                 = '<-' Names .
> .
Extensions       = <
                 = .
                 = '<' Types '>' .
> .
AttrDecls        = <
                 = .
   ChildSelect   = AttrDecls     Name ':' Name Properties .
   ChildNoSelect = AttrDecls              Name Properties .
   AttrTyped     = AttrDecls '[' Name ':' Name Properties ']' .
   AttrInteger   = AttrDecls '[' Name          Properties ']' .
   AttrTypedInit = AttrDecls '[' Name ':' Name ':=' tExpression ']' .
   AttrIntInit   = AttrDecls '[' Name          ':=' tExpression ']' .
> .
Properties       = <
                 = .
                 = Properties 'INPUT' .
                 = Properties 'OUTPUT' .
                 = Properties 'SYNTHESIZED' .
                 = Properties 'INHERITED' .
                 = Properties 'THREAD' .
                 = Properties 'REVERSE' .
                 = Properties 'IGNORE' .
                 = Properties 'VIRTUAL' .
> .
Modules          = <
                 = .
                 = Modules 'MODULE' Name TreeCodes DeclPart RulePart 'END' Name .
> .
Name             = <
                 = tIdent .
                 = tString .
> .
DottedName       = <
                 = Name .
                 = DottedName '.' Name . /* Java only */
> .

/* lexical grammar */

tIdent           : <
                 = Letter .
                 = tIdent Letter .
                 = tIdent Digit .
                 = tIdent '_' .
> .
tString          : <
                 = "'" Characters "'" .
                 = '"' Characters '"' .
> .
tTargetCode      : '{' Characters '}' .

Comment          : '/*' Characters '*/' .

Characters       : <
                 = .
                 = Characters Character .
> .

tExpression      : .    /* target language expression           */
.FR
.bp
.uh "Appendix 2: Concrete Syntax of the Example Language MiniLAX"
.sp
.nf
.FT
.sz -2
RULE
.sp 0.5
Prog            = PROGRAM tIdent ';' 'DECLARE' Decls 'BEGIN' Stats 'END' '.' .
Decls           = <
   Decls1       = Decl .
   Decls2       = Decls ';' Decl .
> .
Decl            = <
   Var          = tIdent ':' Type .
   Proc0        = PROCEDURE tIdent ';' 'DECLARE' Decls 'BEGIN' Stats 'END' .
   Proc         = PROCEDURE tIdent '(' Formals ')' ';'
                                       'DECLARE' Decls 'BEGIN' Stats 'END' .
> .
Formals         = <
   Formals1     = Formal .
   Formals2     = Formals ';' Formal .
> .
Formal          = <
   Value        = tIdent ':' Type .
   Ref          = VAR tIdent ':' Type .
> .
Type            = <
   Int          = INTEGER .
   Real         = REAL .
   Bool         = BOOLEAN .
   Array        = ARRAY '[' Lwb: tIntegerConst '..' Upb: tIntegerConst ']' OF Type .
> .
Stats           = <
   Stats1       = Stat .
   Stats2       = Stats ';' Stat .
> .
Stat            = <
   Assign       = Adr ':=' Expr .
   Call0        = tIdent .
   Call         = tIdent '(' Actuals ')' .
   If           = IF Expr THEN Then: Stats ELSE Else: Stats 'END' .
   While        = WHILE Expr DO Stats 'END' .
   Read         = READ '(' Adr ')' .
   Write        = WRITE '(' Expr ')' .
> .
Actuals         = <
   Expr1        = Expr .
   Expr2        = Actuals ',' Expr .
> .
Expr            = <
   Less         = Lop: Expr '<' Rop: Expr .
   Plus         = Lop: Expr '+' Rop: Expr .
   Times        = Lop: Expr '*' Rop: Expr .
   Not          = NOT Expr .
   '()'         = '(' Expr ')' .
   IConst       = tIntegerConst .
   RConst       = tRealConst .
   False        = FALSE .
   True         = TRUE .
   Adr          = <
      Name      = tIdent .
      Index     = Adr '[' Expr ']' .
   > .
> .
tIdent          : [Ident: tIdent] .
tIntegerConst   : [Integer      ] .
tRealConst      : [Real : double] .
.sz +2
.FR
.bp
.uh "Appendix 3: Abstract Syntax of the Example Language MiniLAX"
.sp
.nf
.FT
TREE                                    /* MiniLAX: abstract syntax */
IMPORT  {
# include "Idents.h"
# include "Position.h"
}

RULE

MiniLax         = Proc .
Decls           = <
   NoDecl       = .
   Decl         = Next: Decls REV [Ident: tIdent] [Pos: tPosition] <
      Proc      = Formals Decls Stats .
      Var       = Type .
   > .
> .
Formals         = <
   NoFormal     = .
   Formal       = Next: Formals REV [Ident: tIdent] [Pos: tPosition] Type .
> .
Type            = <
   Integer      = .
   Real         = .
   Boolean      = .
   Array        = Type                [Lwb] [Upb] [Pos: tPosition] .
   Ref          = Type .
> .
Stats           = <
   NoStat       = .
   Stat         = Next: Stats REV <
      Assign    = Adr Expr            [Pos: tPosition] .
      Call      = Actuals             [Ident: tIdent] [Pos: tPosition] .
      If        = Expr Then: Stats Else: Stats .
      While     = Expr Stats .
      Read      = Adr .
      Write     = Expr .
   > .
> .
Actuals         = <
   NoActual     =                     [Pos: tPosition] .
   Actual       = Next: Actuals REV Expr .
> .
Expr            =                     [Pos: tPosition] <
   Binary       = Lop: Expr Rop: Expr [Operator] .
   Unary        = Expr                [Operator] .
   IntConst     =                     [Value        ] .
   RealConst    =                     [Value: double] .
   BoolConst    =                     [Value: rbool ] .
   Adr          = <
      Index     = Adr Expr .
      Ident     =                     [Ident: tIdent] .
   > .
> .
.FR
.bp
.uh "Appendix 4: Generated Header File for C"
.sp
.nf
.FT
# ifndef yyTREE   /* throughout replace TREE by the name of the tree module */
# define yyTREE
.sp 0.5
<import_declarations>
.sp 0.5
# define rbool char
# define NoTREE (tTREE) NULL
# define k<type_1> 1
# define k<type_2> 2
   ...
.sp 0.5
typedef unsigned short TREE_tKind;   /* or unsigned char */
typedef unsigned short TREE_tMark;
typedef unsigned short TREE_tLabel;
typedef union TREE_Node * tTREE;
typedef void (* TREE_tProcTree) (void);
.sp 0.5
typedef tTREE t<type_1>;   /* for toplevel node types, only */
typedef tTREE t<type_2>;
   ...
.sp 0.5
<export_declarations>
.sp 0.5
# ifndef TREE_NodeHead
# define TREE_NodeHead
# endif
typedef struct { TREE_tKind yyKind; TREE_tMark yyMark; TREE_NodeHead }
                                                       TREE_tNodeHead;
typedef struct { TREE_tNodeHead yyHead;
                 <children_and_attributes_of_type_1> } y<type_1>;
typedef struct { TREE_tNodeHead yyHead;
                 <children_and_attributes_of_type_2> } y<type_2>;
   ...
.sp 0.5
union TREE_Node {
   TREE_tKind Kind;
   TREE_tNodeHead yyHead;
   y<type_1> <type_1>;
   y<type_2> <type_2>;
    ...
};
.sp 0.5
extern tTREE TREERoot;
extern unsigned long TREE_HeapUsed;
.\" extern unsigned short TREE_NodeSize [];
extern char * TREE_NodeName [];
extern void (* Tree_Exit)       (void);
.sp 0.5
extern tTREE n<type_1>          (void);
extern tTREE n<type_2>          (void);
   ...
.sp 0.5
extern tTREE m<type_1>          (<input_children_and_attributes_of_type_1>);
extern tTREE m<type_2>          (<input_children_and_attributes_of_type_2>);
   ...
.sp 0.5
extern tTREE MakeTREE           (TREE_tKind Kind);
extern rbool TREE_IsType        (tTREE t, TREE_tKind Kind);
extern void  ReleaseTREE        (tTREE t);
extern void  ReleaseTREEModule  (void);
extern void  WriteTREENode      (FILE * f, tTREE t);
extern tTREE ReadTREE           (FILE * f);
extern void  WriteTREE          (FILE * f, tTREE t);
extern void  WriteTREEXML       (FILE * f, tTREE t);
extern tTREE GetTREE            (FILE * f);
extern void  PutTREE            (FILE * f, tTREE t);
extern void  TraverseTREETD     (tTREE t, void (* Procedure) (tTREE t));
extern void  TraverseTREEBU     (tTREE t, void (* Procedure) (tTREE t));
extern tTREE ReverseTREE        (tTREE t);
extern void  ForallTREE         (tTREE t, void (* Procedure) (tTREE t));
extern tTREE CopyTREE           (tTREE t);
extern rbool IsEqualTREE        (tTREE t1, tTREE t2);
extern rbool CheckTREE          (tTREE t);
extern void  QueryTREE          (tTREE t);
extern void  DrawTREE           (tTREE t);
.\" extern void  SetDepthTREE       (int Depth);
.\" extern void  SetBoxTREE         (int Width, int Height);
extern void  ConfigureTREE      (char * Parameter, char * Value);
extern void  BeginTREE          (void);
extern void  CloseTREE          (void);
.sp 0.5
# endif
.FR
.bp
.uh "Appendix 5: Generated Header File for Simple C++"
.sp
.nf
.FT
# ifndef yyTREE   // throughout replace TREE by the name of the tree module
# define yyTREE
.sp 0.5
<import_declarations>
.sp 0.5
# define rbool char
.sp 0.5
# define NoTREE (tTREE) 0L
# define k<type_1> 1
# define k<type_1> 2
   ...
.sp 0.5
typedef unsigned short TREE_tKind;   // or unsigned char
typedef unsigned short TREE_tMark;
typedef unsigned short TREE_tLabel;
typedef union TREE_Node * tTREE;
typedef void (* TREE_tProcTree) (void);
.sp 0.5
typedef tTREE t<type_1>;   // for toplevel node types, only
typedef tTREE t<type_2>;
   ...
.sp 0.5
<export_declarations>
.sp 0.5
# ifndef TREE_NodeHead
# define TREE_NodeHead
# endif
typedef struct { TREE_tKind yyKind; TREE_tMark yyMark; TREE_NodeHead }
                                                       TREE_tNodeHead;
typedef struct { TREE_tNodeHead yyHead;
                 <children_and_attributes_of_type_1> } y<type_1>;
typedef struct { TREE_tNodeHead yyHead;
                 <children_and_attributes_of_type_2> } y<type_2>;
   ...
.sp 0.5
union TREE_Node {
   TREE_tKind Kind;
   TREE_tNodeHead yyHead;
   y<type_1> <type_1>;
   y<type_2> <type_2>;
    ...
};
.sp 0.5
.\" extern const unsigned short TREE_NodeSize [];
extern const char * const TREE_NodeName [];
.sp 0.5
.bp
# define TREE_BASE_CLASS
.sp 0.5
class TREE TREE_BASE_CLASS {
public:
 tTREE                  TREERoot;
 unsigned long          TREE_HeapUsed;
 void (*                TREE_Exit) (void);
.sp 0.5
 tTREE n<type_1>        (void);
 tTREE n<type_2>        (void);
    ...
.sp 0.5
 tTREE m<type_1>        (<input_children_and_attributes_of_type_1>);
 tTREE m<type_2>        (<input_children_and_attributes_of_type_2>);
    ...
.sp 0.5
 tTREE MakeTREE         (TREE_tKind Kind);
 rbool TREE_IsType      (tTREE t, TREE_tKind Kind);
 void  ReleaseTREE      (tTREE t);
 void  ReleaseTREEModule(void);
 void  WriteTREENode    (FILE * f, tTREE t);
 tTREE ReadTREE         (FILE * f);
 void  WriteTREE        (FILE * f, tTREE t);
 void  WriteTreeXML     (FILE * f, tTREE t);
 tTREE GetTREE          (FILE * f);
 void  PutTREE          (FILE * f, tTREE t);
 void  TraverseTREETD   (tTREE t, TREE_tProcTree Proc);
 void  TraverseTREEBU   (tTREE t, TREE_tProcTree Proc);
 tTREE ReverseTREE      (tTREE t);
 void  ForallTREE       (tTREE t, TREE_tProcTree Proc);
 tTREE CopyTREE         (tTREE t);
 rbool IsEqualTREE      (tTREE t1, tTREE t2);
 rbool CheckTREE        (tTREE t);
 void  QueryTREE        (tTREE t);
 void  DrawTREE         (tTREE t);
.\"  void  SetDepthTREE     (int Depth);
.\"  void  SetBoxTREE       (int Width, int Height);
 void  ConfigureTREE    (char * Parameter, char * Value);
 void  BeginTREE        (void);
 void  CloseTREE        (void);
       TREE             (void);
       ~TREE            (void);
};
.sp 0.5
# endif
.FR
.bp
.uh "Appendix 6: Generated Header File for Proper C++"
.sp
.nf
.FT
# ifndef yyTREE   // throughout replace TREE by the name of the tree module
# define yyTREE
.sp 0.5
<import_declarations>
.sp 0.5
namespace TREE {
.sp 0.5
# define NoTREE 0
static const int k<type_1> = 1;
static const int k<type_2> = 2;
   ...
.sp 0.5
typedef class yyTREE * tTREE;
typedef void (* yytProcTREE) (tTREE);
typedef unsigned short yytKind;   // or unsigned char
typedef unsigned short yytMark;
.\" typedef unsigned short yytLabel;
.sp 0.5
typedef class <type_1> * tp<type_1>;
typedef class <type_2> * tp<type_2>;
   ...
.sp 0.5
extern  tTREE   Root;
extern  const char * const NodeName [];
extern  Errors * ErrorsObj;
.sp 0.5
extern  tTREE   Make            (yytKind);
extern  bool    IsType          (tTREE, yytKind);
extern  void    Release         (tTREE);
extern  void    WriteNode       (FILE *, tTREE);
extern  tTREE   Read            (FILE *);
extern  void    Write           (FILE *, tTREE);
extern  void    WriteXML        (FILE *, tTREE);
extern  tTREE   Get             (FILE *);
extern  void    Put             (FILE *, tTREE);
extern  void    TraverseTD      (tTREE, yytProcTREE Proc);
extern  void    TraverseBU      (tTREE, yytProcTREE Proc);
extern  tTREE   Reverse         (tTREE);
extern  void    Forall          (tTREE, yytProcTREE Proc);
extern  tTREE   Copy            (tTREE);
extern  bool    IsEqual         (tTREE, tTREE);
extern  bool    Check           (tTREE);
extern  void    Query           (tTREE);
extern  void    Draw            (tTREE);
.\" extern      void    SetDepth        (int Depth);
.\" extern      void    SetBox          (int Width, int Height);
extern  void    Configure       (char * Parameter, char * Value);
extern  void    yyInit          (tTREE);
extern  void    Begin           ();
extern  void    Close           ();
.sp 0.5
.bp
class yyTREE {
public:
        yytKind Kind;
        yytMark yyMark;
        TREE_NodeHead
.sp 0.5
        yyTREE  ();
.sp 0.5
        bool    IsType          (yytKind);
        void    Release         ();
        void    WriteNode       (FILE *);
        void    Write           (FILE *);
        void    WriteXML        (FILE *);
        void    Put             (FILE *);
        void    TraverseTD      (yytProcTREE Proc);
        void    TraverseBU      (yytProcTREE Proc);
        tTREE   Reverse         ();
        void    Forall          (yytProcTREE Proc);
        tTREE   Copy            ();
        bool    IsEqual         (tTREE);
        bool    Check           ();
        void    Query           ();
        void    Draw            ();
};
.sp 0.5
class <type_1> : public cTREE {
public:
        <children_and_attributes_of_type_1>
.sp 0.5
        <type_1> ();
        <type_1> (<input_children_and_attributes_of_type_1>);
};
.sp 0.5
class <type_2> : public <type_1> {
public:
        <children_and_attributes_of_type_2>
.sp 0.5
        <type_2> ();
        <type_2> (<input_children_and_attributes_of_type_1>);
};
.sp 0.5
   ...
.sp 0.5
};
.sp 0.5
<export_declarations>
.sp 0.5
# endif
.FR
.bp
.uh "Appendix 7: Generated Definition Module for Modula-2"
.sp
.nf
.FT
DEFINITION MODULE TREE;
   IMPORT IO;     (* throughout replace TREE by the name of the tree module *)
.sp 0.5
   <import_declarations>
.sp 0.5
   CONST
      NoTREE       = NIL;
      <type_1>     = 1;
      <type_2>     = 2;
      ...
.sp 0.5
   TYPE
      tTREE        = POINTER TO yyNode;
      tProcTree    = PROCEDURE (tTREE);
.sp 0.5
      t<type_1>    = tTREE;   (* for toplevel node types, only *)
      t<type_2>    = tTREE;
      ...
.sp 0.5
   <export_declarations>
.sp 0.5
   TYPE
      yytNodeHead  = RECORD yyKind, yyMark: SHORTCARD; END;
.sp 0.5
   TYPE
      y<type_1>    = RECORD yyHead: yytNodeHead;
                            <children_and_attributes_of_type_1> END;
      y<type_2>    = RECORD yyHead: yytNodeHead;
                            <children_and_attributes_of_type_2> END;
      ...
.sp 0.5
      yyNode       = RECORD
         CASE : SHORTCARD OF
         | 0        : Kind: SHORTCARD;
         | ...      : yyHead: yytNodeHead;
         | <type_1> : <type_1>    : y<type_1>;
         | <type_2> : <type_2>    : y<type_2>;
         ...
         END;
      END;
.sp 0.5
   VAR TREERoot  : tTREE;
   VAR HeapUsed  : LONGCARD;
.\"    VAR yyNodeSize: ARRAY [ ... ] OF SHORTCARD;
   VAR yyExit    : PROC;
.sp 0.5
   PROCEDURE n<type_1>      (): tTREE;
   PROCEDURE n<type_2>      (): tTREE;
   ...
   PROCEDURE m<type_1>      (<input_children_and_attributes_of_type_1>): tTREE;
   PROCEDURE m<type_2>      (<input_children_and_attributes_of_type_2>): tTREE;
   ...
   PROCEDURE MakeTREE       (Kind: SHORTCARD): tTREE;
   PROCEDURE IsType         (Tree: tTREE; Kind: SHORTCARD): BOOLEAN;
   PROCEDURE ReleaseTREE    (Tree: tTREE);
   PROCEDURE ReleaseTREEModule;
   PROCEDURE WriteTREENode  (f: IO.tFile; Tree: tTREE);
   PROCEDURE ReadTREE       (f: IO.tFile): tTREE;
   PROCEDURE WriteTREE      (f: IO.tFile; Tree: tTREE);
   PROCEDURE GetTREE        (f: IO.tFile): tTREE;
   PROCEDURE PutTREE        (f: IO.tFile; Tree: tTREE);
   PROCEDURE TraverseTREETD (Tree: tTREE; Proc: tProcTree);
   PROCEDURE TraverseTREEBU (Tree: tTREE; Proc: tProcTree);
   PROCEDURE ReverseTREE    (Tree: tTREE): tTREE;
   PROCEDURE ForallTREE     (Tree: tTREE; Proc: tProcTree);
   PROCEDURE CopyTREE       (Tree: tTREE): tTREE;
   PROCEDURE IsEqualTREE    (Tree1, Tree2: tTREE): BOOLEAN;
   PROCEDURE CheckTREE      (Tree: tTREE): BOOLEAN;
   PROCEDURE QueryTREE      (Tree: tTREE);
   PROCEDURE DrawTREE       (Tree: tTREE);
.\"    PROCEDURE SetDepthTREE   (Depth: INTEGER);
.\"    PROCEDURE SetBoxTREE     (Width, Height: INTEGER);
   PROCEDURE ConfigureTREE  (VAR Parameter, Value: ARRAY OF CHAR);
   PROCEDURE BeginTREE;
   PROCEDURE CloseTREE;
END TREE.
.FR
.bp
.uh "Appendix 8: Generated Declarations for Java"
.sp
.nf
.FT
// throughout replace TREE by the name of the tree module
.sp 0.5
package <package_name>;   // If the tree module is a dotted name
<import_declarations>
<global_declarations>
<local_declarations>
.sp 0.5
public class TREE implements java.io.Serializable {
  static final TREE NoTREE = null;
.sp 0.5
  /* for 'forall', 'traverseBU', 'traverseTD' */
  public static interface ProcTree {
    public void proc (TREE t);
  }
.sp 0.5
<export_declarations>
.sp 0.5
  /* methods available on all tree nodes */
  /* some are available as static methods taking an argument of type TREE */
  public int yyKind ();
  static void writeNode (de.cocolab.reuse.CocktailWriter yyout)
                          throws java.io.IOException { ... }
  public void traverseTD (ProcTree Proc) { ... }
  public void traverseBU (ProcTree Proc) { ... }
  public TREE reverse () { ... }
  public void forall (ProcTree Proc) throws Throwable { ... }
  public boolean isType (int Kind) { ... }
  public static boolean check (TREE t) throws java.io.IOException { ... }
  public void query () throws java.io.IOException { ... }
  public boolean isEqual (TREE t) { ... }
  public static void write (de.cocolab.reuse.CocktailWriter yyout)
                          throws java.io.IOException { ... }
  public static TREE read (de.cocolab.reuse.CocktailReader yyin)
                          throws java.io.IOException { ... }
  public void put (java.io.OutputStream s) { ... }
  public void put (String fileName) { ... }
  public static TREE get (java.io.InputStream s) { ... }
  public static TREE get (String fileName) { ... }
  public static TREE copy (TREE t) { ... }
  public java.lang.Object clone () { ... }
.sp 0.5
  static final int k<type_1> = 1;
  static final int k<type_2> = 2;
  ...
.sp 0.5
  public static class <type_1> extends TREE {
    <children_and_attributes_of_type_1>
    public <type_1> () { ... }
    public <type_1> (<children_and_attributes_of_type_1>) { ... }
  }
.sp 0.5
  public static class <type_2> extends TREE {
    <children_and_attributes_of_type_1>
    public <type_2> () { ... }
    public <type_2> (<children_and_attributes_of_type_2>) { ... }
  }
   ...
.sp 0.5
  static final String [] NodeNames = {
    "NoTree", "<type_1>", "<type_2>", ... };
.sp 0.5
  public static TREE make (int Kind) { ... }
.sp 0.5
  public static void begin () {
<begin_code>
  }
  public static void close () {
<close_code>
  }
  static { begin (); }
}
.FR
.bp
.uh "Appendix 9: Predefined Type Specific Operations for C"
.sp
.nf
.FT
/* int */
# define beginint(a)
# define closeint(a)
.mc \(bv
# define readint(a)             fscanf (yyf, "%d", & a);
# define writeint(a)            fprintf (yyf, "%d", a);
.mc
# define getint(a)              yyGet ((char *) & a, sizeof (a));
# define putint(a)              yyPut ((char *) & a, sizeof (a));
# define copyint(a, b)
# define equalint(a, b)         (a) == (b)
.mc \(bv
# define writeXMLint(a)         fprintf (yyf, "%d", a);
.mc
/* short */
# define beginshort(a)
# define closeshort(a)
.mc \(bv
# define readshort(a)           fscanf (yyf, "%hd", & a);
# define writeshort(a)          fprintf (yyf, "%hd", a);
.mc
# define getshort(a)            yyGet ((char *) & a, sizeof (a));
# define putshort(a)            yyPut ((char *) & a, sizeof (a));
# define copyshort(a, b)
# define equalshort(a, b)       (a) == (b)
.mc \(bv
# define writeXMLshort(a)       fprintf (yyf, "%hd", a);
.mc
/* long */
# define beginlong(a)
# define closelong(a)
.mc \(bv
# define readlong(a)            fscanf (yyf, "%ld", & a);
# define writelong(a)           fprintf (yyf, "%ld", a);
.mc
# define getlong(a)             yyGet ((char *) & a, sizeof (a));
# define putlong(a)             yyPut ((char *) & a, sizeof (a));
# define copylong(a, b)
# define equallong(a, b)        (a) == (b)
.mc \(bv
# define writeXMLlong(a)        fprintf (yyf, "%ld", a);
.mc
/* unsigned */
# define beginunsigned(a)
# define closeunsigned(a)
.mc \(bv
# define readunsigned(a)        fscanf (yyf, "%u", & a);
# define writeunsigned(a)       fprintf (yyf, "%u", a);
.mc
# define getunsigned(a)         yyGet ((char *) & a, sizeof (a));
# define putunsigned(a)         yyPut ((char *) & a, sizeof (a));
# define copyunsigned(a, b)
# define equalunsigned(a, b)    (a) == (b)
.mc \(bv
# define writeXMLunsigned(a)    fprintf (yyf, "%u", a);
.mc
/* float */
# define beginfloat(a)
# define closefloat(a)
.mc \(bv
# define readfloat(a)           fscanf (yyf, "%g", & a);
# define writefloat(a)          fprintf (yyf, "%g", a);
.mc
# define getfloat(a)            yyGet ((char *) & a, sizeof (a));
# define putfloat(a)            yyPut ((char *) & a, sizeof (a));
# define copyfloat(a, b)
# define equalfloat(a, b)       (a) == (b)
.mc \(bv
# define writeXMLfloat(a)       fprintf (yyf, "%g", a);
.mc
/* double */
# define begindouble(a)
# define closedouble(a)
.mc \(bv
# define readdouble(a)          fscanf (yyf, "%g", & a);
# define writedouble(a)         fprintf (yyf, "%g", a);
.mc
# define getdouble(a)           yyGet ((char *) & a, sizeof (a));
# define putdouble(a)           yyPut ((char *) & a, sizeof (a));
# define copydouble(a, b)
# define equaldouble(a, b)      (a) == (b)
.mc \(bv
# define writeXMLdouble(a)      fprintf (yyf, "%g", a);
.mc
/* rbool */
# define beginrbool(a)
# define closerbool(a)
# define readrbool(a)           a = fgetc (yyf) == 'T';
.mc \(bv
# define writerbool(a)          fputc (a ? 'T' : 'F', yyf);
.mc
# define getrbool(a)            yyGet ((char *) & a, sizeof (a));
# define putrbool(a)            yyPut ((char *) & a, sizeof (a));
# define copyrbool(a, b)
# define equalrbool(a, b)       (a) == (b)
.mc \(bv
# define writeXMLrbool(a)       fputc (a ? 'T' : 'F', yyf);
.mc
/* char */
# define beginchar(a)
# define closechar(a)
# define readchar(a)            a = fgetc (yyf);
.mc \(bv
# define writechar(a)           fputc (a, yyf);
.mc
# define getchar(a)             yyGet ((char *) & a, sizeof (a));
# define putchar(a)             yyPut ((char *) & a, sizeof (a));
# define copychar(a, b)
# define equalchar(a, b)        (a) == (b)
.mc \(bv
# define writeXMLchar(a)        yyWriteCharXML (a);
/* vchar */
# define beginvchar(a)
# define closevchar(a)
# define readvchar(a)           fscanf (yyf, vFc, & a);
# define writevchar(a)          fprintf (yyf, vFc, a);
# define getvchar(a)            yyGet ((char *) & a, sizeof (a));
# define putvchar(a)            yyPut ((char *) & a, sizeof (a));
# define copyvchar(a, b)
# define equalvchar(a, b)       (a) == (b)
# define writeXMLvchar(a)       yyWriteCharXML (a);
.mc
/* tString */
# define begintString(a)
# define closetString(a)
# define readtString(a)
.mc \(bv
# define writetString(a)        fputs (a, yyf);
.mc
# define gettString(a)
# define puttString(a)
# define copytString(a, b)
# define equaltString(a, b)     strcmp (a, (b)) == 0
.mc \(bv
# define writeXMLtString(a)     yyWriteStringXML (a);
.mc
/* tStringRef */
# define begintStringRef(a)     a = NoString;
# define closetStringRef(a)
# define readtStringRef(a)      { char yys [1024]; \\
.mc \(bv
                                  fgets (yys, 1024, yyf); \\
                                  ungetc ('\\n', yyf); \\
.mc
                                  a = PutString (yys, strlen (yys) - 1); }
# define writetStringRef(a)       WriteString (yyf, a);
# define gettStringRef(a)       { char yys [1024]; \\
.mc \(bv
                                  fgets (yys, 1024, yyf); \\
.mc
                                  a = PutString (yys, strlen (yys) - 1); }
# define puttStringRef(a)       { WriteString (yyf, a); \\
.mc \(bv
                                  fputc ('\\n', yyf); }
.mc
# define copytStringRef(a, b)
# define equaltStringRef(a, b)  (a) == (b)
.mc \(bv
# define writeXMLtStringRef(a)  yyWriteStringXML (StGetCStr (a));
/* tWStringRef */
# define begintWStringRef(a)    a = NoWString;
# define closetWStringRef(a)
# define readtWStringRef(a)
# define writetWStringRef(a)    WriteWString (yyf, a);
# define gettWStringRef(a)
# define puttWStringRef(a)      { WriteWString (yyf, a); fputc ('\\n', yyf); }
# define copytWStringRef(a, b)
# define equaltWStringRef(a, b) (a) == (b)
# define writeXMLtWStringRef(a) yyWriteWStringXML (StGetWCStr (a));
/* vtStringRef */
# define beginvtStringRef(a)    a = vNoString;
# define closevtStringRef(a)
# define readvtStringRef(a)
# define writevtStringRef(a)    vWriteString (yyf, a);
# define getvtStringRef(a)
# define putvtStringRef(a)      { vWriteString (yyf, a); fputc ('\\n', yyf); }
# define copyvtStringRef(a, b)
# define equalvtStringRef(a, b) (a) == (b)
# define writeXMLvtStringRef(a) yyWriteStringXML (vStGetCStr (a));
.mc
/* tIdent */
# define begintIdent(a)         a = NoIdent;
# define closetIdent(a)
# define readtIdent(a)          a = yyReadIdent ();
# define writetIdent(a)         WriteIdent (yyf, a);
# define gettIdent(a)           yyGetIdent (& a);
# define puttIdent(a)           yyPutIdent (a);
# define copytIdent(a, b)
# define equaltIdent(a, b)      (a) == (b)
.mc \(bv
# define writeXMLtIdent(a)      yyWriteStringXML (GetCStr (a));
/* tWIdent */
# define begintWIdent(a)        a = NoWIdent;
# define closetWIdent(a)
# define readtWIdent(a)
# define writetWIdent(a)        WriteWIdent (yyf, a);
# define gettWIdent(a)
# define puttWIdent(a)          { WriteWIdent (yyf, a); fputc ('\\n', yyf); }
# define copytWIdent(a, b)
# define equaltWIdent(a, b)     (a) == (b)
# define writeXMLtWIdent(a)     yyWriteWStringXML (GetWCStr (a));
/* vtIdent */
# define beginvtIdent(a)        a = vNoIdent;
# define closevtIdent(a)
# define readvtIdent(a)
# define writevtIdent(a)        vWriteIdent (yyf, a);
# define getvtIdent(a)
# define putvtIdent(a)          { vWriteIdent (yyf, a); fputc ('\\n', yyf); }
# define copyvtIdent(a, b)
# define equalvtIdent(a, b)     (a) == (b)
# define writeXMLvtIdent(a)     yyWriteStringXML (vGetCStr (a));
.mc
/* tSet */
# define begintSet(a)
# define closetSet(a)
# define readtSet(a)            ReadSet (yyf, & a);
# define writetSet(a)           WriteSet (yyf, & a);
# define gettSet(a)
# define puttSet(a)
# define copytSet(a, b)
# define equaltSet(a, b)        IsEqual (& a, & b)
.mc \(bv
# define writeXMLtSet(a)        WriteSet (yyf, & a);
.mc
/* tPosition */
# define begintPosition(a)      a = NoPosition;
# define closetPosition(a)
# define readtPosition(a)       ReadPosition (yyf, & a);
# define writetPosition(a)      WritePosition (yyf, a);
# define gettPosition(a)        yyGet ((char *) & a, sizeof (a));
# define puttPosition(a)        yyPut ((char *) & a, sizeof (a));
# define copytPosition(a, b)
# define equaltPosition(a, b)   Compare (a, b) == 0
.mc \(bv
# define writeXMLtPosition(a)   WritePosition (yyf, a);
.mc
/* NodeHead */
# define beginNodeHead(a)
# define closeNodeHead(a)
# define readNodeHead(a)
# define writeNodeHead(a)
# define getNodeHead(a)
# define putNodeHead(a)
# define copyNodeHead(a, b)
# define equalNodeHead(a, b)    rtrue
.mc \(bv
# define writeXMLNodeHead(a)
.mc
.FR
.bp
.uh "Appendix 10: Predefined Type Specific Operations for Simple C++"
.sp
.nf
.FT
/* int */
# define beginint(a)
# define closeint(a)
# define readint(a)             fscanf (yyf, "%d", & a);
# define writeint(a)            fprintf (yyf, "%d", a);
# define getint(a)              yyGet ((char *) & a, sizeof (a));
# define putint(a)              yyPut ((char *) & a, sizeof (a));
# define copyint(a, b)
# define equalint(a, b)         (a) == (b)
.mc \(bv
# define writeXMLint(a)         fprintf (yyf, "%d", a);
.mc
/* short */
# define beginshort(a)
# define closeshort(a)
# define readshort(a)           fscanf (yyf, "%hd", & a);
# define writeshort(a)          fprintf (yyf, "%hd", a);
# define getshort(a)            yyGet ((char *) & a, sizeof (a));
# define putshort(a)            yyPut ((char *) & a, sizeof (a));
# define copyshort(a, b)
# define equalshort(a, b)       (a) == (b)
.mc \(bv
# define writeXMLshort(a)       fprintf (yyf, "%hd", a);
.mc
/* long */
# define beginlong(a)
# define closelong(a)
# define readlong(a)            fscanf (yyf, "%ld", & a);
# define writelong(a)           fprintf (yyf, "%ld", a);
# define getlong(a)             yyGet ((char *) & a, sizeof (a));
# define putlong(a)             yyPut ((char *) & a, sizeof (a));
# define copylong(a, b)
# define equallong(a, b)        (a) == (b)
.mc \(bv
# define writeXMLlong(a)        fprintf (yyf, "%ld", a);
.mc
/* unsigned */
# define beginunsigned(a)
# define closeunsigned(a)
# define readunsigned(a)        fscanf (yyf, "%u", & a);
# define writeunsigned(a)       fprintf (yyf, "%u", a);
# define getunsigned(a)         yyGet ((char *) & a, sizeof (a));
# define putunsigned(a)         yyPut ((char *) & a, sizeof (a));
# define copyunsigned(a, b)
# define equalunsigned(a, b)    (a) == (b)
.mc \(bv
# define writeXMLunsigned(a)    fprintf (yyf, "%u", a);
.mc
/* float */
# define beginfloat(a)
# define closefloat(a)
# define readfloat(a)           fscanf (yyf, "%g", & a);
# define writefloat(a)          fprintf (yyf, "%g", a);
# define getfloat(a)            yyGet ((char *) & a, sizeof (a));
# define putfloat(a)            yyPut ((char *) & a, sizeof (a));
# define copyfloat(a, b)
# define equalfloat(a, b)       (a) == (b)
.mc \(bv
# define writeXMLfloat(a)       fprintf (yyf, "%g", a);
.mc
/* double */
# define begindouble(a)
# define closedouble(a)
# define readdouble(a)          fscanf (yyf, "%g", & a);
# define writedouble(a)         fprintf (yyf, "%g", a);
# define getdouble(a)           yyGet ((char *) & a, sizeof (a));
# define putdouble(a)           yyPut ((char *) & a, sizeof (a));
# define copydouble(a, b)
# define equaldouble(a, b)      (a) == (b)
.mc \(bv
# define writeXMLdouble(a)      fprintf (yyf, "%g", a);
.mc
/* rbool */
# define beginrbool(a)
# define closerbool(a)
# define readrbool(a)           a = fgetc (yyf) == 'T';
# define writerbool(a)          fputc (a ? 'T' : 'F', yyf);
# define getrbool(a)            yyGet ((char *) & a, sizeof (a));
# define putrbool(a)            yyPut ((char *) & a, sizeof (a));
# define copyrbool(a, b)
# define equalrbool(a, b)       (a) == (b)
.mc \(bv
# define writeXMLrbool(a)       fputc (a ? 'T' : 'F', yyf);
.mc
/* bool */
# define beginbool(a)
# define closebool(a)
# define readbool(a)            a = fgetc (yyf) == 'T';
# define writebool(a)           fputc (a ? 'T' : 'F', yyf);
# define getbool(a)             yyGet ((bool *) & a, sizeof (a));
# define putbool(a)             yyPut ((bool *) & a, sizeof (a));
# define copybool(a, b)
# define equalbool(a, b)        (a) == (b)
.mc \(bv
# define writeXMLbool(a)        fputc (a ? 'T' : 'F', yyf);
.mc
/* char */
# define beginchar(a)
# define closechar(a)
# define readchar(a)            a = fgetc (yyf);
# define writechar(a)           fputc (a, yyf);
# define getchar(a)             yyGet ((char *) & a, sizeof (a));
# define putchar(a)             yyPut ((char *) & a, sizeof (a));
# define copychar(a, b)
# define equalchar(a, b)        (a) == (b)
.mc \(bv
# define writeXMLchar(a)        yyWriteCharXML (a);
/* vchar */
# define beginvchar(a)
# define closevchar(a)
# define readvchar(a)           fscanf (yyf, vFc, & a);
# define writevchar(a)          fprintf (yyf, vFc, a);
# define getvchar(a)            yyGet ((char *) & a, sizeof (a));
# define putvchar(a)            yyPut ((char *) & a, sizeof (a));
# define copyvchar(a, b)
# define equalvchar(a, b)       (a) == (b)
# define writeXMLvchar(a)       yyWriteCharXML (a);
.mc
/* tString */
# define begintString(a)
# define closetString(a)
# define readtString(a)
# define writetString(a)        fputs (a, yyf);
# define gettString(a)
# define puttString(a)
# define copytString(a, b)
# define equaltString(a, b)     strcmp (a, (b)) == 0
.mc \(bv
# define writeXMLtString(a)     yyWriteStringXML (a);
.mc
/* tStringRef */
# define begintStringRef(a)     a = String_PREFIX NoString;
# define closetStringRef(a)
# define readtStringRef(a)      { char yys [1024]; \\
                                  fgets (yys, 1024, yyf); \\
                                  ungetc ('\\n', yyf); \\
                          a = String_PREFIX PutString (yys, strlen (yys) - 1); }
# define writetStringRef(a)       String_PREFIX WriteString (yyf, a);
# define gettStringRef(a)       { char yys [1024]; \\
                                  fgets (yys, 1024, yyf); \\
                          a = String_PREFIX PutString (yys, strlen (yys) - 1); }
# define puttStringRef(a)       { String_PREFIX WriteString (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copytStringRef(a, b)
# define equaltStringRef(a, b)  (a) == (b)
.mc \(bv
# define writeXMLtStringRef(a)  yyWriteStringXML (String_PREFIX StGetCStr (a));
/* tWStringRef */
# define begintWStringRef(a)    a = String_PREFIX NoWString;
# define closetWStringRef(a)
# define readtWStringRef(a)
# define writetWStringRef(a)    String_PREFIX WriteWString (yyf, a);
# define gettWStringRef(a)
# define puttWStringRef(a)      { String_PREFIX WriteWString (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copytWStringRef(a, b)
# define equaltWStringRef(a, b) (a) == (b)
# define writeXMLtWStringRef(a) yyWriteWStringXML (String_PREFIX StGetWCStr (a));
/* vtStringRef */
# define beginvtStringRef(a)    a = String_PREFIX vNoString;
# define closevtStringRef(a)
# define readvtStringRef(a)
# define writevtStringRef(a)    String_PREFIX vWriteString (yyf, a);
# define getvtStringRef(a)
# define putvtStringRef(a)      { String_PREFIX vWriteString (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copyvtStringRef(a, b)
# define equalvtStringRef(a, b) (a) == (b)
# define writeXMLvtStringRef(a) yyWriteStringXML (String_PREFIX vStGetCStr (a));
.mc
/* tIdent */
# define begintIdent(a)         a = Idents_PREFIX NoIdent;
# define closetIdent(a)
# define readtIdent(a)          a = yyReadIdent ();
# define writetIdent(a)         Idents_PREFIX WriteIdent (yyf, a);
# define gettIdent(a)           yyGetIdent (& a);
# define puttIdent(a)           yyPutIdent (a);
# define copytIdent(a, b)
# define equaltIdent(a, b)      (a) == (b)
.mc \(bv
# define writeXMLtIdent(a)      yyWriteStringXML (Idents_PREFIX GetCStr (a));
/* tWIdent */
# define begintWIdent(a)        a = Idents_PREFIX NoWIdent;
# define closetWIdent(a)
# define readtWIdent(a)
# define writetWIdent(a)        Idents_PREFIX WriteWIdent (yyf, a);
# define gettWIdent(a)
# define puttWIdent(a)          { Idents_PREFIX WriteWIdent (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copytWIdent(a, b)
# define equaltWIdent(a, b)     (a) == (b)
# define writeXMLtWIdent(a)     yyWriteWStringXML (Idents_PREFIX GetWCStr (a));
/* vtIdent */
# define beginvtIdent(a)        a = Idents_PREFIX vNoIdent;
# define closevtIdent(a)
# define readvtIdent(a)
# define writevtIdent(a)        Idents_PREFIX vWriteIdent (yyf, a);
# define getvtIdent(a)
# define putvtIdent(a)          { Idents_PREFIX vWriteIdent (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copyvtIdent(a, b)
# define equalvtIdent(a, b)     (a) == (b)
# define writeXMLvtIdent(a)     yyWriteStringXML (Idents_PREFIX vGetCStr (a));
.mc
/* tSet */
# define begintSet(a)
# define closetSet(a)
# define readtSet(a)            ReadSet (yyf, & a);
# define writetSet(a)           WriteSet (yyf, & a);
# define gettSet(a)
# define puttSet(a)
# define copytSet(a, b)
# define equaltSet(a, b)        IsEqual (& a, & b)
.mc \(bv
# define writeXMLtSet(a)        WriteSet (yyf, & a);
.mc
/* tPosition */
# define begintPosition(a)      a = NoPosition;
# define closetPosition(a)
# define readtPosition(a)       ReadPosition (yyf, & a);
# define writetPosition(a)      WritePosition (yyf, a);
# define gettPosition(a)        yyGet ((char *) & a, sizeof (a));
# define puttPosition(a)        yyPut ((char *) & a, sizeof (a));
# define copytPosition(a, b)
# define equaltPosition(a, b)   Compare (a, b) == 0
.mc \(bv
# define writeXMLtPosition(a)   WritePosition (yyf, a);
.mc
/* NodeHead */
# define beginNodeHead(a)
# define closeNodeHead(a)
# define readNodeHead(a)
# define writeNodeHead(a)
# define getNodeHead(a)
# define putNodeHead(a)
# define copyNodeHead(a, b)
# define equalNodeHead(a, b)    true
.mc \(bv
# define writeXMLNodeHead(a)
.mc
.FR
.bp
.uh "Appendix 11: Predefined Type Specific Operations for Proper C++"
.sp
.nf
.FT
// int
# define beginint(a)
# define closeint(a)
# define readint(a)             fscanf (yyf, "%d", & a);
# define writeint(a)            fprintf (yyf, "%d", a);
# define getint(a)              yyGet ((char *) & a, sizeof (a));
# define putint(a)              yyPut ((char *) & a, sizeof (a));
# define copyint(a, b)
# define equalint(a, b)         (a) == (b)
.mc \(bv
# define writeXMLint(a)         fprintf (yyf, "%d", a);
.mc
// short
# define beginshort(a)
# define closeshort(a)
# define readshort(a)           fscanf (yyf, "%hd", & a);
# define writeshort(a)          fprintf (yyf, "%hd", a);
# define getshort(a)            yyGet ((char *) & a, sizeof (a));
# define putshort(a)            yyPut ((char *) & a, sizeof (a));
# define copyshort(a, b)
# define equalshort(a, b)       (a) == (b)
.mc \(bv
# define writeXMLshort(a)       fprintf (yyf, "%hd", a);
.mc
// long
# define beginlong(a)
# define closelong(a)
# define readlong(a)            fscanf (yyf, "%ld", & a);
# define writelong(a)           fprintf (yyf, "%ld", a);
# define getlong(a)             yyGet ((char *) & a, sizeof (a));
# define putlong(a)             yyPut ((char *) & a, sizeof (a));
# define copylong(a, b)
# define equallong(a, b)        (a) == (b)
.mc \(bv
# define writeXMLlong(a)        fprintf (yyf, "%ld", a);
.mc
// unsigned
# define beginunsigned(a)
# define closeunsigned(a)
# define readunsigned(a)        fscanf (yyf, "%u", & a);
# define writeunsigned(a)       fprintf (yyf, "%u", a);
# define getunsigned(a)         yyGet ((char *) & a, sizeof (a));
# define putunsigned(a)         yyPut ((char *) & a, sizeof (a));
# define copyunsigned(a, b)
# define equalunsigned(a, b)    (a) == (b)
.mc \(bv
# define writeXMLunsigned(a)    fprintf (yyf, "%u", a);
.mc
// float
# define beginfloat(a)
# define closefloat(a)
# define readfloat(a)           fscanf (yyf, "%g", & a);
# define writefloat(a)          fprintf (yyf, "%g", a);
# define getfloat(a)            yyGet ((char *) & a, sizeof (a));
# define putfloat(a)            yyPut ((char *) & a, sizeof (a));
# define copyfloat(a, b)
# define equalfloat(a, b)       (a) == (b)
.mc \(bv
# define writeXMLfloat(a)       fprintf (yyf, "%g", a);
.mc
// double
# define begindouble(a)
# define closedouble(a)
# define readdouble(a)          fscanf (yyf, "%g", & a);
# define writedouble(a)         fprintf (yyf, "%g", a);
# define getdouble(a)           yyGet ((char *) & a, sizeof (a));
# define putdouble(a)           yyPut ((char *) & a, sizeof (a));
# define copydouble(a, b)
# define equaldouble(a, b)      (a) == (b)
.mc \(bv
# define writeXMLdouble(a)      fprintf (yyf, "%g", a);
.mc
// rbool
# define beginrbool(a)
# define closerbool(a)
# define readrbool(a)           a = fgetc (yyf) == 'T';
# define writerbool(a)          fputc (a ? 'T' : 'F', yyf);
# define getrbool(a)            yyGet ((char *) & a, sizeof (a));
# define putrbool(a)            yyPut ((char *) & a, sizeof (a));
# define copyrbool(a, b)
# define equalrbool(a, b)       (a) == (b)
.mc \(bv
# define writeXMLrbool(a)       fputc (a ? 'T' : 'F', yyf);
// bool
# define beginbool(a)
# define closebool(a)
# define readbool(a)            a = fgetc (yyf) == 'T';
# define writebool(a)           fputc (a ? 'T' : 'F', yyf);
# define getbool(a)             yyGet ((bool *) & a, sizeof (a));
# define putbool(a)             yyPut ((bool *) & a, sizeof (a));
# define copybool(a, b)
# define equalbool(a, b)        (a) == (b)
# define writeXMLbool(a)        fputc (a ? 'T' : 'F', yyf);
.mc
// char
# define beginchar(a)
# define closechar(a)
# define readchar(a)            a = fgetc (yyf);
# define writechar(a)           fputc (a, yyf);
# define getchar(a)             yyGet ((char *) & a, sizeof (a));
# define putchar(a)             yyPut ((char *) & a, sizeof (a));
# define copychar(a, b)
# define equalchar(a, b)        (a) == (b)
.mc \(bv
# define writeXMLchar(a)        yyWriteCharXML (a);
// vchar
# define beginvchar(a)
# define closevchar(a)
# define readvchar(a)           fscanf (yyf, vFc, & a);
# define writevchar(a)          fprintf (yyf, vFc, a);
# define getvchar(a)            yyGet ((char *) & a, sizeof (a));
# define putvchar(a)            yyPut ((char *) & a, sizeof (a));
# define copyvchar(a, b)
# define equalvchar(a, b)       (a) == (b)
# define writeXMLvchar(a)       yyWriteCharXML (a);
.mc
// tString
# define begintString(a)
# define closetString(a)
# define readtString(a)
# define writetString(a)        fputs (a, yyf);
# define gettString(a)
# define puttString(a)
# define copytString(a, b)
# define equaltString(a, b)     strcmp (a, (b)) == 0
.mc \(bv
# define writeXMLtString(a)     yyWriteStringXML (a);
.mc
// tStringRef
# define begintStringRef(a)     a = String_PREFIX NoString;
# define closetStringRef(a)
# define readtStringRef(a)      { char yys [1024]; \\
                                  fgets (yys, 1024, yyf); \\
                                  ungetc ('\\n', yyf); \\
                          a = String_PREFIX PutString (yys, strlen (yys) - 1); }
# define writetStringRef(a)       String_PREFIX WriteString (yyf, a);
# define gettStringRef(a)       { char yys [1024]; \\
                                  fgets (yys, 1024, yyf); \\
                          a = String_PREFIX PutString (yys, strlen (yys) - 1); }
# define puttStringRef(a)       { String_PREFIX WriteString (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copytStringRef(a, b)
# define equaltStringRef(a, b)  (a) == (b)
.mc \(bv
# define writeXMLtStringRef(a)  yyWriteStringXML (String_PREFIX StGetCStr (a));
// tWStringRef
# define begintWStringRef(a)    a = String_PREFIX NoWString;
# define closetWStringRef(a)
# define readtWStringRef(a)
# define writetWStringRef(a)    String_PREFIX WriteWString (yyf, a);
# define gettWStringRef(a)
# define puttWStringRef(a)      { String_PREFIX WriteWString (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copytWStringRef(a, b)
# define equaltWStringRef(a, b) (a) == (b)
# define writeXMLtWStringRef(a) yyWriteWStringXML (String_PREFIX StGetWCStr (a));
// vtStringRef
# define beginvtStringRef(a)    a = String_PREFIX vNoString;
# define closevtStringRef(a)
# define readvtStringRef(a)
# define writevtStringRef(a)    String_PREFIX vWriteString (yyf, a);
# define getvtStringRef(a)
# define putvtStringRef(a)      { String_PREFIX vWriteString (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copyvtStringRef(a, b)
# define equalvtStringRef(a, b) (a) == (b)
# define writeXMLvtStringRef(a) yyWriteStringXML (String_PREFIX vStGetCStr (a));
.mc
// tIdent
# define begintIdent(a)         a = Idents_PREFIX NoIdent;
# define closetIdent(a)
# define readtIdent(a)          a = yyReadIdent ();
# define writetIdent(a)         Idents_PREFIX WriteIdent (yyf, a);
# define gettIdent(a)           yyGetIdent (& a);
# define puttIdent(a)           yyPutIdent (a);
# define copytIdent(a, b)
# define equaltIdent(a, b)      (a) == (b)
.mc \(bv
# define writeXMLtIdent(a)      yyWriteStringXML (Idents_PREFIX GetCStr (a));
// tWIdent
# define begintWIdent(a)        a = Idents_PREFIX NoWIdent;
# define closetWIdent(a)
# define readtWIdent(a)
# define writetWIdent(a)        Idents_PREFIX WriteWIdent (yyf, a);
# define gettWIdent(a)
# define puttWIdent(a)          { Idents_PREFIX WriteWIdent (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copytWIdent(a, b)
# define equaltWIdent(a, b)     (a) == (b)
# define writeXMLtWIdent(a)     yyWriteWStringXML (Idents_PREFIX GetWCStr (a));
// vtIdent
# define beginvtIdent(a)        a = Idents_PREFIX vNoIdent;
# define closevtIdent(a)
# define readvtIdent(a)
# define writevtIdent(a)        Idents_PREFIX vWriteIdent (yyf, a);
# define getvtIdent(a)
# define putvtIdent(a)          { Idents_PREFIX vWriteIdent (yyf, a); \\
                                  fputc ('\\n', yyf); }
# define copyvtIdent(a, b)
# define equalvtIdent(a, b)     (a) == (b)
# define writeXMLvtIdent(a)     yyWriteStringXML (Idents_PREFIX vGetCStr (a));
.mc
// tSet
# define begintSet(a)
# define closetSet(a)
# define readtSet(a)            ReadSet (yyf, & a);
# define writetSet(a)           WriteSet (yyf, & a);
# define gettSet(a)
# define puttSet(a)
# define copytSet(a, b)
# define equaltSet(a, b)        IsEqual (& a, & b)
.mc \(bv
# define writeXMLtSet(a)        WriteSet (yyf, & a);
.mc
// tPosition
# define begintPosition(a)      a = NoPosition;
# define closetPosition(a)
# define readtPosition(a)       ReadPosition (yyf, & a);
# define writetPosition(a)      WritePosition (yyf, a);
# define gettPosition(a)        yyGet ((char *) & a, sizeof (a));
# define puttPosition(a)        yyPut ((char *) & a, sizeof (a));
# define copytPosition(a, b)
# define equaltPosition(a, b)   Compare (a, b) == 0
.mc \(bv
# define writeXMLtPosition(a)   WritePosition (yyf, a);
.mc
// NodeHead
# define beginNodeHead(a)
# define closeNodeHead(a)
# define readNodeHead(a)
# define writeNodeHead(a)
# define getNodeHead(a)
# define putNodeHead(a)
# define copyNodeHead(a, b)
# define equalNodeHead(a, b)    true
.mc \(bv
# define writeXMLNodeHead(a)
.mc
.FR
.bp
.uh "Appendix 12: Predefined Type Specific Operations for Modula-2"
.sp 0.5
.nf
.FT
(* INTEGER *)
# define beginINTEGER(a)
# define closeINTEGER(a)
# define readINTEGER(a)         a := IO.ReadI (yyf);
# define writeINTEGER(a)        IO.WriteI (yyf, a, 0);
# define getINTEGER(a)          yyGet (a);
# define putINTEGER(a)          yyPut (a);
# define copyINTEGER(a, b)
# define equalINTEGER(a, b)     a = b
.mc \(bv
# define writeXMLINTEGER(a)     IO.WriteI (yyf, a, 0);
.mc
(* SHORTINT *)
# define beginSHORTINT(a)
# define closeSHORTINT(a)
# define readSHORTINT(a)        a := IO.ReadI (yyf);
# define writeSHORTINT(a)       IO.WriteI (yyf, a, 0);
# define getSHORTINT(a)         yyGet (a);
# define putSHORTINT(a)         yyPut (a);
# define copySHORTINT(a, b)
# define equalSHORTINT(a, b)    a = b
.mc \(bv
# define writeXMLSHORTINT(a)    IO.WriteI (yyf, a, 0);
.mc
(* LONGINT *)
# define beginLONGINT(a)
# define closeLONGINT(a)
# define readLONGINT(a)         a := IO.ReadI (yyf);
# define writeLONGINT(a)        IO.WriteI (yyf, a, 0);
# define getLONGINT(a)          yyGet (a);
# define putLONGINT(a)          yyPut (a);
# define copyLONGINT(a, b)
# define equalLONGINT(a, b)     a = b
.mc \(bv
# define writeXMLLONGINT(a)     IO.WriteI (yyf, a, 0);
.mc
(* CARDINAL *)
# define beginCARDINAL(a)
# define closeCARDINAL(a)
# define readCARDINAL(a)        a := IO.ReadI (yyf);
# define writeCARDINAL(a)       IO.WriteCard (yyf, a, 0);
# define getCARDINAL(a)         yyGet (a);
# define putCARDINAL(a)         yyPut (a);
# define copyCARDINAL(a, b)
# define equalCARDINAL(a, b)    a = b
.mc \(bv
# define writeXMLCARDINAL(a)    IO.WriteCard (yyf, a, 0);
.mc
(* SHORTCARD *)
# define beginSHORTCARD(a)
# define closeSHORTCARD(a)
# define readSHORTCARD(a)       a := IO.ReadI (yyf);
# define writeSHORTCARD(a)      IO.WriteCard (yyf, a, 0);
# define getSHORTCARD(a)        yyGet (a);
# define putSHORTCARD(a)        yyPut (a);
# define copySHORTCARD(a, b)
# define equalSHORTCARD(a, b)   a = b
.mc \(bv
# define writeXMLSHORTCARD(a)   IO.WriteCard (yyf, a, 0);
.mc
(* LONGCARD *)
# define beginLONGCARD(a)
# define closeLONGCARD(a)
# define readLONGCARD(a)        a := IO.ReadI (yyf);
# define writeLONGCARD(a)       IO.WriteCard (yyf, a, 0);
# define getLONGCARD(a)         yyGet (a);
# define putLONGCARD(a)         yyPut (a);
# define copyLONGCARD(a, b)
# define equalLONGCARD(a, b)    a = b
.mc \(bv
# define writeXMLLONGCARD(a)    IO.WriteCard (yyf, a, 0);
.mc
(* REAL *)
# define beginREAL(a)
# define closeREAL(a)
# define readREAL(a)            a := IO.ReadR (yyf);
# define writeREAL(a)           IO.WriteR (yyf, a, 0, 6, 1);
# define getREAL(a)             yyGet (a);
# define putREAL(a)             yyPut (a);
# define copyREAL(a, b)
# define equalREAL(a, b)        a = b
.mc \(bv
# define writeXMLREAL(a)        IO.WriteR (yyf, a, 0, 6, 1);
.mc
(* LONGREAL *)
# define beginLONGREAL(a)
# define closeLONGREAL(a)
# define readLONGREAL(a)        a := IO.ReadR (yyf);
# define writeLONGREAL(a)       IO.WriteR (yyf, a, 0, 6, 1);
# define getLONGREAL(a)         yyGet (a);
# define putLONGREAL(a)         yyPut (a);
# define copyLONGREAL(a, b)
# define equalLONGREAL(a, b)    a = b
.mc \(bv
# define writeXMLLONGREAL(a)    IO.WriteR (yyf, a, 0, 6, 1);
.mc
(* BOOLEAN *)
# define beginBOOLEAN(a)
# define closeBOOLEAN(a)
# define readBOOLEAN(a)         a := IO.ReadB (yyf);
# define writeBOOLEAN(a)        IO.WriteB (yyf, a);
# define getBOOLEAN(a)          yyGet (a);
# define putBOOLEAN(a)          yyPut (a);
# define copyBOOLEAN(a, b)
# define equalBOOLEAN(a, b)     a = b
.mc \(bv
# define writeXMLBOOLEAN(a)     IO.WriteB (yyf, a);
.mc
(* CHAR *)
# define beginCHAR(a)
# define closeCHAR(a)
# define readCHAR(a)            a := IO.ReadC (yyf);
# define writeCHAR(a)           IO.WriteC (yyf, a);
# define getCHAR(a)             yyGet (a);
# define putCHAR(a)             yyPut (a);
# define copyCHAR(a, b)
# define equalCHAR(a, b)        a = b
.mc \(bv
# define writeXMLCHAR(a)        IO.WriteC (yyf, a);
.mc
(* BITSET *)
# define beginBITSET(a)
# define closeBITSET(a)
# define readBITSET(a)          yyReadHex (a);
# define writeBITSET(a)         yyWriteHex (a);
# define getBITSET(a)           yyGet (a);
# define putBITSET(a)           yyPut (a);
# define copyBITSET(a, b)
# define equalBITSET(a, b)      a = b
.mc \(bv
# define writeXMLCHAR(a)
.mc
(* BYTE *)
# define beginBYTE(a)
# define closeBYTE(a)
# define readBYTE(a)            yyReadHex (a);
# define writeBYTE(a)           yyWriteHex (a);
# define getBYTE(a)             yyGet (a);
# define putBYTE(a)             yyPut (a);
# define copyBYTE(a, b)
# define equalBYTE(a, b)        a = b
.mc \(bv
# define writeXMLBYTE(a)        yyWriteHex (a);
.mc
(* WORD *)
# define beginWORD(a)
# define closeWORD(a)
# define readWORD(a)            yyReadHex (a);
# define writeWORD(a)           yyWriteHex (a);
# define getWORD(a)             yyGet (a);
# define putWORD(a)             yyPut (a);
# define copyWORD(a, b)
# define equalWORD(a, b)        a = b
.mc \(bv
# define writeXMLWORD(a)        yyWriteHex (a);
.mc
(* ADDRESS *)
# define beginADDRESS(a)
# define closeADDRESS(a)
# define readADDRESS(a)         yyReadHex (a);
# define writeADDRESS(a)        yyWriteHex (a);
# define getADDRESS(a)          yyGet (a);
# define putADDRESS(a)          yyPut (a);
# define copyADDRESS(a, b)
# define equalADDRESS(a, b)     a = b
.mc \(bv
# define writeXMLADDRESS(a)     yyWriteHex (a);
.mc
(* tString *)
# define begintString(a)
# define closetString(a)
# define readtString(a)         Strings.ReadL (yyf, a);
# define writetString(a)        Strings.WriteL (yyf, a);
# define gettString(a)          yyGet (a);
# define puttString(a)          yyPut (a);
# define copytString(a, b)
# define equaltString(a, b)     Strings.IsEqual (a, b)
.mc \(bv
# define writeXMLtString(a)     Strings.WriteL (yyf, a);
(* tWString *)
# define begintWString(a)
# define closetWString(a)
# define readtWString(a)        WStrings.ReadL (yyf, a);
# define writetWString(a)       WStrings.WriteL (yyf, a);
# define gettWString(a)         yyGet (a);
# define puttWString(a)         yyPut (a);
# define copytWString(a, b)
# define equaltWString(a, b)    WStrings.IsEqual (a, b)
# define writeXMLtWString(a)    WStrings.WriteL (yyf, a);
.mc
(* tStringRef *)
# define begintStringRef(a)     a := StringM.NoString;
# define closetStringRef(a)
# define readtStringRef(a)
# define writetStringRef(a)     StringM.WriteString (yyf, a);
# define gettStringRef(a)
# define puttStringRef(a)
# define copytStringRef(a, b)
# define equaltStringRef(a, b)  a = b
.mc \(bv
# define writeXMLtStringRef(a)  StringM.WriteString (yyf, a);
(* tWStringRef *)
# define begintWStringRef(a)    a := StringM.NoString;
# define closetWStringRef(a)
# define readtWStringRef(a)
# define writetWStringRef(a)    StringM.WriteWString (yyf, a);
# define gettWStringRef(a)
# define puttWStringRef(a)
# define copytWStringRef(a, b)
# define equaltWStringRef(a, b) (a) = (b)
# define writeXMLtWStringRef(a) StringM.WriteWString (yyf, a);
.mc
(* tIdent *)
# define begintIdent(a)         a := Idents.NoIdent;
# define closetIdent(a)
# define readtIdent(a)          a := yyReadIdent ();
# define writetIdent(a)         Idents.WriteIdent (yyf, a);
# define gettIdent(a)           yyGetIdent (a);
# define puttIdent(a)           yyPutIdent (a);
# define copytIdent(a, b)
# define equaltIdent(a, b)      a = b
.mc \(bv
# define writeXMLtIdent(a)      Idents.WriteIdent (yyf, a);
(* tWIdent *)
# define begintWIdent(a)        a := Idents.NoWIdent;
# define closetWIdent(a)
# define readtWIdent(a)
# define writetWIdent(a)        Idents.WriteWIdent (yyf, a);
# define gettWIdent(a)
# define puttWIdent(a)
# define copytWIdent(a, b)
# define equaltWIdent(a, b)     (a) = (b)
# define writeXMLtWIdent(a)     Idents.WriteWIdent (yyf, a);
.mc
(* tText *)
# define begintText(a)
# define closetText(a)
# define readtText(a)
# define writetText(a)          Texts.WriteText (yyf, a);
# define gettText(a)
# define puttText(a)
# define copytText(a, b)
# define equaltText(a, b)       FALSE
.mc \(bv
# define writeXMLtText(a)       Texts.WriteText (yyf, a);
.mc
(* tSet *)
# define begintSet(a)
# define closetSet(a)
# define readtSet(a)            Sets.ReadSet (yyf, a);
# define writetSet(a)           Sets.WriteSet (yyf, a);
# define gettSet(a)
# define puttSet(a)
# define copytSet(a, b)
# define equaltSet(a, b)        Sets.IsEqual (a, b)
.mc \(bv
# define writeXMLtSet(a)        Sets.WriteSet (yyf, a);
.mc
(* tRelation *)
# define begintRelation(a)
# define closetRelation(a)
# define readtRelation(a)       Relation.ReadRelation (yyf, a);
# define writetRelation(a)      Relation.WriteRelation (yyf, a);
# define gettRelation(a)
# define puttRelation(a)
# define copytRelation(a, b)
# define equaltRelation(a, b)   Relation.IsEqual (a, b)
.mc \(bv
# define writeXMLtRelation(a)   Relation.WriteRelation (yyf, a);
.mc
(* tPosition *)
# define begintPosition(a)      a := Position.NoPosition;
# define closetPosition(a)
# define readtPosition(a)       Position.ReadPosition (yyf, a);
# define writetPosition(a)      Position.WritePosition (yyf, a);
# define gettPosition(a)        yyGet (a);
# define puttPosition(a)        yyPut (a);
# define copytPosition(a, b)
# define equaltPosition(a, b)   Position.Compare (a, b) = 0
.mc \(bv
# define writeXMLtPosition(a)   Position.WritePosition (yyf, a);
.mc
(* NodeHead *)
# define beginNodeHead(a)
# define closeNodeHead(a)
# define readNodeHead(a)
# define writeNodeHead(a)
# define getNodeHead(a)
# define putNodeHead(a)
# define copyNodeHead(a, b)
# define equalNodeHead(a, b)    TRUE
.mc \(bv
# define writeXMLNodeHead(a)
.mc
.bp
.FR
.uh "Appendix 13: Predefined Type Specific Operations for Java"
.sp
Note: The operations getTYPE and putTYPE are not used.
.sp
.nf
.FT
// boolean
# define beginboolean(a)
# define closeboolean(a)
# define readboolean(a)         a = yyin.readB ();
# define writeboolean(a)        yyout.write (a);
# define copyboolean(a, b)      a = (b);
# define equalboolean(a, b)     (a) == (b)
.mc \(bv
# define writeXMLboolean(a)     yyout.write (a);
.mc
// byte
# define beginbyte(a)
# define closebyte(a)
# define readbyte(a)            a = (byte) yyin.readI ();
# define writebyte(a)           yyout.write ((int) a);
# define copybyte(a, b)         a = (b);
# define equalbyte(a, b)        (a) == (b)
.mc \(bv
# define writeXMLbyte(a)        yyout.write ((int) a);
.mc
// char
# define beginchar(a)
# define closechar(a)
# define readchar(a)            a = (char) yyin.read ();
# define writechar(a)           yyout.write (a);
# define copychar(a, b)         a = (b);
# define equalchar(a, b)        (a) == (b)
.mc \(bv
# define writeXMLchar(a)        yyout.write (a);
.mc
// double
# define begindouble(a)
# define closedouble(a)
# define readdouble(a)          a = Double.parseDouble (yyin.readL (). \\
                                  toString ());
# define writedouble(a)         yyout.write (Double.toString (a)); \\
                                  yyout.writeNl ();
# define copydouble(a, b)       a = (b);
# define equaldouble(a, b)      (a) == (b)
.mc \(bv
# define writeXMLdouble(a)      yyout.write (Double.toString (a));
.mc
// float
# define beginfloat(a)
# define closefloat(a)
# define readfloat(a)           a = yyin.readR ();
# define writefloat(a)          yyout.write (a, 0, 0, 0);
# define copyfloat(a, b)        a = (b);
# define equalfloat(a, b)       (a) == (b)
.mc \(bv
# define writeXMLfloat(a)       yyout.write (a, 0, 0, 0);
.mc
// int
# define beginint(a)
# define closeint(a)
# define readint(a)             a = yyin.readI ();
# define writeint(a)            yyout.write (a);
# define copyint(a, b)          a = (b);
# define equalint(a, b)         (a) == (b)
.mc \(bv
# define writeXMLint(a)         yyout.write (a);
.mc
// long
# define beginlong(a)
# define closelong(a)
# define readlong(a)            a = Long.parseLong (yyin.readL ().toString ());
# define writelong(a)           yyout.write (Long.toString (a)); \\
                                  yyout.writeNl ();
# define copylong(a, b)         a = (b);
# define equallong(a, b)        (a) == (b)
.mc \(bv
# define writeXMLlong(a)        yyout.write (Long.toString (a));
.mc
// short
# define beginshort(a)
# define closeshort(a)
# define readshort(a)           a = (short) yyin.readI ();
# define writeshort(a)          yyout.write ((int) a);
# define copyshort(a, b)        a = (b);
# define equalshort(a, b)       (a) == (b)
.mc \(bv
# define writeXMLshort(a)       yyout.write ((int) a);
.mc
// Ident
# define beginIdent(a)
# define closeIdent(a)
# define readIdent(a)           a = Idents_PREFIX makeIdent (yyin.readL ());
.mc \(bv
# define writeIdent(a)          yyout.write (a);
.mc
# define copyIdent(a, b)        a = (b);
# define equalIdent(a, b)       (a.equals (b))
.mc \(bv
# define writeXMLIdent(a)       yyout.write (a);
.mc
// Position
# define beginPosition(a)       a = Position.NoPosition;
# define closePosition(a)
# define readPosition(a)        a = new Position (yyin);
# define writePosition(a)       yyout.write (a);
# define copyPosition(a, b)     a = (b);
# define equalPosition(a, b)    (a.compareTo (b) == 0)
.mc \(bv
# define writeXMLPosition(a)    yyout.write (a);
.mc
// NodeHead
# define beginNodeHead(a)
# define closeNodeHead(a)       **not used**
# define readNodeHead(a)
# define writeNodeHead(a)
# define copyNodeHead(a, b)
# define equalNodeHead(a, b)    true
.mc \(bv
# define writeXMLNodeHead(a)
.mc
.FR
.fi
.sz 12
.bp 1
.b Contents
.sp
.xp
