.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.EQ
gsize 12
delim off
.EN
.T0

	Cocktail FAQ
	Frequently Asked Questions


	J. Grosch


.T1
.T2 "" "Cocktail FAQ - Frequently Asked Questions" "Josef Grosch" "Oct. 2, 1998" 35 1998
.bp 1
.ce 99
.b "Cocktail FAQ - Frequently Asked Questions"
.sp 1.5
Josef Grosch
CoCoLab
Hagsfelder Allee 16
D-76131 Karlsruhe
Germany
.sp 0.5
Tel: +49-721-697061
Fax: +49-721-661966
EMail: grosch@cocolab.de
.ce 0
.sp 1
.uh Abstract
.lp
This list answers some frequently asked questions about the Cocktail Toolbox.
Although most of the questions are about efficiency there are some other topics
as well.
.sh 1 "What does COCKTAIL stand for?"
.lp
Cocktail stands for
.(b
COmpiler Compiler ToolkIt KArLsruhe or
COmpiler CompIler Toolbox KArLsruhe.
.)b
Some creativity is needed to bring the relevant characters into the right order.
.sh 1 "How to generate efficient compilers?"
.lp
When we want to construct efficient software, we want to reduce or optimize
two aspects: run time and storage. There are measures that improve both aspects
together and there are measures that improve one aspect at the expense of the
other.
.lp
The Cocktail Tools have been designed originally for the operating system UNIX
which usually provides a sufficient amount of storage. Therefore the compiler
parts generated by Cocktail are primarily oriented towards run time efficiency
which sometimes causes an increased need for storage.
.lp
When we are asking for an efficient compiler we have to specify first
what we want to reduce primarily: run time or storage. Then we have to
construct all compiler parts according to this goal: input handling, scanner,
parser, etc. .
.sh 2 "How to make input as efficient as possible?"
.lp
Input is handled in the module
.i Source
by the procedure
.i GetLine .
The default version of this module reads large blocks of characters from a file.
This is actually done using the procedure
.i rRead
from the module
.i rSystem
in the reuse library. The only concern is the aspect of run time.
.lp
When reading from a file using rRead, select a fast variant of rRead from the
following possibilities (in order of decreasing speed):
.ip -
Use the UNIX system call read.
.ip -
Use the function fread of the C library.
.ip -
Use the function fgets of the C library.
.lp
General hints:
.ip -
Let the procedure GetLine return as large blocks of characters as possible up to
the maximal size given by the argument Size.
.ip -
Avoid any preprocessing such as e. g. truncating line length to 72 characters.
.sh 2 "How to generate efficient scanners?"
.sh 3 "How to generate fast scanners?"
.lp
.ip -
Specify separate patterns for the keywords.
.ip -
Avoid backtracking (or backing up) by following the next hints (in decreasing
importance):
.ip .
Avoid the use of right context where both regular expressions match an arbitrary
number of characters.
.ip .
Avoid the use of right context where one regular expression matches a fixed
number of characters.
.ip .
Avoid the use of right context at all.
.ip .
Avoid the use of the action yyLess.
.ip -
The predefined rule for skipping blanks is faster than an explicitly specified
rule. Therefore, usually it is a good idea to avoid rules such as
.(b
.FT
" "     :- {}
" " +   :- {}
.)b
.ip -
Avoid the use of the left justification operator <.
.ip -
Compute source positions only where necessary. This means to
introduce the action part in rules with :- instead of :.
.ip -
Avoid unnecessary copying of tokens by calling GetWord and so on.
.ip -
.ta 3c
.nf
Replace	l = GetWord (s); x = MakeIdent (s, l);
by	x = MakeIdent (TokenPtr, TokenLength);
Replace	l = GetWord (s); x = PutString (s, l);
by	x = PutString (TokenPtr, TokenLength);
Replace	GetWord (s); x = atoi (s);
by	x = atoi (TokenPtr); if possible
.ip -
Avoid calling of procedures in the actions, prefer inline code.
.ip -
Avoid wrapper functions such as:
.(b
.FT
GLOBAL {
   int GetToken ARGS ((void))
   {
      register int Token = Get_Token ();
      ...
      return Token;
   }

   # define GetToken Get_Token
}
.)b
.sh 3 "How to generate small scanners?"
.lp
A generated scanner uses an initial buffer for 8448 characters.
It also contains a stack of states of that size (16896 bytes) which yields an
initial space requirement for the main data structures of 25344 bytes.
.ip -
Decrease the initial buffer size by using a #define directive such as:
.(b
.FT
# define yyInitBufferSize       1024 * 1 + 256
.)b
.ip -
Decrease the size of the stack for include files by using a #define directive
such as:
.(b
.FT
# define yyInitFileStackSize    4
.)b
.ip -
Do not specify separate patterns for the keywords. Recognize keywords with the
pattern for identifiers and distinguish both cases with an additional mechanism.
Might be worth while if there are many keywords - and the additional
mechanism also uses space.
.ip -
Minimize the number of start states.
.ip -
Avoid the constructs for counted repetition of regular expressions such as e. g.
.(b
.FT
a [3]
a [0-4]
.)b
In most cases this causes a big increase in table size.
.ip -
Minimize the maximal length of tokens, because otherwise the buffer size could
increase dynamically. Example: Do not recognize comments as one
token but break it up into smaller parts.
.ip -
Avoid include files, that means avoid calls of BeginFile, because this will
allocate additional buffers.
.ip -
Use options -r and -o, do not use option -i, if possible.
.(b
. ta 2c
-o	optimize table size
-r	reduce number of generated switch labels
-i	use ISO 8 bit code instead of ASCII 7 bit code
.)b
.ip -
Unused functions should be removed from the generated scanner such as e. g.
GetWord, GetUpper, GetLower, input, yyPush, yyPop, etc. (This is done
automatically.)
.ip -
Unused arrays should be removed from the generated scanner such as e. g.
yyToLower, yyToUpper, and yyStStStack. (This is done automatically.)
.sh 2 "How to compute the end position of tokens?"
.lp
The line and column numbers of the last character of all tokens can be
computed by including a "wrapper" procedure into the GLOBAL section similar
to the following:
.(b
.FT
int GetToken (void)
{
   int Token = Get_Token ();

   if (Token != EofToken) {
      Line   = yyLineCount;
      Column = (unsigned char *) TokenPtr - yyLineStart + TokenLength - 1;
   }
   return Token;
}

# define GetToken Get_Token
.)b
This code uses the two internal variables yyLineCount and yyLineStart which are
not documented, otherwise. It works even in case of tokens that are spread over
several lines or recognized by a series of rules.
.sh 2 "How to handle include files?"
.lp
The scanning of an include file is triggered by a call of the procedure
BeginFile with the name of the include file as argument.
This procedure can be called from the scanner or from the parser.
In both cases, care has to be taken of the exact moment of the call.
What BeginFile does is that it inserts the contents of the include file after a
certain character of the current file. This character is the one that has been
recognized last by the scanner.
.sh 3 "How to handle include files in the scanner?"
.lp
Let's assume the scanner specification contains the following rule:
.(b
.FT
"#" INCLUDE identifier   : { char word [256];
                             GetWord (word);
                             BeginFile (word + 8);
                             push (word + 8);
                             return ...;
                           }
.)b
This rule does not care about white space that might surround the keyword
INCLUDE. The contents of the include file is inserted exactly after the
last character of the identifier. This is done independently of any lookahead
that the scanner might need in order to recognize this rule.
In case of lookahead the scanner will backup automatically.
The return statement in the above rule is optional.
This rule might or might not produce a token.
.sh 3 "How to handle include files in the parser?"
.lp
The call of BeginFile can be issued by the parser as well, however, the scanner
behaves exactly as in the previous case. Additionally, the lookahead tokens that
the parser needs have to be taken into account. In simple cases, the parser
has requested exactly one lookahead token from the scanner whenever a grammar
rule is recognized or reduced. When trial parsing is used or access to
arbitrary lookahead tokens via the procedures GetLookahead or GetAttribute then
in general an unknown number of tokens have already been requested from the
scanner.
.lp
The following example shows how to call BeginFile from the parser:
.(b
.FT
include_statement = '#' INCLUDE
                  { => { { tScanAttribute a; GetAttribute (1, & a);
                           BeginFile (a.identifier.Ident); } };
                  } identifier .
.)b
This works only if this rule can be recognized without trial parsing.
BeginFile is called when the parser has accepted the tokens '#' and INCLUDE.
In order to do this the parser will request one lookahead token from the
scanner which is the identifier token in this case.
Now it is necessary to access the attribute of the identifier token,
which represents the name of the include file. The parser has not recognized
this token yet, it is only known as lookahead token. The access to this
attribute has to be done using the operation GetAttribute.
Again the contents of the include file is inserted exactly after the last
character of the identifier.
.lp
It would be wrong to move the semantic action in the above example to the end
of the right-hand side. The parser would request one more lookahead token in
order to recognize the complete rule. Then the include file would be inserted
after this lookahead token which is usually not what is wanted.
.sh 3 "How to keep track of the current filename?"
.lp
Implement a stack of filenames. Assume this stack has two operations called
push and pop. Whenever the procedure BeginFile is called, the operation push
should be executed as well. This operation pushes a filename on the stack
(see previous example).
Accordingly, whenever the procedure CloseFile is called, the operation pop
should be executed. However, CloseFile is usually called automatically by the
scanner and therefore there is no direct way to attach statements to this call.
A solution is the following:
CloseFile in turn calls CloseSource. The procedure CloseSource in the module
Source can be extended by an activation of pop. Get a copy of the Source module,
if it does not exist already in the current directory, and modify, compile, and
link it to your program. Then, the top element of the stack always contains the
current filename.
.sh 2 "How to access the start state from outside?"
.lp
The current start state of the scanner is available in the variable
.i yyStartState .
This variable is declared static in the scanner module. In order to make it
available for other compilation units you can include an interface function in
the GLOBAL section such as for example:
.(b
.FT
int GetStartState (void) { return yyStartState; }
.)b
.sh 2 "How to change the start state from outside?"
.lp
The start state of the scanner is changed by statements such as
.(b
.FT
yyStart (Comment);
.)b
In C,
.i yyStart
is implemented by a macro and
.i Comment
is defined by a preprocessor constant. Both items are delcared local to the
scanner module. In order to make them
available for other compilation units you can include an interface function in
the GLOBAL section such as for example:
.(b
.FT
void StartComment (void) { yyStart (Comment); }
.)b
.sh 2 "How to generate efficient parsers?"
.lp
First, the choice of the parser generator has some influence on the run time,
although the differences are not very high. Select one of the following parser
generators given in order of increasing run time:
.ip -
Use ell, version before February 1991: the error recovery detects errors as
late as possible. (This tool is currently not available any more.)
.ip -
Use ell, current version: errors are detected as early as possible. This gives
improved quality of error recovery at the cost of increased run time.
.ip -
Use lark.
.lp
General hints:
.ip -
Use only a few attributes for the terminal symbols, ideally at most one.
.ip -
Avoid chain rules. Example:
.(b
.FT
statement       = <
                = if_statement .
                = while_statement .
> .
if_statement    = IF expression THEN statement ELSE statement .

while_statement = WHILE expression DO statement .
.)b
can be improved to
.(b
.FT
statement       = <
                = IF expression THEN statement ELSE statement .
                = WHILE expression DO statement .
> .
.)b
.ip -
Use ambiguous rules for expressions and specify precedence and associativity for
the operators. Although this method introduces LR conflicts, run time can be
decreased substantially. Example:
.(b
.FT
expression      = <
                = expression '+' term .
                = expression '-' term .
                = term .
> .
term            = <
                = term '*' factor .
                = term '/' factor .
                = factor .
> .
factor          = <
                = number .
                = identifier .
                = '(' expression ')' .
> .
.)b
can be improved to
.(b
.FT
PREC            LEFT '+' '-'
                LEFT '*' '/'

expression      = <
                = expression '+' expression .
                = expression '-' expression .
                = expression '*' expression .
                = expression '/' expression .
                = number .
                = identifier .
                = '(' expression ')' .
> .
.)b
.ip -
Avoid separate rules for lists and list elements - merge lists and list
elements: Example:
.(b
.FT
statement_seq   = <
                = .
                = statement_seq statement ';' .
> .
statement       = <
                = IF expression THEN statement_seq ELSE statement_seq END .
                = WHILE expression DO statement_seq END .
> .
.)b
can be improved to
.(b
.FT
statement_seq   = <
                = .
                = statement_seq IF expression THEN statement_seq ELSE statement_seq END ';' .
                = statement_seq WHILE expression DO statement_seq END ';' .
> .
.)b
.ip -
Avoid separate rules for parts of constructs. Example:
.(b
.FT
statement       = IF expression then_part else_part END .

then_part       = THEN statement_seq .

else_part       = ELSE statement_seq .
.)b
can be improved to
.(b
.FT
statement       = IF expression THEN statement_seq ELSE statement_seq END .
.)b
.ip -
Avoid reduce actions. This is the general scheme behind all of the above
mentioned hints on how to write grammar rules. An LR parser such as e. g.
.i lark
executes shift and reduce actions. It executes exactly one shift action for
every input token. There is nothing that can be changed for shift actions.
And it executes one reduce action for every grammar rule that is recognized.
Therefore grammars should be written with as few rules as possible.
All of the above examples follow this general strategy.
.ip -
For ell, use grammar rules with iteration instead of recursion.
.ip -
For lark, avoid dynamic repair of LR conflicts using semantic and syntactic
predicates.
.ip -
For lark, avoid reparsing.
.sh 3 "How to generate fast parsers?"
.lp
.ip -
Use options -u and -o. This generates fast and large tables. The default is to
generate slow and small tables.
.sh 3 "How to generate small parsers?"
.lp
.ip -
Use option -n. This decreases the number of case labels in switch statements.
.ip -
Use option -4. This make use of tables to decrement stack pointers instead of
inline code.
.ip -
Do not use option -r: This would disable the elimination of LR(0) reductions.
.ip -
For lark, avoid right recursive grammar rules. These rules can lead to large
expansion of the parsing stack.
.ip -
Preset the initial size of the parsing stack to the maximum size that will
usually be needed by including a #define directive into the GLOBAL section:
.(b
.FT
# define yyInitStackSize        100
.)b
.ip -
For lark, when the default error recovery which includes comfortable reporting,
repair, and recovery is not needed then it can be switched to simple panic mode
by including the following definition into the GLOBAL section:
.(b
.FT
# define ERROR fprintf (stderr, "syntax error at %d, %d\\n", \\
        Attribute.Position.Line, Attribute.Position.Column);
.)b
.ip -
Once error recovery has been switched to panic mode, the following procedures
can be removed from a generated parser:
yyErrorRecovery, yyComputeContinuation, yyIsContinuation, yyComputeRestartPoints.
The remaining calls to yyErrorRecovery and ErrorMessageI have to be removed, too.
Also, the #include directives for the modules Errors, Sets, and Position can be
removed or disabled as well, so that these modules are not linked to the program.
This is achieved by including the following definition into the GLOBAL section:
.(b
.FT
# define NO_RECOVER
.)b
.sh 2 "How to generate efficient syntax trees?"
.lp
.ip -
Define the tree structure by as few nodes as possible.
.ip -
Avoid separate rules for lists and list elements - merge lists and list
elements: Example:
.(b
.FT
statement_seq   = <
   stat_seq_0   = .
   stat_seq_1   = statement_seq statement .
> .
statement       = <
   if           = expression then: statement_seq else: statement_seq .
   while        = expression statement_seq .
> .
.)b
can be improved to
.(b
.FT
statement_seq   = <
   no_statement = .
   statement    = next: statement_seq <
      if        = expression then: statement_seq else: statement_seq .
      while     = expression statement_seq .
   > .
> .
.)b
.ip -
Use inline attributes. Example:
.(b
.FT
call            = identifier arguments .
identifier      = [ident: tIdent] .
.)b
can be improved to
.(b
.FT
call            = [ident: tIdent] arguments .
.)b
.ip -
Generate only the procedures that are really used.
.ip -
Switch off the generation of the procedures CheckTree or WriteTree after the
development phase.
.ip -
Remove the array Tree_NodeName from the generated tree module in case it is not
needed. (This should be supported somehow!)
.ip -
Remove #include directives for unused modules of the library reuse
from a generated tree module. By default, almost every module from the library
reuse that defines a data structure is included which may lead to the linking
of superfluous modules. (This is done automatically.)
.sh 2 "How to release space for parts of syntax trees?"
.lp
In order to be able to free space for single nodes or subtrees using the
procedure ReleaseTree two macro definitions are necessary in the GLOBAL section
of an ast description. For example:
.(b
.FT
# define yyALLOC(size1, size2) (tTree) Alloc (size2)
# define yyFREE(ptr, size) Free (size, ptr);
.)b
The section 2.15. of the
.i ast
manual about "Storage Management" describes the details.
.sh 2 "How to generate efficient attribute evaluators?"
.lp
.ip -
Use attribute grammars from the class OAG. This means to avoid the class WAG
and the option -L.
.ip -
Use the option -0 which optimizes the storage for attributes.
.sh 1 "How to avoid memory leaks?"
.lp
Almost all modules of the library reuse that store data have functions
for initialization and for finalization. The function names uniformly start
with Begin or Close:
.sp 0.5
.TS
center;
l l l.
Module	Initialization	Finalization
.sp 0.5
Idents	BeginIdents	CloseIdents
StringM	BeginStringMemory	CloseStringMemory
rMemory	BeginrMemory	CloserMemory
Errors	BeginErrors
Sets	BeginSets
.TE
.lp
In simple cases these functions do not have to be called because the modules
are initialized automatically, by default. However, if a parser is to be
executed repeatedly within a loop then explicit initialization and
finalization is advantageous in order to avoid memory leaks. The order of the
calls for initialization and finalization is significant and should be as
follows:
.(b
.FT
BeginrMemory         ();
for (;;) {
   BeginStringMemory ();
   BeginIdents       ();
   BeginErrors       ();
   Parser            ();
   ReleaseTreeModule ();
   CloseIdents       ();
   CloseStringMemory ();
}
CloserMemory         ();
.)b
.sh 1 "How to redefine the exception handling?"
.lp
Some of the Cocktail generated source modules might detect serious error
conditions which make it impossible to continue program execution.
These conditions are regarded as exceptions. The default reaction is to emit
an error message and to terminate program execution. The default reaction can be
changed by the user as described below. The following kinds of exceptions might
be detected:
.lp
.TS
center;
l l l.
Module	Exception	Remark
.sp 0.5
Scanner	cannot open input file	should be checked before calling BeginFile
	out of memory	huge token or lookahead, too many nested include files
	too many calls to CloseFile	can be checked at programming time
	too many calls to yyPop	can be checked at programming time
	internal error	should not occur
.sp 0.5
Tree	out of memory	too many tree nodes
.sp 0.5
Trafo	function failed	can be avoided at programming time
.sp 0.5
Errors	fatal message	can be avoided at programming time
.TE
.lp
The following example code shows how to change the default reaction of the
exception handling using the routines
.i setjmp
and
.i longjmp
of the C library:
.(b
.FT
# include <setjmp.h>
.sp 0.5
jmp_buf jmp_env;        /* buffer for longjmp */
.sp 0.5
void OurExit (void) { longjmp (jmp_env, 1); }   /* goto exception handler */
.sp 0.5
int main () {
                        /* register exception handler */
   if (setjmp (jmp_env)) {
      fprintf (stderr, "caught exception\n"); return 1;
   }
                        /* redefine ..._Exit routines of all Cocktail modules */
   Errors_Exit          = OurExit;
   Scanner_Exit         = OurExit;
   Tree_Exit            = OurExit;
   Trafo_Exit           = OurExit;
.sp 0.5
   ...
}
.)b
The above few lines at the beginning of the procedure
.i main
redefine the exception handling to execute the "then-part" of the if statement
in case of an exception. It can contain arbitrary code.
.sh 1 "How to compile the Cocktail code?"
.lp
.sh 2 "How to compile the Cocktail source code?"
.lp
In general every good 32 bit C compiler should work. The data type 'int' should
be represented by 32 bits. The compiler should obey either the C language
definition of Kernighan and Ritchie or ANSI C. And it should have no
restrictions such as for example array size <= 64 K or stack size <= 64 K.
Under Unix, the command 'make' at the global level of the source distribution
should do the job (see file README).
(Compiling the Cocktail source code with the 16 bit compiler Microsoft Visual
C++ version 1.52 failed.)
.sh 2 "How to compile the source code generated by Cocktail tools?"
.lp
See answer to previous and next questions.
.sh 2 "How to compile the generated code with Microsoft Visual C++?"
.lp
Since version 9607 it is possible to compile the source code generated by
Cocktail with the Microsoft Visual C++ compiler version 1.52. In order to
overcome the restrictions of this 16 bit compiler the following hints might
help:
.(b
- select the huge memory model (option /AH)
- set the new segment data size threshold (option /Gt8192)
- increase the stack size (up to 64 K)
- implement attribute evaluators as stack machines (ag -K)
.)b
.fi
.\" .sz 12
.\" .[]
.bp 1
.lp
.b Contents
.sp
.xp
