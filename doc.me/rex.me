.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.EQ
gsize 12
gfont R
.EN
.nr bi 0.5c     \" block indentation
.T0


	Rex
	A Scanner Generator

	J. Grosch


.T1
.T2 Rex "Rex - A Scanner Generator" "Josef Grosch" "Aug. 01, 2006" 5 2006
.hc @
.bp 1
.sh 1 Introduction
.pp
.i Rex
generates program code to be used in lexical analysis of text.
A typical application is the generation of scanners for compilers.
The generated scanners can handle single byte input as well as Unicode input.
Rex stands for Regular EXpression tool.
In principle it is a remake of LEX\*([<\*([[Les75\*(]]\*(>].
.pp
Rex processes a specification
containing regular expressions to be searched for, and actions written in one of
the target languages (C, C++, Modula-2, Ada, Eiffel or Java)
to be executed when regular expressions are matching.
Unrecognized portions of the input are copied by default to standard output.
Rex generates a table-driven scanner consisting of a scanner routine and
control tables. The scanner routine implements a tunnel automaton
\*([[Gro89\*(]] and contains a copy of the specified actions.
.pp
The scanners generated by Rex are 5 times faster and up to 5 times smaller
than those generated by LEX. It is possible to reach a speed of
1.5 million lines per minute on a SPARC station ELC.
(including input from file). If, additionally, hashing of identifiers is performed
the speed is around 1.25 million lines per minute.
The generator Rex itself is 10 to 20 times faster than LEX in typical cases.
Like LEX, Rex has all the features necessary to scan contemporary
languages: that is the left and the right context can be taken into account
to identify a token. The left context is handled by so-called start states
and the right context by additional regular expressions.
The source coordinates (line and column number) of recognized words are
calculated automatically. Scanners can be generated in the languages
C, C++, Modula-2, Ada, Eiffel or Java. Rex itself is implemented originally in Modula-2.
.pp
The following chapters constitute the user manual of Rex.
Chapter 2 gives an overview of the operation of Rex and how its output is
to be integrated in e. g. compilers.
Chapter 3 describes the specification language.
Chapter 4 summarizes the predefined items of the specification language.
Chapter 5 contains the specification of the interface of the generated scanners.
Chapter 6 shows how to invoke and use Rex.
Chapter 7 contains some details of the implementation.
Chapter 8 describes the differences between Rex and LEX for those
already familiar with LEX.
The appendices contain a grammar for the input language and some examples.
.sh 1 "Overview"
.(z L
.sp 0.5
.PS
define par #
	box invis $1
	line up boxht right boxwid * 1/6 from last box.sw
	line right boxwid * 5/6
	line down boxht left boxwid * 1/6
	line left boxwid * 5/6
#
delta	= boxwid * 0.1

P0:	par("Specifi-" "cation")
	arrow right at P0.e - (boxwid * 1/12, 0)
K:	box "Rex"
	move right movewid * 2
P3:	par("Scanner" "body")
	move up movewid/2 at P3.n
P2:	par("Scanner" "spec")
	move up movewid/2 at P2.n
P1:	par("Scanner" "driver")

	move down movewid/2 at P3.s
P4:	par("Source" "spec")
	move down movewid/2 at P4.s
P5:	par("Source" "body")

	arrow from K.e to P1.w + (boxwid * 1/12, 0)
	arrow from K.e to P2.w + (boxwid * 1/12, 0)
	arrow from K.e to P3.w + (boxwid * 1/12, 0)
	arrow from K.e to P4.w + (boxwid * 1/12, 0)
	arrow from K.e to P5.w + (boxwid * 1/12, 0)

A1:	arrow right linewid * 3 dashed at P1.e - (boxwid * 1/12, 0)
B1:	box "Scanner" "driver"
	arrow right linewid * 3 dashed at P3.e - (boxwid * 1/12, 0)
B2:	box "Scanner"
A3:	arrow right linewid * 3 dashed at P5.e - (boxwid * 1/12, 0)
B3:	box "Source"
	line down <- at B3.s
	par("Input")

	arrow from B3.n to B2.s
	arrow from B2.n to B1.s
	arrow from P2.e - (boxwid * 1/12, 0) to B2.w dashed
	arrow from P4.e - (boxwid * 1/12, 0) to B3.w dashed

	arrow from B1.s - (delta, 0) to B2.n - (delta, 0) dashed dashwid * 3
	arrow from B2.s - (delta, 0) to B3.n - (delta, 0) dashed dashwid * 3
L:	line from A1.start + (linewid * 1.5, 1) to A3.start + (linewid * 1.5, -1.5) dotted
	"generation time" at L.n - (1, 0) rjust
	"run time" at L.n + (1, 0) ljust

	arrow right at P0 - (linewid/2, 1.5)
	"  data flow" ljust
	arrow right at P0 - (linewid/2, 1.7) dashed
	"  compilation" ljust
	arrow right at P0 - (linewid/2, 1.9) dashed dashwid * 3
	"  invocation / use" ljust
boxwid	= boxwid/2
boxht	= boxht/2
	box at P0 - (0, 2.2)
	"    program / executable module" ljust
	move to P0 - (boxwid/2, 2.5 + boxht/2)
L5:	par("")
	"    file / memory area" ljust at L5.e
.PE
.sp
.ce
Fig. 1: Rex Overview
.)z
.pp
Figure 1 gives an overview of the observable behaviour of Rex.
It takes as input a specification of a lexical analyser written in the
language described in the next chapter. The output is the source text of a scanner.
The source
text consists of a specification and a body part. These parts are files with
the suffixes 'h' and 'c' if C is the target language. In the case of
Modula-2 the parts are a definition and an implementation module.
The scanner requires a source module to get blocks of characters e. g. by
input from file. Rex can be asked to provide a prototype source module
which performs input from the UNIX standard input file. Additionally Rex
can be asked to provide a main program to serve as test driver of the
scanner. This main program calls the scanner routine until the end of the
input is reached.
.pp
The above mentioned source programs constitute the minimum configuration to
run the generated scanner. What is happening after the compilation of the
program modules is shown in the "run time" half of Fig. 1.
Then the scanner driver starts calling the
scanner routine which in turn sometimes calls the source module routines to
get characters. The data flow is in the opposite direction. The source
module returns blocks of characters to the scanner. The scanner analyzes the
character stream, executes the associated actions upon finding character
sequences matched by regular expressions, and eventually returns tokens to
the scanner driver. In general the scanner driver can be replaced by any
other main program or subroutine like e. g. a parser.
.sh 1 "Specification Language"
.pp
The input of Rex consists mainly of three parts:
.(b L
- code written in the target language to be copied unchanged to the output (see 3.7.)
- definitions of named regular expressions and start states (see 3.4. + 3.5.)
- a set of regular expressions with associated actions written in the target language (see 3.2.)
.)b
The first two parts are optional. We discuss the three parts in reverse
order after introducing some lexical conventions.
.sh 2 "Lexical Conventions"
.pp
The specification can be written in unformatted manner. That means white
space in the form of blanks, tab characters, and newline characters has
no meaning except to separate other items.
.mc \(bv
Comments are written in the styles of C or C++:
Text included in '/*' and '*/' or from '//' to the end of line is ignored.
Comments may not be nested.
.mc
The specification uses a few keywords which should be escaped if needed as
identifiers (see below):
.(b
.FT
BEGIN         CHARACTER_SET CLOSE         DEFAULT       DEFINE
EOF           EXPORT        GLOBAL        LOCAL         NOT
RULE          RULES         SCANNER       START
.)b
The following special characters are used as operators, delimiters, or
escape characters:
.(b
.FT
=  .  ,  :  :-  "  #  +  -  *  /  |  ?  (  )  [  ]  {  }  <  >  \\
.)b
.pp
Besides keywords and the above special characters a scanner specification is
composed of characters, numbers, identifiers, strings, and actions.
.pp
A character denotes itself. Special characters have to be
escaped using a preceding escape character. The escape character is a
backslash: '\\'.
For certain non-graphic characters the same escape sequences as in C are
available:
.sp 0.5
.TS
center;
l l l.
.mc \(bv
bell    	BEL	\\a
.mc
backspace	BS	\\b
.mc \(bv
character tabulation	HT	\\t
line feed	LF	\\n
line tabulation	VT	\\v
form feed	FF	\\f
.mc
carriage return	CR	\\r
.TE
.lp
Other unprintable characters are represented by the escape character followed
either by an integer decimal number or by a hexadecimal number giving the
internal encoding. These escape sequences can be used to denote Unicode
characters whose representation can take up to 4 bytes.
.(b
.FT
;  \\+  \\\\  \\n  \\10  \\0XAC  \\0xabcd  \\uabcdef01
.)b
.pp
Numbers denote numerical integer values. They consist of a sequence of
digits.
.(b
.FT
8  12  0
.)b
.pp
Identifiers are used to refer to named entities. They consist of a letter
followed by letters, digits, or underscore characters '_'. Lower case as well
as upper case letters are possible. If an identifier is not defined its
character sequence is treated as a string. Identifiers that are keywords
have to be escaped by a preceding escape character.
.(b
.FT
letter  HexDigit  under_score  \\BEGIN  END
.)b
.pp
Strings denote a sequence of characters. They consist of a sequence of
characters enclosed in double quotes '"'. It is not possible to include a
double quote or an newline character into a string. No escape is needed
within strings. It is a shorthand for escaping a whole sequence of
characters.
.(b
.FT
"BEGIN"  ":="  "\\"
.)b
.pp
Actions are statements to be copied unchanged into the generated code.
The statements have to be written in the desired target language.
The actions have to be enclosed in braces '{' '}'.
The characters '{' and '}' can be used within the actions as long as they are either
properly nested or contained in strings or in character constants.
Otherwise they have to be escaped by a backslash character '\\'. The escape
character '\\' has to be escaped by itself if it is used outside of strings or
character constants: '\\\\'. In general, a backslash character `\\` can be used to escape any
character outside of strings or character constants. Within those tokens the escape
conventions are disabled and the tokens are left unchanged.
There are additionally statements available to aid in scanning (see section 4.4.).
.(b
.FT
{ printf ("BEGIN recognized\\n"); }
{ return tBegin; }
{ if (level > 0) { GetWord (String); Concatenate (Word, String); } }
{ printf ("} recognized\\n"); }
.)b
.sh 2 "Regular Expressions"
.pp
In general the specification of a scanner consists of the keyword RULE or RULES
followed by a list of regular expressions each one associated with an
action.
.(b
.FT
RULE
BEGIN   : { printf ("BEGIN recognized"); }
END     : { printf ("END   recognized"); }
;       : { printf (";     recognized"); }
.)b
The scanner generated from the above example specification would print an
appropriate message upon finding one of the character
sequences 'BEGIN', 'END', or ';' in the input whenever they appear.
We say a character sequence and a regular expression match if the character
sequence has a structure according to the regular expression.
.pp
In general the input of the scanner is searched for character sequences
which match one of the specified regular expressions and the associated
action is executed. Input characters which are not matched by any regular
expression are copied by default to standard output.
.pp
The syntax to write regular expressions is as follows (see Appendix 1 for a
complete definition of the syntax). The productions are given in increasing
precedence:
.(b
.FT
Reg_Expr: Reg_Expr '|' Reg_Expr
        | Reg_Expr Reg_Expr
        | Reg_Expr '+'
        | Reg_Expr '*'
        | Reg_Expr '?'
        | Reg_Expr '[' Number ']'
        | Reg_Expr '[' Number '-' Number ']'
        | '(' Reg_Expr ')'
        | Character_Set
        | Character
        | Identifier
        | String
        .
.)b
.ip -
A character is matched by a single identical character.
.(b
.FT
.ta 4c
a	matches the character 'a'
\\t	matches a tab character
\\n	matches a newline character
\\10	matches a newline character (only if ASCII is used)
\\\\	matches the character '\\'
\\0xabcd	matches a Unicode character
\\uabcdef01	matches a Unicode character
.)b
.ip -
A string is matched by a character sequence identical to the characters that
make up the string.
.(b
.FT
.ta 4c
":="	matches the character sequence ':='
"\\"	matches the character '\\'
.)b
.ip -
An identifier may be defined to refer to a regular expression. In this case
it matches the same characters as the regular expression. An undefined
identifier is treated like a string, it matches its own character sequence.
.(b
.FT
.ta 4c
END	matches the character sequence 'END'
\\NOT	matches the character sequence 'NOT'
.)b
.ip -
A number is treated like a string, it matches its own character sequence.
.(b
.FT
.ta 4c
007	matches the character sequence '007'
.)b
.ip -
A character set matches one arbitrary character contained in the set.
It is written as a sequence of characters enclosed in braces. Ranges may be
used to include intervals of characters. The same escapes as described for
characters may be used. Unprintable characters and the
following ones have to be escaped within character sets:
.(b
.FT
 '-'  '}'  ' '  '\\'
.)b
The predefined identifier ANY stands for a character set containing every
character except the newline character.
If a character set is preceded by the operator '\-' it matches one arbitrary
character except the ones contained in the set.
.(b
.FT
.ta 4c
{ +\\-*/ }	matches the arithmetic operators + - * /
{ A-Z a-z 0-9 }	matches all letters and digits
{ \\0xabcd-\\uabcdef01 }	matches a set of Unicode characters
- { }	matches all characters
- { \\n }	matches all characters except the newline character
ANY	matches all characters except the newline character
.)b
.ip -
Two regular expressions separated by the operator '|' match characters that
are matched by the first or by the second regular expressions.
.(b
.FT
.ta 4c
a | b	matches the characters 'a' or 'b'
.)b
.ip -
Two regular expressions following each other with no operator in between
match the concatenation of character sequences matched by the single regular
expressions.
.(b
.FT
.ta 4c
a b	matches the character sequence 'ab'
.)b
.ip -
The operator '?' matches a character sequence matched by
the preceding regular expression or the empty character sequence.
In other words, the specified characters are optional.
.(b
.FT
.ta 4c
a b ?	matches the character sequences 'a' and 'ab'
.)b
.ip -
The operator '+' matches a character sequence which can be matched by the
repetition of the preceding regular expression 1 or more times.
.(b
.FT
.ta 4c
a +	matches the character sequences 'a', 'aa', 'aaa', ...
.)b
.ip -
The operator '*' matches a character sequence which can be matched by the
repetition of the preceding regular expression zero or more times.
.(b
.FT
.ta 4c
a b *	matches the character sequences 'a', 'ab', 'abb',
	'abbb', ...
.)b
.ip -
A regular expression followed by a number in brackets matches
a character sequence which can be matched by the
repetition of the preceding regular expression exactly the times
specified by the number.
.(b
.FT
.ta 4c
a [4]	matches the character sequence 'aaaa'
.)b
.ip -
A regular expression followed by a range in brackets matches
a character sequence which can be matched by the
repetition of the preceding regular expression a number of times lying in
between of the two given numbers.
.(b
.FT
.ta 4c
a [2-4]	matches the character sequences 'aa', 'aaa', and 'aaaa'
.)b
.ip -
Parentheses '(' ')' can be used for grouping in more complex regular
expressions.
.(b
.FT
.ta 4c
(a | b+)? (c d)*	matches strings like 'acdcd', 'cdcdcd', 'bcd', or 'bbb';
	but not 'ab', 'abb', or 'abcd'.
.)b
.pp
A complete regular expression which is not part of any other regular
expression is called a pattern. A pattern is matched exactly in the same way
as regular expressions. It can be augmented by the following
specifications.
.ip -
A pattern preceded by the operator '<' matches a character sequence only
if it appears at the beginning of a line.
.(b
.FT
.ta 4c
< {a-z} +	matches identifiers only at the beginning of lines
.)b
.ip -
A pattern followed by the operator '>' matches a character sequence only
if it appears at the end of a line.
.(b
.FT
.ta 4c
" " + >	matches trailing spaces
< C ANY * >	matches FORTRAN comment lines
.)b
.ip -
A pattern followed by the operator '/' and a regular expression matches
a character sequence only if it is followed by a character sequence that is
matched by the regular expression behind the operator '/'.
.(b
.FT
.ta 4c
{0-9} + / ".."	matches numbers, but only if followed by two dots
.)b
.ip -
Several patterns that share a common action can be given in a comma
separated list, thus the action has to be specified only once.
.(b
.FT
.ta 4c
 ' - {\\n'} * ', \\" - {\\n"} * \\"
	matches both possible forms of Modula-2 strings
.)b
.sh 2 "Ambiguous Specifications"
.pp
Rex can handle ambiguous specifications. When more than one expression can
match the current input, Rex chooses as follows:
.ip -
The longest match is preferred.
.ip -
Among rules which match the same number of characters, the rule given first
is preferred.
.pp
The length of a match is the number of matched characters plus the number of
characters matched by the regular expression following the "right context"
operator '/' if applicable.
.(b
Example:
.sp 0.5
.FT
{0-9} +             : { return tDecimal; }
{0-9} + / ".."      : { return tDecimal; }
{0-9} + "." {0-9} * : { return tReal   ; }
".."                : { return tRange  ; }
"."                 : { return tDot    ; }
.)b
.pp
Suppose the right context of the first rule above is missing. The input
.(b
.FT
1..
.)b
would be recognized as tReal and tDot because tReal matches two
characters. To get the right solution the right context is necessary. Now
the input is recognized as tDecimal and tRange because the second rule for
tDecimal matches 3 characters.
.(b
Example:
.sp 0.5
.FT
BEGIN   : { return tBegin; }
END     : { return tEnd  ; }
{A-Z} + : { return tIdent; }
.)b
.pp
The rules for keywords should be given before the rule for identifiers.
Otherwise the keywords would be recognized as identifiers.
.pp
An analysis that checks a scanner specification for ambiguous rules can
be requested with option -p. The result of this analysis is a list of pairs of
patterns that are ambiguous with respect to each other.
.sh 2 "Definitions"
.pp
Regular expressions can be given names. This serves to avoid duplication of
regular expressions or to increase the expressive power of a specification.
After the keyword DEFINE a list of identifiers can be associated with
regular expressions. Defined identifiers appearing within regular
expressions are replaced by the regular expression given in the definition.
Identifiers have to be declared before use.
Undefined identifiers are treated as strings, by default and reported as errors
when option -x is set.
The identifier ANY is predefined to match any character except newline.
.(b
Example:
.sp 0.5
.FT
letter           = { A-Z a-z } .
digit            = { 0-9 }     .
string_character = - { " \\n }  .
ANY              = - { \\n }    .
.)b
.sh 2 "Start States"
.pp
For complex tasks Rex offers a facility called "start states". Usually the
generated scanner is always in the standard state called STD and all
specified patterns are recognized. In general the scanner is allowed to
change its state between an arbitrary number of user defined states. The
patterns can be specified to be recognized only in certain states.
Initially the scanner is in the standard start state STD.
There are special statements to change the state of the scanner (see section 4.4.).
They can be used in the actions of the rules.
.pp
.mc \(bv
Two kinds of start states are distinguished: "inclusive" start states and
"exclusive" start states. This distinction is relevant for patterns given
without start states.
.pp
.mc
Start states have to be defined by giving a list of identifiers after the
.mc \(bv
keyword START. Two groups of identifiers can be separated by the character '-'.
The identifiers in the first group are treated as inclusive start states
while the identifiers in the second group are treated as exclusive start states.
The identifiers in every group may be separated by commas.
The standard state STD is predefined as an inclusive start state.
.br
.mc
.ip -
.mc \(bv
A pattern given without start states
is recognized when the scanner is in any inclusive start state.
The exclusive start states are not considered.
.br
.mc
.ip -
.mc \(bv
A pattern preceded by the characters '#*#'
is recognized when the scanner is in any start state.
Both, inclusive and exclusive start states are considered.
.mc
.ip -
.mc \(bv
A pattern preceded by a list of start states (enclosed in '#' characters)
.mc
is recognized only if the scanner is in one of the listed start states.
Again the listed start states may be separated by commas.
.ip -
A pattern preceded by the keyword NOT and a list of start states
(enclosed in '#' characters)
is recognized only if the scanner is in a start state not listed.
.mc \(bv
Instead of the keyword NOT the character '-' can be used as well.
.mc
.lp
.(b
Example:
.sp 0.5
.FT
START comment
RULE
           "(*"         : {++ level; yyStart (comment);}
#comment#  "*)"         : {-- level; if (level == 0) yyStart (STD);}
#comment#  "(" | "*" | - {*(} + : {}
#STD#      {0-9} +      : {return tNumber;}
.)b
.pp
The above example shows how to handle nested comments in a Modula-2 scanner.
.mc \(bv
The rule for opening comment brackets is recognized in all inclusive start
states. The nesting level is increased and we change the start state to the
inclusive start state
.mc
.i comment
with the
predefined statement yyStart. Closing comment brackets are recognized only
if the scanner is in start state
.i comment.
Upon their recognition the nesting
level is decreased. Should the nesting level reach zero the comment is
finished and we change the state back to STD using yyStart again. While the
scanner is in start state
.i comment
everything except opening and closing
comment brackets is skipped by specifying an empty action. The last rule
specifying the structure of decimal numbers is recognized only in the start
state STD.
.pp
The problem of how to declare the variable for counting the nesting level of
comments is solved in section 3.7.
.mc \(bv
.lp
.br
.mc
.(b
.mc \(bv
Example:
.sp 0.5
.FT
START S - T U
RULE
	A : {}
#*#	B : {}
#STD#	C : {}
#S#	D : {}
#T#	E : {}
#S, T#	F : {}
-#S, T#	G : {}
NOT #U#	H : {}
.br
.mc
.)b
.mc \(bv
.pp
This example declares one inclusive start state S and two exclusive start
states T and U. The following table gives for every rule the set of start
states where the rule is active.
.br
.mc
.(b
.mc \(bv
.sp 0.5
.ce
Table: Start States
.sp 0.5
.TS
center;
l l l.
Rule	Start States
_
A	STD, S
B	STD, S, T, U
C	STD
D	S
E	T
F	S, T
G	STD, U
H	STD, S, T
.TE
.br
.mc
.)b
.mc \(bv
.mc
.sh 2 "Scanner Name"
.pp
A specification may be optionally headed by a name for the scanner to be generated:
.(b
Example:
.sp 0.5
.FT
SCANNER lexer
.)b
The identifier is used to derive the names of the scanner and source modules and,
if the target language requires it, a
prefix for the objects exported by the scanner. If the name is missing it defaults to
.i Scanner .
In the following we refer to this name by <Scanner>. The prefixes <Scanner> and
<Scanner>_ are generated only if this clause is present. Otherwise they are omitted
in order to be compatible with former versions of Rex.
.pp
If the target language is Java, this name may include a package name:
.(b
Example:
.sp 0.5
.FT
SCANNER mydomain.mypackage.Lexer
.)b
Here the scanner name is
.i Lexer
and the generated class will include a package declaration placing it in
.i mydomain.mypackage .
.sh 2 "Target Code"
.pp
The actions associated with regular expressions may need variables or in
general arbitrary declarations to perform their task.
A scanner specification may be
preceded by several kinds of sections written in the target language.
The syntax rules for actions apply to these sections, too.
These sections are copied unchanged and unchecked to the generated scanner
at the following places:
.ip -
The IMPORT section is used to declare use of other modules by the scanner.
.br
For Ada, target code after the keyword IMPORT is included in the specification
part of the generated scanner before the package header.
It can be used to introduce WITH and USE clauses.
.br
For Java, target code after the keyword IMPORT is included at the head of the
class file (after the package declaration if there is one). It may be used to
add
.i import
statements.
.br
For other languages an IMPORT section is treated like an EXPORT section.
.ip -
Target code after the keyword EXPORT is included in the specification part
(definition module) of the generated scanner. It allows to extend the set of
objects exported by the scanner module.
If not given it is predefined as described below.
.ip -
Target code after the keyword GLOBAL is included in the scanner module at
level 0, that is the extent of variables given in this section is the
run time of the whole program.
If not given it is predefined as described below.
.ip -
Target code after the keyword LOCAL is included in the scanner routine
called <Scanner>_GetToken (at level 1), that is the extent of variables given
in this section is one invocation of this routine.
.ip -
Target code after the keyword BEGIN is included in the routine
<Scanner>_BeginScanner which may be called in order to initialize the data structures declared
in the sections EXPORT and GLOBAL.
.ip -
Target code after the keyword CLOSE is included in the routine
<Scanner>_CloseScanner which may be called after scanning is finished. This statements
can be used to finalize the data structures declared in the sections EXPORT
and GLOBAL.
.ip -
Target code after the keyword DEFAULT is included in the scanner routine
to be executed whenever a character is not matched by one of the regular
expressions. It can be used to detect illegal characters for example.
If not given it is predefined as described below.
.ip -
Target code after the keyword EOF is included in the scanner routine
to be executed upon reaching the end of the input. It can be used to return
a value different from the predefined one (<Scanner>_EofToken = 0) or to check for
unclosed comments or strings for example.
.pp
If the IMPORT, EXPORT, GLOBAL, or DEFAULT sections are not used then the following
predefined declarations are included:
.(b
If the target language is C:
.sp 0.5
.FT
EXPORT {
# include "Position.h"
typedef struct { tPosition Position; } <Scanner>_tScanAttribute;
extern void <Scanner>_ErrorAttribute (int Token,
                                      <Scanner>_tScanAttribute * Attribute);
}
.sp 0.5
GLOBAL {
void <Scanner>_ErrorAttribute (Token, Attribute)
   int Token;
   <Scanner>_tScanAttribute * Attribute;
   { }
}
.sp 0.5
DEFAULT {
   yyEcho;
}
.)b
.(b
If the target language is C++:
.sp 0.5
.FT
EXPORT {
# include "Position.h"
.sp 0.5
typedef struct { tPosition Position; } <Scanner>_tScanAttribute;
}
.sp 0.5
GLOBAL {
void <Scanner>::ErrorAttribute (int Token, <Scanner>_tScanAttribute * Attribute)
   { }
}
.sp 0.5
DEFAULT {
   yyEcho;
}
.)b
.(b
If the target language is Modula-2:
.sp 0.5
.FT
EXPORT {
IMPORT Position;
TYPE tScanAttribute = RECORD Position: Position.tPosition; END;
PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
}
.sp 0.5
GLOBAL {
PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
   BEGIN
   END ErrorAttribute;
}
.sp 0.5
DEFAULT {
   yyEcho;
}
.)b
.(b
If the target language is Ada:
.sp 0.5
.FT
EXPORT {
type tScanAttribute is record Position: tPosition; end record;
procedure ErrorAttribute (Token: Integer; Attribute: out tScanAttribute);
}
.sp 0.5
GLOBAL {
procedure ErrorAttribute (Token: Integer; Attribute: out tScanAttribute) is
   begin
      null;
   end ErrorAttribute;
}
.sp 0.5
DEFAULT {
Text_Io.Put (Text_Io.Standard_Output, yyChBufferPtr (yyChBufferIndex-1));
}
.)b
.(b
If the target language is Eiffel:
.sp 0.5
.FT
GLOBAL {
ErrorAttribute (Token: INTEGER): ScanAttribute is
   do
      Result := Attribute;
   end;
}
.sp 0.5
DEFAULT {
   yyEcho;
}
.)b
.(b
If the target language is Java:
.sp 0.5
.FT
IMPORT {
import de.cocolab.reuse.*;
}
.sp 0.5
EXPORT {
    class ScanAttribute extends Position {
        public ScanAttribute (int line, int column) {
            super (line, column);
        }
.sp 0.5
        public ScanAttribute (Position other) {
            super (other.line, other.column);
        }
    }
.sp 0.5
    public ScanAttribute errorAttribute (int token) {
        return new ScanAttribute (Position.NoPosition);
    }
}
.sp 0.5
DEFAULT {
    yyEcho ();
}
.)b
.pp
These sections import the type tPosition from a module named Position and they
declare the type <Scanner>_tScanAttribute as well as the procedure
<Scanner>_ErrorAttribute. These items are needed in combination with parser generators.
A variable called <Scanner>_Attribute of type <Scanner>_tScanAttribute is used to
communicate additional properties of the tokens from the scanner to the parser.
The type <Scanner>_tScanAttribute has to be a struct (record) type with at least one member
(field) called Position of type tPosition. tPosition has to be a struct (record)
type with at least two members (fields) called Line and Column (see section 3.8.). It can
be imported from the predefined module Position or from a user modified version of it.
.pp
During automatic error repair a parser may insert tokens. In this case the parser
calls the procedure <Scanner>_ErrorAttribute in order to ask for the additional properties of
an inserted token which is given by the parameter Token. The types tPosition and
<Scanner>_tScanAttribute are predefined as given above and the procedure
<Scanner>_ErrorAttribute is empty. If only one of the sections IMPORT, EXPORT,
or GLOBAL
is used, it has to contain declarations consistent with the remaining predefined ones.
.sh 2 "Source Position"
.pp
The generated scanners automatically compute the line and column position of
every token. This position can be accessed via the fields Position.Line and
Position.Column of the global variable <Scanner>_Attribute as described in the
section about the Scanner Interface.
The source position is computed automatically if the action of a rule is preceded by
a colon like in all the examples so far. However, if the character '-' is appended to
the colon, the calculation of the source position can be disabled for a rule.
.pp
There are mainly two reasons for not to compute the position. First, some
"compound" tokens have to be recognized by the combination of several rules
(usually in connection with a start state). In order to get the correct
position, which is the position yielded by the first rule, the calculation
of the position has to be disabled for the following rules.
.(b
Example (Pascal strings):
.sp 0.5
.FT
START string
RULE
#STD#    '              :  {yyStart (string);}
#string# - {'\\t\\n} +    :- {}
#string# ''             :- {}
#string# '              :- {yyStart (STD); return tString;}
.)b
.pp
Second, there is no need to calculate the source position in rules that skip
input characters without returning a token. In this case disabling the
computation of the position yields an increase in run time efficiency. The typical
examples are comments. The example given in the chapter about Start States
should be rewritten as follows:
.(b
Example (Modula-2 comments):
.sp 0.5
.FT
START comment
RULE
           "(*"         :- {++ level; yyStart (comment);}
#comment#  "*)"         :- {-- level; if (level == 0) yyStart (STD);}
#comment#  "(" | "*" | - {*(\\t\\n} + :- {}
.)b
.pp
The automatic computation of the line and column position for every token is the
default behaviour of a generated scanner. This mechanism can be changed.
It is implemented using three
.i cpp
macros which are predefined as follows:
.(b
If the target language is C:
.sp 0.5
.FT
# define yyColumn(Ptr) ((int) ((Ptr) - (char *) yyLineStart))
# define yyOffset(Ptr) (yyFileOffset + ((Ptr) - yyChBufferStart2))
# define yySetPosition <Scanner>_Attribute.Position.Line = yyLineCount; \\
         <Scanner>_Attribute.Position.Column = yyColumn (<Scanner>_TokenPtr);
.)b
.(b
If the target language is C++:
.sp 0.5
.FT
# define yyColumn(Ptr) ((int) ((Ptr) - (char *) yyLineStart))
# define yyOffset(Ptr) (yyFileOffset + ((Ptr) - (char *) yyChBufferStart))
# define yySetPosition Attribute.Position.Line   = yyLineCount; \\
                       Attribute.Position.Column = yyColumn (TokenPtr);
.)b
.(b
If the target language is Modula-2:
.sp 0.5
.FT
# define yyColumn(Index) ((Index) - yyLineStart)
# define yyOffset(Index) (yyFileOffset + ((Index) - yyChBufferStart))
# define yySetPosition Attribute.Position.Line   := yyLineCount; \\
                       Attribute.Position.Column := yyColumn (TokenIndex);
.)b
.(b
If the target language is Ada:
.sp 0.5
.FT
# define yyColumn(Index) ((Index) - yyLineStart)
# define yyOffset(Index) (yyFileOffset + ((Index) - yyChBufferStart))
# define yySetPosition Attribute.Position.Line   := yyLineCount; \\
                       Attribute.Position.Column := yyColumn (TokenIndex);
.)b
.(b
If the target language is Java:
.sp 0.5
.FT
# define yyColumn(Index) ((Index) - yyLineStart)
# define yyOffset(Index) (yyFileOffset + ((Index) - yyChBufferStart))
# define yySetPosition \\
   attribute = new ScanAttribute (yyLineCount, tokenIndex - yyLineStart);
.)b
.pp
The macro
.i yyColumn
determines the column number for a given buffer location (TokenPtr in C and C++,
TokenIndex in Modula-2, Java, and Ada).
The macro
.i yySetPosition
is used by the generated scanner in order to assign the position data to the
variable Attribute. It can be redefined by the user in the GLOBAL section.
This allows for example for the following:
.sp 0.3
It is possible to get rid of the fields Line and Column.
.sp 0.3
The fields Line and Column can be named differently.
.sp 0.3
It is possible to implement a completely different representation for source
positions such as e. g. the absolute character offset in a file (as is used by
fseek of Unix). This is achieved by using the macro
.i yyOffset
which determines the offset value for a given buffer location.
In the following example the fields
.i Offset
and
.i End
receive the absolute character positions of the beginning and the end of a
token.
.lp
.(b
.FT
# define yySetPosition Attribute.Position.Offset = yyOffset (TokenPtr); \\
         Attribute.Position.End = yyOffset (TokenPtr + TokenLength - 1);
.)b
.sh 2 "Character Set"
.pp
Scanners generated by Rex depend on the internal representation of the character
set. The reason originates from the implementation of the finite automaton which uses
in principal a two-dimensional array that maps a state and a character to a new
state:
.(b
State := Table [State] [Character];
.)b
The internal representation of the characters is used for the array access during
run time of the scanner as well as during generation time of the table.
In order to make a scanner work, these two internal
representations have to agree. This is no problem as long as a scanner is
generated on a machine with the same encoding of characters as the machine where the
scanner is supposed to run on. For example, if both machines use ASCII everything
is fine. However, if the encoding of characters is different, then Rex has to know
about the internal representation of the character set on the target machine.
This can be done by a specification like the following:
.(b
.FT
.ta 2c 4c
CHARACTER_SET {
0	0xf0
1	0xf1
\&...
9	0xf9
A	0xc1
B	0xc2
\&..
Z	0xe9
a	0x81
b	0x82
\&...
z	0xa9
0x09	0x05	/* tab        */
\\n	0x25	/* newline    */
32	0x40	/* space      */
\\\\	0xe0	/* back slash */
{	0xc0
|	0x6a
}	0xd0
}
.)b
The curly brackets after the keyword CHARACTER_SET contain a list of pairs. A pair
describes a translation and it
consists of a character and its internal code. A character is given by a printable
character, a C escape sequence (\\n, \\t, \\v, \\b, \\r, \\f), or a number and a code
is given by a number. The numbers can be either decimal, octal, or
hexadecimal numbers. Like in C, octal numbers start with the digit '0' and
hexadecimal numbers with '0x'. While the character refers to the representation
on the host machine the code refers to the representation on the target machine.
If no translation is given for a character, then the internal representation of the
host machine will be used.
.pp
The following should be noted if a character set is specified:
The option -i might be necessary if codes greater than 127 are used.
(Option -i selects an 8 bit representation for characters.)
The action statements <Scanner>_GetLower and <Scanner>_GetUpper (see section 4.4.)
may not work because they rely on ASCII.
The operator '<' for matching the beginning of lines may cause troubles.
This feature is implemented by a test whether the character before a line is an end
of line character. The end of line character is predefined as the ASCII newline
character or whatever this character is translated to by the specification of the
character set:
.(b
.FT
# define yyEolCh        (unsigned char) '\\12'
.)b
For C and C++ scanners this definition can be overwritten by supplying an
appropriate preprocessor directive in the GLOBAL section.
.sh 1 "Predefined Items"
.pp
Rex knows several predefined items described in the next sections.
.sh 2 "Definitions"
.pp
The identifier ANY is predefined to match one arbitrary character except
newline.
.(b
.FT
DEFINE ANY = - { \\n } .
.)b
.sh 2 "Start States"
.pp
The identifier STD is predefined to denote the standard start state of Rex.
The generated scanners are initially in this state.
.(b
.FT
START STD
.)b
.sh 2 "Rules"
.pp
The 4 for rules given below are predefined after the user specified rules, by
default.
By giving own rules the user can overwrite these because of the strategy to
solve ambiguities. The predefined rules help to calculate the line and
column positions and to skip blanks efficiently.
The implicit definition of the first 3 rules can be switched off with option -v.
The fourth rule can be overwritten using the DEFAULT section.
.(b
.FT
RULE
" "     :- {}
\\t      :- {yyTab;}
\\n      :- {yyEol (0);}
ANY     :- {yyEcho;}
.)b
.sh 2 "Action Statements"
.pp
The following statements can be used within the actions associated with
regular expressions. The exact syntax varies according to the target
language, for example GetWord may be a function returning a value; see
the next section for details.
.ip "<Scanner>_GetWord (v);" 3c
This statement gives access to the matched character sequence.
.br
In C or C++ the sequence is returned in the variable v which must be of type
char v [ ] or wchar_t v [ ].
Additionally the length of the sequence is returned as result of the function.
.br
In Modula-2 the sequence is returned in the variable v which must be of type
Strings.tString.
.ip "<Scanner>_GetLower (v);" 3c
Like <Scanner>_GetWord, except that every letter is normalized to lower case.
.ip "<Scanner>_GetUpper (v);" 3c
Like <Scanner>_GetWord, except that every letter is normalized to upper case.
.ip yyEcho; 3c
The matched character sequence is printed on standard output.
.ip "yyLess (n);" 3c
The matched character sequence is truncated to the first n characters.
The other characters are rescanned for the next character sequence.
.ip "yyStart (s);" 3c
The start state is changed to state s.
.ip "yyPush (s);" 3c
The current start state is pushed on a stack and the start state is changed to
state s;
.ip "yyPop ();" 3c
The start state is changed to the state popped from a stack.
.ip yyPrevious; 3c
.nh
The start state is changed to the state valid before the last execution of
yyStart, yyPush, yyPop, or yyPrevious.
.hy
.ip yyStartState 3c
This is not a statement but an expression of type short or SHORTCARD, respectively,
whose value is the current start
state. It can be used to execute different statements in one action
depending on the current start state.
.ip yyTab; 3c
This statement should be used if a regular expression is specified by the
user to process tab characters. Its purpose is to update the internal
variable to calculate the column position of tokens. yyTab works only if the
tab character exclusively is specified by a rule.
.ip "yyTab1 (a);" 3c
Like yyTab
this statement should be used if a regular expression is specified by the
user to process tab characters. Its purpose is to update the internal
variable to calculate the column position of tokens. yyTab1 works if the
tab character is embedded in other characters. The parameter a must
specify the number of characters before the tab character.
.ip "yyEol (n);" 3c
This statement should be used if a regular expression is specified by the
user to process newline characters. Its purpose is to update the internal
variables to calculate the line and column position of tokens.
yyEol should be executed once for every newline character matched.
The parameter n should specify the number of characters matched after the
last newline character. In simple cases where the pattern consists only of a
newline character one invocation of yyEol (0); is sufficient.
.ip "input ();" 3c
This is a function call returning the next character from the input. It
is used where regular expressions alone are not able to describe the input
language, for example Fortran style constants.
.ip "unput (c);" 3c
This pushes the character c back into the input, to be considered when
scanning for the next token.
.\" It is used in conjunction with input.
.sh 1 "Interface of the Generated Scanners"
.pp
The scanners generated by Rex offer an interface to be used by a main
program like e. g. a parser and they require a source module
for blocked input of characters to obey a certain interface.
The structure of these two interfaces is independent from a specific target language.
The interfaces are discussed in language specific chapters because
the syntactic details vary from one target language to another.
.sh 2 "C"
.pp
The option -c selects the generation of a scanner in C that can be translated by
compilers for ANSI-C, K&R-C, or C++.
This is accomplished by appropriate preprocessor directives.
It has been already mentioned that the prefixes <Scanner> and
<Scanner>_ are generated only if the keyword SCANNER is present.
Otherwise they are omitted in order to be compatible with former versions of Rex.
.sh 3 "Scanner Interface"
.pp
The scanner interface consists of two parts: While the objects specified in the
external interface can be used from outside the scanner, the objects of the
internal interface can be used only within a scanner description. The external
scanner interface in the file <Scanner>.h has the following contents:
.(b
.FT
# include "Position.h"
typedef struct { tPosition Position; } <Scanner>_tScanAttribute;
extern  void <Scanner>_ErrorAttribute (int Token,
                                       <Scanner>_tScanAttribute * Attribute);
.sp 0.5
# define          <Scanner>_EofToken        0
# define          <Scanner>_xxMaxCharacter  255
.sp 0.5
# if xxMaxCharacter < 256
#  define         <Scanner>_xxtChar         char
# else
#  define         <Scanner>_xxtChar         wchar_t
# endif
.sp 0.5
extern  <Scanner>_xxtChar * <Scanner>_TokenPtr;
extern  int       <Scanner>_TokenLength     ;
extern  <Scanner>_tScanAttribute <Scanner>_Attribute;
extern  void   (* <Scanner>_Exit) (void)    ;
.sp 0.5
extern  void      <Scanner>_BeginScanner    (void);
extern  void      <Scanner>_BeginFile       (char * FileName);
extern  void      <Scanner>_BeginFileW      (wchar_t * FileName);
extern  void      <Scanner>_BeginMemory     (void * InputPtr);
extern  void      <Scanner>_BeginMemoryN    (void * InputPtr, int Length);
extern  void      <Scanner>_BeginGeneric    (void * InputPtr);
extern  int       <Scanner>_GetToken        (void);
extern  int       <Scanner>_GetWord         (<Scanner>_xxtChar * Word);
extern  int       <Scanner>_GetLower        (<Scanner>_xxtChar * Word);
extern  int       <Scanner>_GetUpper        (<Scanner>_xxtChar * Word);
extern  void      <Scanner>_CloseFile       (void);
extern  void      <Scanner>_CloseScanner    (void);
extern  void      <Scanner>_ResetScanner    (void);
.)b
.ip -
The procedure <Scanner>_GetToken is the central scanning routine.
It returns the next token found in the input or whatever is specified
in the actions associated with the regular expressions.
.ip -
The procedure <Scanner>_BeginFile may be called in order to open an input file
or a nested include file.
It has one parameter of type 'char *' (string) which specifies the file name.
The value NULL indicates input from standard input.
If not called input is read from standard input.
Include files may be nested to arbitrary depth.
.ip -
The procedure <Scanner>_BeginFileW does the same as <Scanner>_BeginFile for file
names given by wide character strings.
.ip -
The procedure <Scanner>_BeginMemory may be called in order to indicate that
input should be read from the null terminated string of input items at location
InputPtr. The input string may not contain null characters. The contents of the
string may not be changed until it has been processed completely.
.ip -
The procedure <Scanner>_BeginMemoryN may be called in order to indicate that
that the input should be Length input items at location InputPtr.
The input may contain null characters. The contents of the
input may not be changed until it has been processed completely.
.ip -
The procedure <Scanner>_BeginGeneric may be called in order to indicate that
the input is user-defined at location InputPtr.
The source module (see below) has to be extended by the user in order to
implement this feature.
.ip -
The procedure <Scanner>_CloseFile may be called in order to close the current
input stream (before reaching end of file or end of input).
<Scanner>_CloseFile is called automatically by the
scanner upon reaching end of file or end of input.
.ip -
The procedure <Scanner>_BeginScanner may be called in order to initialize
user data. The contents of the target code section named BEGIN is included
in the body of this procedure.
.ip -
The procedure <Scanner>_CloseScanner may be called in order to finalize
user data. The contents of the target code section named CLOSE is included
in the body of this procedure.
.ip -
If the scanner reaches the end of the input it returns the special token
called <Scanner>_EofToken which is encoded by 0.
.ip -
The preprocessor symbol <Scanner>_xxMaxCharacter is used to describe the
range of the character set.
.ip -
The preprocessor symbol <Scanner>_xxtChar is defined to be either char or
wchar_t. It describes the type used as representation of a character.
Note, the size of wchar_t can be 2 or 4 bytes, depending on the compiler.
.ip -
The procedures <Scanner>_GetWord, <Scanner>_GetLower, and <Scanner>_GetUpper
allow access to the matched character sequence as described in section 4.4.
.ip -
Alternatively, the matched character sequence can be accessed using the variables
<Scanner>_TokenPtr and <Scanner>_TokenLength.
<Scanner>_TokenPtr points to the beginning of the matched character
sequence. <Scanner>_TokenLength specifies the number of matched characters.
Note, the matched character sequence is not terminated by a '\\0' character.
.ip -
The variable <Scanner>_Attribute is supposed to communicate additional properties of
the current token. The value must be provided by appropriate action statements.
This variable is of type <Scanner>_tScanAttribute which has to be a struct type with
at least one member called Position of type tPosition. tPosition has to be a struct
type with at least two members called Line and Column. The values of Line and
Column are computed by the scanner, automatically. They indicate the source
position of the current token. The position of a token is the position of the
first character of the token. For exceptions see section 3.8.
The types <Scanner>_tScanAttribute and tPosition are predefined as given above.
The definitions of these types can be changed as described in section 3.7.
.ip -
During automatic error repair a parser may insert tokens. In this case the
parser calls the procedure <Scanner>_ErrorAttribute in order to ask for the additional
properties of an inserted token which is given by the parameter Token.
The procedure should return in the second argument called Attribute a
default value for the additional properties of the token Token.
.ip -
The variable <Scanner>_Exit refers to a procedure which is called upon an internal
error in the scanner. The default procedure terminates the program execution. The
variable can be changed in order to achieve a different behaviour.
.lp
The internal scanner interface consists of the following objects:
.ip -
The initial size of the scanner input buffer is defined by the value of the
preprocessor symbol yyInitBufferSize with a default of 8448. The buffer size is
increased automatically when necessary. The initial buffer size can be changed
by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyInitBufferSize 562
.)b
For best results, the value should be a power of two plus a constant between 50
and 256.
.ip -
The initial size of the stack for include files is defined by the value of the
preprocessor symbol yyInitFileStackSize with a default of 8. The stack size is
increased automatically when necessary. The initial stack size can be changed
by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyInitFileStackSize 16
.)b
.ip -
The value for tab stops is defined by the preprocessor symbol yyTabSpace with
a default of 8. This value can be changed
by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyTabSpace 4
.)b
.sh 3 "Source Interface"
.pp
The scanners generated by Rex need a source module that provides blocked input
of characters. Rex can provide a prototype source module which can read
from standard input, from any file, or from memory. It is contained in the
files <Scanner>Source.h and <Scanner>Source.c.
The specification file <Scanner>Source.h consists of something like:
.(b
.FT
extern void <Scanner>_SetEncoding        (int Encoding, int Endian);
extern int  <Scanner>_BeginSourceFile    (char * FileName);
extern int  <Scanner>_BeginSourceFileW   (wchar_t * FileName);
extern void <Scanner>_BeginSourceMemory  (void * InputPtr);
extern void <Scanner>_BeginSourceMemoryN (void * InputPtr, int Length);
extern void <Scanner>_BeginSourceGeneric (void * InputPtr);
extern int  <Scanner>_GetLine            (int File, char * Buffer, int Size);
extern int  <Scanner>_GetWLine           (int File, wchar_t * Buffer, int Size);
extern void <Scanner>_CloseSource        (int File);
.)b
.ip -
<Scanner>_BeginSourceFile is called from the scanner function <Scanner>_BeginFile
indicating that input should be read from a file. The file specified
by the parameter FileName is opened and used as input file.
If not called input is read from standard input. The function
should return an integer file descriptor as provided by the system
call open or any other handle understood by the function <Scanner>_GetLine.
.ip -
<Scanner>_BeginSourceFileW is called from the scanner function
<Scanner>_BeginFileW.
It does the same as <Scanner>_BeginSourceFile for file
names given by wide character strings.
The source module has to be extended by the user in order to
implement this feature.
.ip -
<Scanner>_BeginSourceMemory is called from the scanner function <Scanner>_BeginMemory
indicating that input should be read from the null terminated string
of input items at location InputPtr.
The input string may not contain null characters. The contents of the
string may not be changed until it has been processed completely.
.ip -
<Scanner>_BeginSourceMemoryN is called from the scanner function <Scanner>_BeginMemoryN
indicating that the input should be Length input items at location
InputPtr. The input may contain null characters. The contents of the
input may not be changed until it has been processed completely.
.ip -
<Scanner>_BeginSourceGeneric is called from the scanner function <Scanner>_BeginGeneric
indicating that the input is user-defined at location InputPtr.
The source module has to be extended by the user in order to
implement this feature.
.ip -
<Scanner>_GetLine is called from the scanner in order to fill a buffer at
address Buffer with a block of maximal Size characters. Input
should be read from a file specified by the integer file descriptor
File if the current input stream comes from a file. Otherwise input
comes from memory and the parameter File can be ignored.
Lines are terminated by newline characters (ASCII = 0xa).
The function returns the number of characters transferred.
Reasonable block sizes are between 128 and 8192 or the length of a line.
Smaller block sizes - especially block size 1 - will drastically
slow down the scanner.  The end of file or end of input is indicated
by a return value <= 0.
.ip -
<Scanner>_GetWLine is the
same as <Scanner>_GetLine for type wchar_t instead of type char.
.ip -
<Scanner>_CloseSource is called from the scanner function <Scanner>_CloseFile
at end of file or at end of input, respectively.
It can be used to close files.
The functions <Scanner>_BeginSource... and <Scanner>_CloseSource can be called
in a nested way, for example in order to handle include files.
The encoding and the endian property of the input stream are stacked.
Therefore after a call of <Scanner>_CloseSource the properties of the
previous input stream are restored.
.ip -
The function <Scanner>_SetEncoding can be called by the user in order to
specify the encoding and the endian property of the input stream.
The arguments have to be values as defined below.
This function has to be called after the function <Scanner>_BeginSource... .
If neither little-endian nor big-endian is specified then the endian
property of the current system is assumed to hold for the input.
The function <Scanner>_GetWLine will convert the input stream to a stream
of type wchar_t.
.sp 0.5
The following constants describe the encoding of the input stream:
.(b
.FT
# define CODE_NONE      0
# define CODE_BYTE      1       /* 1 byte         */
# define CODE_WCHAR_T   2       /* 2 or 4 bytes   */
# define CODE_UCS2      3       /* 2 bytes        */
# define CODE_UCS4      4       /* 4 bytes        */
# define CODE_UTF8      5       /* seq of 1 byte  */
# define CODE_UTF16     6       /* seq of 2 bytes */
.)b
The above comments give the size of an input stream item in bytes.
All input stream items (or sequences of input stream items in the cases
of UTF8 and UTF16) represent Unicode characters.
The encodings BYTE, UCS2, and UTF16, and possibly WCHAR_T can represent
subsets of the full Unicode character set, only.
A Unicode character will be stored in variables of type wchar_t.
Note, the size of wchar_t can be 2 or 4 bytes, depending on the compiler.
Therefore, if the size of wchar_t is 2 then characters encoded by UCS4,
UTF8, and UTF16 will be truncated to two bytes.
.sp 0.5
The following constants describe the endian property of the input stream:
.(b
.FT
# define ENDIAN_NONE    0       /* no endian property specified         */
# define ENDIAN_LITTLE  1       /* little-endian                        */
# define ENDIAN_BIG     2       /* big-endian                           */
.)b
.sh 3 "Scanner Driver"
.pp
A main program is necessary for the test of a generated scanner.
Rex can provide a minimal main program in the file <Scanner>Drv.c which can serve
as test driver. It counts the tokens and looks like the following:
.(b
.FT
# include "Position.h"
# include "<Scanner>.h"
.sp 0.5
int main (void)
{
   int Token, Count = 0;
   char Word [2048];
.sp 0.5
   <Scanner>_BeginScanner ();
   do {
      Token = <Scanner>_GetToken ();
      Count ++;
# ifdef Debug
      if (Token != <Scanner>_EofToken) <Scanner>_GetWord (Word);
      else Word [0] = '\\0';
      WritePosition (stdout, <Scanner>_Attribute.Position);
      printf ("%5d %s\\n", Token, Word);
# endif
   } while (Token != <Scanner>_EofToken);
   <Scanner>_CloseScanner ();
   printf ("%d\\n", Count);
   return 0;
}
.)b
.sh 2 "C++"
.pp
.sh 3 "Scanner Interface"
.pp
The scanner interface consists of two parts: While the objects specified in the
external interface can be used from outside the scanner, the objects of the
internal interface can be used only within a scanner description. The external
scanner interface is described by a class named <Scanner>. The name <Scanner>
may be specified after the keyword SCANNER. It defaults to
.i Scanner.
The class definition is contained in a file named <Scanner>.h which has the
following contents:
.(b
.FT
# include "Position.h"
.sp 0.5
typedef struct { tPosition Position; } <Scanner>_tScanAttribute;
.sp 0.5
# define  <Scanner>_xxMaxCharacter  255
.sp 0.5
# if xxMaxCharacter < 256
#  define <Scanner>_xxtChar         char
# else
#  define <Scanner>_xxtChar         wchar_t
# endif
.sp 0.5
# define <Scanner>_BASE_CLASS
.sp 0.5
class <Scanner> <Scanner>_BASE_CLASS {
.sp 0.5
public:
# define                <Scanner>_EofToken 0
   <Scanner>_xxtChar *  TokenPtr        ;
   int                  TokenLength     ;
   <Scanner>_tScanAttribute Attribute   ;
   void                 (* Exit) (void) ;
.sp 0.5
                        <Scanner>       (void);
   void                 BeginFile       (char * FileName);
   void                 BeginFileW      (wchar_t * FileName);
   void                 BeginMemory     (void * InpuPtr);
   void                 BeginMemoryN    (void * InpuPtr, int Length);
   void                 BeginGeneric    (void * InpuPtr);
   int                  GetToken        (void);
   int                  GetWord         (<Scanner>_xxtChar * Word);
   int                  GetLower        (<Scanner>_xxtChar * Word);
   int                  GetUpper        (<Scanner>_xxtChar * Word);
   void                 CloseFile       (void);
                        ~<Scanner>      (void);
   void                 ErrorAttribute  (int Token,
                                        <Scanner>_tScanAttribute * Attribute);
   Errors *             ErrorsObj       ;
};
.)b
.ip -
The method GetToken is the central scanning routine. It returns the next
token found in the input or whatever is specified in the actions associated
with the regular expressions.
.ip -
The method BeginFile may be called in order to open an input file or a nested
include file.
It has one parameter of type 'char *' (string) which specifies the file name.
The vaue NULL indicates input from standard input.
If not called input is read from standard input.
Include files may be nested to arbitrary depth.
.ip -
The method BeginFileW does the same as BeginFile for file
names given by wide character strings.
.ip -
The method BeginMemory may be called in order to indicate that
input should be read from the null terminated string of input items at location
InputPtr. The input string may not contain null characters. The contents of the
string may not be changed until it has been processed completely.
.ip -
The method BeginMemoryN may be called in order to indicate that
that the input should be Length input items at location InputPtr.
The input may contain null characters. The contents of the
input may not be changed until it has been processed completely.
.ip -
The method BeginGeneric may be called in order to indicate that
the input is user-defined at location InputPtr.
The source module (see below) has to be extended by the user in order to
implement this feature.
.ip -
The method CloseFile may be called in order to close the current input file
(before reaching end of file or end of input).
CloseFile is called automatically by the scanner upon reaching end of file or
end of input.
.ip -
The constructor <Scanner> is called automatically in order to initialize
a scanner object. The contents of the target code section named BEGIN
is included in the body of this method.
.ip -
The destructor ~<Scanner> is called automatically in order to finalize
a scanner object. The contents of the target code section named CLOSE
is included in the body of this method.
.ip -
If the scanner reaches the end of the input it returns the special token
called <Scanner>_EofToken which is encoded by 0.
.ip -
The preprocessor symbol <Scanner>_xxMaxCharacter is used to describe the
range of the character set.
.ip -
The preprocessor symbol <Scanner>_xxtChar is defined to be either char or
wchar_t. It describes the type used as representation of a character.
Note, the size of wchar_t can be 2 or 4 bytes, depending on the compiler.
.ip -
The methods GetWord, GetLower, and GetUpper allow
access to the matched character sequence as described in section 4.4.
.ip -
Alternatively, the matched character sequence can be accessed using the member
variables TokenPtr and TokenLength.
TokenPtr points to the beginning of the matched character
sequence. TokenLength specifies the number of matched characters. Note, the
matched character sequence is not terminated by a '\\0' character.
.ip -
The member variable Attribute is supposed to communicate additional properties of
the current token. The value must be provided by appropriate action statements.
This variable is of type <Scanner>_tScanAttribute which has to be a struct type with
at least one member called Position of type tPosition. tPosition has to be a struct
type with at least two members called Line and Column. The values of Line and
Column are computed by the scanner, automatically. They indicate the source
position of the current token. The position of a token is the position of the
first character of the token. For exceptions see section 3.8.
The types <Scanner>_tScanAttribute and tPosition are predefined as given above.
The definitions of these types can be changed as described in section 3.7.
.ip -
During automatic error repair a parser may insert tokens. In this case the
parser calls the method ErrorAttribute in order to ask for the additional properties
of an inserted token which is given by the parameter Token.
The method should return in the second argument called Attribute a
default value for the additional properties of the token Token.
.ip -
The variable Exit refers to a procedure which is called upon an internal error in
the scanner. The default procedure terminates the program execution. The variable
can be changed in order to achieve a different behaviour.
.ip -
The preprocessor symbol <Scanner>_BASE_CLASS can be used to specify a base class
for the class <Scanner> using a #define directive in the EXPORT section of a
scanner description. Example:
.(b L
.FT
EXPORT {
# define Scanner_BASE_CLASS : public BaseClass
}
.)b
.lp
The internal scanner interface consists of the following objects:
.ip -
The initial size of the scanner input buffer is defined by the value of the
preprocessor symbol yyInitBufferSize with a default of 8448. The buffer size is
increased automatically when necessary. The initial buffer size can be changed
by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyInitBufferSize 562
.)b
For best results, the value should be a power of two plus a constant between 50
and 256.
.ip -
The initial size of the stack for include files is defined by the value of the
preprocessor symbol yyInitFileStackSize with a default of 8. The stack size is
increased automatically when necessary. The initial stack size can be changed
by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyInitFileStackSize 16
.)b
.ip -
The value for tab stops is defined by the preprocessor symbol yyTabSpace with
a default of 8. This value can be changed
by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyTabSpace 4
.)b
.sh 3 "Source Interface"
.pp
The scanners generated by Rex need a source module that provides blocked input
of characters. Rex can provide a prototype source module which can read
from standard input, from any file, or from memory. It is contained in the
files <Scanner>Source.h and <Scanner>Source.cxx.
The specification file <Scanner>Source.h consists of something like:
.(b
.FT
extern void <Scanner>_SetEncoding        (int Encoding, int Endian);
extern int  <Scanner>_BeginSourceFile    (char * FileName);
extern int  <Scanner>_BeginSourceFileW   (wchar_t * FileName);
extern void <Scanner>_BeginSourceMemory  (void * InputPtr);
extern void <Scanner>_BeginSourceMemoryN (void * InputPtr, int Length);
extern void <Scanner>_BeginSourceGeneric (void * InputPtr);
extern int  <Scanner>_GetLine            (int File, char * Buffer, int Size);
extern int  <Scanner>_GetWLine           (int File, wchar_t * Buffer, int Size);
extern void <Scanner>_CloseSource        (int File);
.)b
.ip -
<Scanner>_BeginSourceFile is called from the scanner method BeginFile
indicating that input should be read from a file. The file specified
by the parameter FileName is opened and used as input file.
If not called input is read from standard input. The function
should return an integer file descriptor as provided by the system
call open or any other handle understood by the function <Scanner>_GetLine.
.ip -
<Scanner>_BeginSourceFileW is called from the scanner method BeginFileW.
It does the same as <Scanner>_BeginSourceFile for file
names given by wide character strings.
The source module has to be extended by the user in order to
implement this feature.
.ip -
<Scanner>_BeginSourceMemory is called from the scanner method BeginMemory
indicating that input should be read from the null terminated string
of input items at location InputPtr.
The input string may not contain null characters. The contents of the
string may not be changed until it has been processed completely.
.ip -
<Scanner>_BeginSourceMemoryN is called from the scanner method BeginMemoryN
indicating that the input should be Length input items at location
InputPtr. The input may contain null characters. The contents of the
input may not be changed until it has been processed completely.
.ip -
<Scanner>_BeginSourceGeneric is called from the scanner method BeginGeneric
indicating that the input is user-defined at location InputPtr.
The source module has to be extended by the user in order to
implement this feature.
.ip -
<Scanner>_GetLine is called from the scanner in order to fill a buffer at
address Buffer with a block of maximal Size characters. Input
should be read from a file specified by the integer file descriptor
File if the current input stream comes from a file. Otherwise input
comes from memory and the parameter File can be ignored.
Lines are terminated by newline characters (ASCII = 0xa).
The function returns the number of characters transferred.
Reasonable block sizes are between 128 and 8192 or the length of a line.
Smaller block sizes - especially block size 1 - will drastically
slow down the scanner.  The end of file or end of input is indicated
by a return value <= 0.
.ip -
<Scanner>_GetWLine is the
same as <Scanner>_GetLine for type wchar_t instead of type char.
.ip -
<Scanner>_CloseSource is called from the scanner method CloseFile
at end of file or at end of input, respectively.
It can be used to close files.
The functions <Scanner>_BeginSource... and <Scanner>_CloseSource can be called
in a nested way, for example in order to handle include files.
The encoding and the endian property of the input stream are stacked.
Therefore after a call of <Scanner>_CloseSource the properties of the
previous input stream are restored.
.ip -
The function <Scanner>_SetEncoding can be called by the user in order to
specify the encoding and the endian property of the input stream.
The arguments have to be values as defined below.
This function has to be called after the function <Scanner>_BeginSource... .
If neither little-endian nor big-endian is specified then the endian
property of the current system is assumed to hold for the input.
The function <Scanner>_GetWLine will convert the input stream to a stream
of type wchar_t.
.sp 0.5
The following constants describe the encoding of the input stream:
.(b
.FT
# define CODE_NONE      0
# define CODE_BYTE      1       /* 1 byte         */
# define CODE_WCHAR_T   2       /* 2 or 4 bytes   */
# define CODE_UCS2      3       /* 2 bytes        */
# define CODE_UCS4      4       /* 4 bytes        */
# define CODE_UTF8      5       /* seq of 1 byte  */
# define CODE_UTF16     6       /* seq of 2 bytes */
.)b
The above comments give the size of an input stream item in bytes.
All input stream items (or sequences of input stream items in the cases
of UTF8 and UTF16) represent Unicode characters.
The encodings BYTE, UCS2, and UTF16, and possibly WCHAR_T can represent
subsets of the full Unicode character set, only.
A Unicode character will be stored in variables of type wchar_t.
Note, the size of wchar_t can be 2 or 4 bytes, depending on the compiler.
Therefore, if the size of wchar_t is 2 then characters encoded by UCS4,
UTF8, and UTF16 will be truncated to two bytes.
.sp 0.5
The following constants describe the endian property of the input stream:
.(b
.FT
# define ENDIAN_NONE    0       /* no endian property specified         */
# define ENDIAN_LITTLE  1       /* little-endian                        */
# define ENDIAN_BIG     2       /* big-endian                           */
.)b
.sh 3 "Scanner Driver"
.pp
A main program is necessary for the test of a generated scanner.
Rex can provide a minimal main program in the file <Scanner>Drv.cxx which can serve
as test driver. It counts the tokens and looks like the following:
.(b
.FT
# include <stdio.h>
# include "Position.h"
# include "<Scanner>.h"
.sp 0.5
int main (void)
{
   int Token, Count = 0;
   <Scanner> Scanner;
.sp 0.5
   do {
      Token = Scanner.GetToken ();
      Count ++;
# ifdef Debug
      char Word [2048];
      if (Token != <Scanner>_EofToken) Scanner.GetWord (Word);
      else Word [0] = '\\0';
      WritePosition (stdout, Scanner.Attribute.Position);
      printf ("%5d %s\\n", Token, Word);
# endif
   } while (Token != <Scanner>_EofToken);
   printf ("%d\\n", Count);
   return 0;
}
.)b
.sh 2 "Modula-2"
.sh 3 "Scanner Interface"
.pp
The scanners generated by Rex offer an interface given by the following
definition module named <Scanner>.md:
.(b
.FT
DEFINITION MODULE <Scanner>;
.sp 0.5
IMPORT Position, Strings;
.sp 0.5
TYPE tScanAttribute = RECORD Position: Position.tPosition; END;
PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
.sp 0.5
CONST EofToken  = 0;
.sp 0.5
VAR TokenLength : INTEGER;
VAR TokenIndex  : INTEGER;
VAR Attribute   : tScanAttribute;
VAR Exit        : PROC;
.sp 0.5
PROCEDURE BeginScanner  ;
PROCEDURE BeginFile     (FileName: ARRAY OF CHAR);
PROCEDURE GetToken      (): INTEGER;
PROCEDURE GetWord       (VAR Word: Strings.tString);
PROCEDURE GetLower      (VAR Word: Strings.tString);
PROCEDURE GetUpper      (VAR Word: Strings.tString);
PROCEDURE CloseFile     ;
PROCEDURE CloseScanner  ;
.sp 0.5
END <Scanner>.
.)b
.ip -
The procedure GetToken is the central scanning routine. It returns the next
token found in the input or whatever is specified in the actions associated
with the regular expressions.
.ip -
The procedure BeginFile may be called in order to open an input file or a nested
include file.
The parameter FileName specifies the file name.
The value "" (empty string) denotes input from standard input.
If not called input is read from standard input.
Include files up to a nesting depth of 15 can be processed.
.ip -
The procedure CloseFile may be called in order to close the current input file
(before reaching end of file).
CloseFile is called automatically by the scanner upon reaching end of file.
.ip -
The procedure BeginScanner may be called in order to initialize user data.
The contents of the target code section named BEGIN is included in the body of this
procedure.
.ip -
The procedure CloseScanner may be called in order to finalize user data.
The contents of the target code section named CLOSE is included in the body of this
procedure.
.ip -
The procedures GetWord, GetLower, and GetUpper allow access to the matched
character sequence as described in section 4.4.
.ip -
The variable TokenLength specifies the number of matched characters.
.ip -
The variable TokenIndex is an array index of the internal buffer, an array of
characters, which specifies the location where the matched character sequence
starts. It can be used as argument for the macros that compute source positions.
.ip -
The variable Attribute is supposed to communicate additional properties of
the current token. The value must be provided by appropriate action statements.
This variable is of type tScanAttribute which has to be a record type with at
least one field called Position of type tPosition. tPosition has to be a record
type with at least two fields called Line and Column. The values of Line and
Column are computed by the scanner, automatically. They indicate the source
position of the current token. The position of a token is the position of the
first character of the token. For exceptions see section 3.8.
The types tScanAttribute and tPosition are predefined as given above.
The definitions of these types can be changed as described in section 3.7.
.ip -
During automatic error repair a parser may insert tokens. In this case the parser
calls the procedure ErrorAttribute in order to ask for the additional properties of
an inserted token which is given by the parameter Token.
The procedure should return in the second argument called Attribute a
default value for the additional properties of the token Token.
.ip -
The variable Exit refers to a procedure which is called upon an internal error in
the scanner. The default procedure terminates the program execution. The variable can be
changed in order to achieve a different behaviour.
.ip -
If the scanner reaches the end of the input it returns the special token
called EofToken which is encoded by 0.
.sh 3 "Source Interface"
.pp
The scanners generated by Rex need a source module for blocked input of
characters. Rex can provide a prototype source module which reads from
standard input. It is contained in the files <Scanner>Source.md and <Scanner>Source.mi.
The definition module in the file <Scanner>Source.md has the following contents:
.(b
.FT
DEFINITION MODULE <Scanner>Source;
.sp 0.5
FROM SYSTEM     IMPORT ADDRESS;
FROM System     IMPORT tFile;
.sp 0.5
PROCEDURE BeginSource (FileName: ARRAY OF CHAR): tFile;
PROCEDURE GetLine (File: tFile; Buffer: ADDRESS; Size: CARDINAL): INTEGER;
PROCEDURE CloseSource (File: tFile);
.sp 0.5
END <Scanner>Source.
.)b
.ip -
BeginSource is called from the scanner in order to open files or to
initialize any other source of input.
If not called input is read from standard input.
.ip -
GetLine is called in order to fill a buffer starting at address 'Buffer'
with a block of maximal 'Size' characters. Lines are terminated
by newline characters (ASCII = 12C). GetLine returns the number
of characters transferred. Reasonable block sizes are between 128
and 2048 or the length of a line. Smaller block sizes -
especially block size 1 - will drastically slow down the scanner.
.ip -
CloseSource is called from the scanner at end of file respectively
at end of input. It can be used to close files.
.sp
.pp
The implementation module in the file <Scanner>Source.mi has the following contents:
.(l
.FT
IMPLEMENTATION MODULE <Scanner>Source;
.sp 0.5
FROM SYSTEM     IMPORT ADDRESS;
FROM System     IMPORT tFile, OpenInput, Read, Close;
.sp 0.5
PROCEDURE BeginSource (FileName: ARRAY OF CHAR): tFile;
   BEGIN
      RETURN OpenInput (FileName);
   END BeginSource;
.sp 0.5
PROCEDURE GetLine (File: tFile; Buffer: ADDRESS; Size: CARDINAL): INTEGER;
   CONST IgnoreChar = ' ';
   VAR n        : INTEGER;
   VAR BufferPtr: POINTER TO ARRAY [0..30000] OF CHAR;
   BEGIN
   (* # ifdef Dialog
      n := Read (File, Buffer, Size);
(* Add dummy after newline character in order to supply a lookahead for rex. *)
(* This way newline tokens are recognized without typing an extra line.      *)
      BufferPtr := Buffer;
      IF (n > 0) AND (BufferPtr^[n - 1] = 012C) THEN
         BufferPtr^[n] := IgnoreChar; INC (n); END;
      RETURN n;
      # else *)
      RETURN Read (File, Buffer, Size);
   (* # endif *)
   END GetLine;
.sp 0.5
PROCEDURE CloseSource (File: tFile);
   BEGIN
      Close (File);
   END CloseSource;
.sp 0.5
END <Scanner>Source.
.)l
.pp
The newline character may constitute a token of its own in applications such as dialog
programs. Like for every other token, Rex needs at least a look-ahead of one character to
recognize this token. Therefore the user has to type not only one extra character but a
complete extra input line because usually input is line buffered by the operating system.
This behaviour is undesirable. The problem can be solved by modifying the procedure GetLine
in the file <Scanner>Source.mi. The variant in the comment (* # ifdef Dialog ... # else *)
adds a dummy character after the newline character to serve as lookahead. The dummy
character should be a character that is ignored such as e. g. a blank.
.sh 3 "Scanner Driver"
.pp
A main program is necessary for the test of a generated scanner.
Rex can provide a minimal main program in the file <Scanner>Drv.mi which can serve
as test driver. It counts the tokens and looks like the following:
.(l
.FT
MODULE <Scanner>Drv;
.sp 0.5
FROM <Scanner>  IMPORT BeginScanner, GetToken, GetWord, Attribute, EofToken,
                       TokenLength, CloseScanner;
FROM Strings    IMPORT tString, ArrayToString, WriteL;
FROM IO         IMPORT StdOutput, WriteI, WriteC, WriteNl, CloseIO;
FROM Position   IMPORT WritePosition;
FROM System     IMPORT Exit;
.sp 0.5
VAR Token       : INTEGER;
    Word        : tString;
    Debug       : BOOLEAN;
    Count       : INTEGER;
.sp 0.5
BEGIN
   Debug := FALSE;
   Count := 0;
   BeginScanner;
   REPEAT
      Token := GetToken ();
      INC (Count);
      IF Debug THEN
         GetWord (Word);
         WritePosition (StdOutput, Attribute.Position);
         WriteI (StdOutput, Token, 5);
         WriteC (StdOutput, ' ');
         WriteL (StdOutput, Word);
      END;
   UNTIL Token = EofToken;
   CloseScanner;
   WriteI (StdOutput, Count, 0);
   WriteNl (StdOutput);
   CloseIO;
   rExit (0);
END <Scanner>Drv.
.)l
.sh 2 "Ada"
.sh 3 "Scanner Interface"
.pp
The scanners generated by Rex offer an interface given by the following
package contained in the file <Scanner>.ads:
.(b L
.FT
with Position, Strings;
.sp 0.5
package <Scanner> is
.sp 0.5
type tScanAttribute is record Position: tPosition; end record;
procedure ErrorAttribute (Token: Integer; Attribute: out tScanAttribute);
.sp 0.5
EofToken        : constant Integer := 0;
.sp 0.5
TokenLength     : Integer;
TokenIndex      : Integer;
Attribute       : tScanAttribute;
.sp 0.5
procedure BeginScanner  ;
procedure BeginFile     (FileName: String);
function  GetToken      return Integer;
procedure GetWord       (Word: out Strings.tString);
procedure GetLower      (Word: out Strings.tString);
procedure GetUpper      (Word: out Strings.tString);
procedure CloseFile     ;
procedure CloseScanner  ;
.sp 0.5
end <Scanner>;
.)b
.ip -
The procedure GetToken is the central scanning routine. It returns the next
token found in the input or whatever is specified in the actions associated
with the regular expressions.
.ip -
The procedure BeginFile may be called in order to open an input file or a nested
include file.
The parameter FileName specifies the file name.
The value "" (empty string) denotes input from standard input.
If not called input is read from standard input.
Include files up to a nesting depth of 15 can be processed.
.ip -
The procedure CloseFile may be called in order to close the current input file (before reaching end of
file). CloseFile is called automatically by the scanner upon reaching end of file.
.ip -
The procedure BeginScanner may be called in order to initialize user data.
The contents of the target code section named BEGIN is included in the body of this
procedure.
.ip -
The procedure CloseScanner may be called in order to finalize user data.
The contents of the target code section named CLOSE is included in the body of this
procedure.
.ip -
The procedures GetWord, GetLower, and GetUpper allow access to the matched
character sequence as described in section 4.4.
.ip -
The variable TokenLength specifies the number of matched characters.
.ip -
The variable TokenIndex is an array index of the internal buffer, an array of
characters, which specifies the location where the matched character sequence
starts. It can be used as argument for the macros that compute source positions.
.ip -
The variable Attribute is supposed to communicate additional properties of
the current token. The value must be provided by appropriate action statements.
This variable is of type tScanAttribute which has to be a record type with at
least one field called Position of type tPosition. tPosition has to be a record
type with at least two fields called Line and Column. The values of Line and
Column are computed by the scanner, automatically. They indicate the source
position of the current token. The position of a token is the position of the
first character of the token. For exceptions see section 3.8.
The types tScanAttribute and tPosition are predefined as given above.
The definitions of these types can be changed as described in section 3.7.
.ip -
During automatic error repair a parser may insert tokens. In this case the parser
calls the procedure ErrorAttribute in order to ask for the additional properties of
an inserted token which is given by the parameter Token.
The procedure should return in the second argument called Attribute a
default value for the additional properties of the token Token.
.ip -
If the scanner reaches the end of the input it returns the special token
called EofToken which is encoded by 0.
.sh 3 "Source Interface"
.pp
The scanners generated by Rex need a source module for blocked input of
characters. Rex can provide a prototype source module which reads from
standard input. It is contained in the files <Scanner>source.ads and <Scanner>source.adb.
The package module in the file <Scanner>source.ads has the following contents:
.(b L
.FT
package <Scanner>Source is
.sp 0.5
function  BeginSource (FileName: String) return Integer;
procedure GetLine     (File: Integer; Buffer: out String; Size: Integer;
                       Last: out Integer);
procedure CloseSource (File: Integer);
.sp 0.5
end <Scanner>Source;
.)b
.ip -
BeginSource is called from the scanner in order to open files or to
initialize any other source of input.
If not called input is read from standard input.
.ip -
GetLine is called in order to fill a buffer starting at address 'Buffer'
with a block of maximal 'Size' characters. Lines are terminated
by newline characters (ASCII = 12C). GetLine returns the number
of characters transferred. Reasonable block sizes are between 128
and 2048 or the length of a line. Smaller block sizes -
especially block size 1 - will drastically slow down the scanner.
.ip -
CloseSource is called from the scanner at end of file respectively
at end of input. It can be used to close files.
.sp
.pp
The implementation module in the file <Scanner>source.adb has the following contents:
.(l L
.FT
with System; Use System;
.sp 0.5
package body <Scanner>Source is
.sp 0.5
function BeginSource (FileName: String) return Integer is
      function OpenInput (FileName: Address) return Integer;
      pragma Interface (C, OpenInput);
      pragma Interface_Name (OpenInput, "OpenInput");
      C_Name    : String (1 .. 256);
   begin
      C_Name (1 .. FileName'Last) := FileName;
      C_Name (FileName'Last + 1)  := Character'Val (0);
      return OpenInput (C_Name'Address);
   end BeginSource;
.sp 0.5
procedure GetLine (File: Integer; Buffer: out String; Size: Integer;
                   Last: out Integer) is
      function rRead (File: Integer; Buffer: Address; Size: Integer)
                      return Integer;
      pragma Interface (C, rRead);
      pragma Interface_Name (rRead, "rRead");
   begin
      Last := rRead (File, Buffer'Address, Size);
   end GetLine;
.sp 0.5
procedure CloseSource (File: Integer) is
      procedure rClose (File: Integer);
      pragma Interface (C, rClose);
      pragma Interface_Name (rClose, "rClose");
   begin
      rClose (File);
   end CloseSource;
.sp 0.5
end <Scanner>Source;
.)l
.sh 3 "Scanner Driver"
.pp
A main program is necessary for the test of a generated scanner.
Rex can provide a minimal main program in the file <Scanner>drv.adb which can serve
as test driver. It counts the tokens and looks like the following:
.(l L
.FT
with <Scanner>, Text_Io, Position, Strings;
use  <Scanner>, Text_Io, Position, Strings;
.sp 0.5
procedure <Scanner>Drv is
.sp 0.5
   package Int_Io is new Text_Io.Integer_IO (Integer); use Int_Io;
.sp 0.5
   Token        : Integer       := 1;
   Word         : tString;
   Debug        : Boolean       := False;
   Count        : Integer       := 0;
begin
   BeginScanner;
   while Token /= EofToken loop
      Token := GetToken;
      Count := Count + 1;
      if Debug then
         WritePosition (Standard_Output, Attribute.Position);
         Put (Standard_Output, Token, 5);
         if TokenLength > 0 then
            Put (Standard_Output, ' ');
            GetWord (Word);
            WriteS (Standard_Output, Word);
         end if;
         New_Line (Standard_Output);
      end if;
   end loop;
   CloseScanner;
   Put (Standard_Output, Count, 0);
   New_Line (Standard_Output);
end <Scanner>Drv;
.)l
.sh 2 "Eiffel"
.sh 3 "Scanner Interface"
.pp
The file <Scanner>.e contains the class <Scanner> which offers the following
features:
.(b
.FT
class <Scanner>
.sp 0.5
creation BeginScanner
.sp 0.5
feature
.sp 0.5
EofToken        : INTEGER is 0
TokenLength     : INTEGER
Attribute       : ScanAttribute
.sp 0.5
BeginScanner    is
BeginFile       (FileName: STRING) is
GetToken        : INTEGER is
GetWord         : STRING is
GetLower        : STRING is
GetUpper        : STRING is
CloseFile       is
CloseScanner    is
.sp 0.5
ErrorAttribute  (Token: INTEGER): ScanAttribute is
SetAttribute    (Value: ScanAttribute) is
.)b
.ip -
The procedure GetToken is the central scanning routine. It returns the next
token found in the input or whatever is specified in the actions associated
with the regular expressions.
.ip -
The procedure BeginFile may be called in order to open an input file or a nested
include file.
The parameter FileName specifies the file name.
The value "" (empty string) denotes input from standard input.
If not called input is read from standard input.
Include files may be nested to arbitrary depth.
.ip -
The procedure CloseFile may be called in order to close the current input file
(before reaching end of file). CloseFile is called automatically by the
scanner upon reaching end of file.
.ip -
The procedure BeginScanner instantiates a scanner object and performs the
necessary initializations.
For example, the tables are read in from a file named <scanner>.txt.
The contents of the target code section named BEGIN
is included in the body of this procedure.
.ip -
The procedure CloseScanner may be called in order to finalize user data.
The contents of the target code section named CLOSE is included in the body
of this procedure.
.ip -
The procedures GetWord, GetLower, and GetUpper allow access to the matched
character sequence as described in section 4.4.
.ip -
The variable TokenLength specifies the number of matched characters.
.ip -
The variable Attribute is supposed to communicate additional properties of
the current token. The value must be provided by appropriate action statements.
The class of this feature has to be a subclass of the predefined support
class ScanAttribute. This class has one feature called Position of type Position.
The class Position has two features called Line and Column. The values of Line and
Column are computed automatically by the scanner. They indicate the source
position of the current token. The position of a token is the position of the
first character of the token. For exceptions see section 3.8.
The classes ScanAttribute and Position are predefined in the library
reuse/eiffel. Subclasses of these classes can be defined in order reflect
application specific needs.
.ip -
During automatic error repair a parser may insert tokens. In this case the parser
calls the procedure ErrorAttribute in order to ask for the additional properties of
an inserted token which is given by the parameter Token. The procedure should
return a default value for the additional properties of the token Token.
.ip -
The procedure SetAttribute can be used to store values in the variable Attribute.
.ip -
If the scanner reaches the end of the input it returns the special token
called EofToken which is encoded by 0.
.sh 3 "Source Interface"
.pp
The scanners generated by Rex need a source class for blocked input of
characters. Rex can provide a prototype source module which reads from
standard input. It is contained in the file source.e and has the following interface:
.(b
.FT
class Source
.sp 0.5
creation Open
.sp 0.5
feature
.sp 0.5
Open (filename: STRING) is
GetLine (wanted: INTEGER): STRING is
Close is
.)b
.ip -
Open is called from the scanner in order to open files or to
initialize any other source of input.
If not called input is read from standard input.
.ip -
GetLine is called in order to return a block of maximal 'wanted' characters.
.ip -
Close is called from the scanner at end of file respectively
at end of input. It can be used to close files.
.sh 3 "Scanner Driver"
.pp
A main program is necessary for the test of a generated scanner.
Rex can provide a minimal main program in the file <Scanner>drv.e which can
serve as test driver. It counts the tokens and looks as follows:
.(l
.FT
class <Scanner>Drv
.sp 0.5
creation main
.sp 0.5
feature
.sp 0.5
main is
   local
      Token     : INTEGER
      Count     : INTEGER
      Scanner   : <Scanner>
      f         : rFILE
      Attribute : ScanAttribute
   do
      !! f.make_write_from_fp (f.stdout_fp)
      !! Scanner.BeginScanner
      from
         Token := Scanner.GetToken
         Count := 1
         debug
            Scanner.Attribute.Position.WritePosition (f)
            f.putint2 (Token, 5)
            f.putchar (' ')
            f.putstring (Scanner.GetWord)
            f.new_line
         end
      until Token = Scanner.EofToken loop
         Token := Scanner.GetToken
         Count := Count + 1
         debug
            Scanner.Attribute.Position.WritePosition (f)
            f.putint2 (Token, 5)
            f.putchar (' ')
            f.putstring (Scanner.GetWord)
            f.new_line
         end
      end
      Scanner.CloseScanner
      f.putint (Count)
      f.new_line
      f.close
   end
.sp 0.5
end
.)l
.sh 2 "Java"
.sh 3 "Scanner Interface"
.pp
The file <Scanner>.java contains the class <Scanner> which offers the following
features as default:
.(l
.FT
import de.cocolab.reuse.*;
.sp 0.5
public class <Scanner> {
.sp 0.5
    class ScanAttribute implements HasPosition {
    }
.sp 0.5
    public ScanAttribute errorAttribute (int token) {
    }
.sp 0.5
    public static final int eofToken    = 0;
.sp 0.5
    public int          tokenLength;
.sp 0.5
    public ScanAttribute attribute;
.sp 0.5
    public              <Scanner>       () throws java.io.IOException;
    public void         beginFile       (java.io.InputStream stream)
                                           throws java.io.IOException;
    public int          getToken        () throws java.io.IOException;
    public String       getWord         ();
    public String       getLower        ();
    public String       getUpper        ();
    public void         closeFile       () throws java.io.IOException;
    public void         finalize        ();
}
.)l
.ip -
The procedure \fIgetToken\fP is the central scanning routine. It returns the next
token found in the input or whatever is specified in the actions associated
with the regular expressions.
.ip -
The procedure \fIbeginFile\fP may be called in order to open an input file or a nested
include file.
The parameter \fIstream\fP specifies the input source.
If not called input is read from standard input.
Include files may be nested to arbitrary depth.
.ip -
The procedure \fIcloseFile\fP may be called in order to close the current input file
(before reaching end of file).
\fIcloseFile\fP is called automatically by the scanner upon reaching end of file.
.ip -
The contents of the target code section named BEGIN is included in the contructor
<Scanner>(), and is executed whenever a new scanner object is created.
.ip -
The procedure \fIfinalize\fP may be called in order to finalize user data.
The contents of the target code section named CLOSE is included in the body of this
procedure. A good JVM will call this procedure when the scanner object is garbage
collected, or it may be called explicitly.
.ip -
The procedures \fIgetWord\fP, \fIgetLower\fP, and \fIgetUpper\fP allow access to
the matched character sequence as described in section 4.4.
.ip -
The variable \fItokenLength\fP specifies the number of matched characters.
.ip -
The variable \fIattribute\fP is supposed to communicate additional properties of
the current token. The value must be provided by appropriate action statements.
This variable is of type ScanAttribute which has to be a class which implements
the interface HasPosition, i.e. it has a method \fIposition ()\fP which returns
an instance of Position.  Position has to be a class
with at least two fields called \fIline\fP and \fIcolumn\fP. This arrangment leaves
the user free to decide whether to have a field of type Position or to inherit
directly from Position.  The default definition of the macro yySetPosition
assumes the latter; this minimises the number of objects created.
The values of line and
column are computed by the scanner, automatically. They indicate the source
position of the current token. The position of a token is the position of the
first character of the token. For exceptions see section 3.8.
.ip -
During automatic error repair a parser may insert tokens. In this case the parser
calls the procedure \fIerrorAttribute\fP in order to ask for the additional properties of
an inserted token which is given by the parameter \fItoken\fP.
The procedure should return
default values for the additional properties of the token.
.ip -
In the event of an internal error in the scanner an exception de.cocolab.reuse.FatalError
will be thrown. It is not required to catch this exception.
.ip -
If the scanner reaches the end of the input it returns the special token
called \fIeofToken\fP which is encoded by 0.
.lp
The internal scanner interface consists of the following objects:
.ip -
The initial size of the scanner input buffer is defined by the value of the
preprocessor symbol yyInitBufferSize with a default of 8448. The buffer size is
increased automatically when necessary. The initial buffer size can be changed
by including a C preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyInitBufferSize 562
.)b
For best results, the value should be a power of two plus a constant between 50
and 256.
.ip -
The stack for include files is supplied by default with unlimited size.
If nested include files are not required the size of the generated scanner can be
reduced by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyInitFileStackSize 0
.)b
.ip -
The value for tab stops is defined by the preprocessor symbol yyTabSpace with
a default of 8. This value can be changed
by including a preprocessor directive in the GLOBAL section such as:
.(b
.FT
# define yyTabSpace 4
.)b
.ip -
The stack used by yyPush and yyPop is initially 16 elements, and will grow as
required. A different initial size can be specified by including a preprocessor
directive in the GLOBAL section such as:
.(b
.FT
# define yyInitStStStackSize 32
.)b
If the initial size is given as zero then there is no start state stack, and yyPush/yyPop
may not be used. This feature may be used to obtain the smallest possible scanner.
.sh 3 "Tuning the Scanner Interface"
.pp
It is not possible to design one interface to the scanner that
is optimal in all circumstances.
This is because different cases will require different emphasis on the
following characteristics:
.ip -
the number of objects created per token; there will always be an object
representing source location (Position) and there will often be an additional
object ecapsulating this together with other information about the token, for
example a coded identifier.  This is important where the input is large
and run time is to be minimized.
.ip -
memory usage; the size of an instance of ScanAttribute is important if it is
to be stored in an abstract syntax tree and the size of the input may be large.
.ip -
the number of classes generated; the time to load a Java applet over the WWW
increases with the number of classes.  For small input load time is the most
significant factor.
.pp
A scanner generated for Java may be tuned in a number of ways using macros
defined in the GLOBAL section and by proper choice of design for the
ScanAttribute class.  These facilities are introduced
here: more details may be found by examining the skeleton from which Rex
generates a Java scanner, i.e. the file Scanner.java found in the lib/rex
directory within the Cocktail installation.
.ip -
The name ScanAttribute may be defined to Position so that attributes consist
directly of an instance of Position (this being the minimum requirement of a
.i lark
generated parser).  This is suitable for a small, fast scanner which does
not have to deliver additional attributes.
.ip -
ScanAttribute may extend Position instead of having a field of type Position.
This avoids an additional object creation at the cost of having some
information in the ScanAttribute class about the implementation of Position.
Specifically, there needs to be a constructor which mirrors that of Position
and a decision must be made as to what \fItoString ()\fP should return - just
the position or some representation of any additional attributes.
For an example of this technique see the default EXPORT section in the skeleton.
.ip -
Another way of achieving the same end is to have ScanAttribute implement
HasPosition.  The values of line and column are stored as fields and used to
create an instance of Position only when the \fIposition ()\fP method is
called, that is only if a syntax error is detected.  This achieves the aim of
creating only one object per token for correct input while avoiding the issue
of what \fItoString ()\fP should return.
.ip -
By default the macro \fIyySetPosition\fP is defined to create an instance of
ScanAttribute from the position information.  This macro is called whenever
a pattern is matched and position calculation has not been suppressed
(see section 3.8) but \fIbefore\fP any user action code is entered.  If the
user action code may create some subclass of ScanAttribute in order to include
attributes specific to the type of token (the value of a numeric literal for
example) then either yySetPosition must be redefined or position calculation
must be suppressed for those rules which will instantiate some descendant of
ScanAttribute.
.ip -
The macro \fIyyGetTokenBegin\fP may be used to execute code at the beginning of
\fIgetToken ()\fP, that is for every token read.  By default this macro is
empty.
.ip -
The macro \fIyyAttributePosition (attribute)\fP may be used to change how
position information is obtained from an instance of ScanAttribute.  This is
only of significance when the scanner is reporting some internal error such as
misuse of the \fIyyPush/yyPop\fP methods.  A scanner to be used by a
.i lark
generated parser has other requirements.
.sh 3 "Source Interface"
.pp
The scanners generated by Rex need a source module for blocked input of
characters. For Java this is any class which descends from java.io.InputStream.
.sh 3 "Scanner Driver"
.pp
A main program is necessary for the test of a generated scanner.
Rex can provide a minimal main program in the file <Scanner>Drv.java which
can serve as test driver. It counts the tokens and looks like the following:
.(l
.FT
import java.io.*;
.sp 0.5
/**
 * Simple class for driving a generated scanner.
 */
.sp 0.5
class <Scanner>Drv {
.sp 0.5
    public static void main (String argv []) throws java.io.IOException {
        <Scanner> scanner = new <Scanner> ();
        int token;
        boolean debug = false;
        String filename = null;
        int count = 0;
.sp 0.5
        for (int i = 0; i < argv.length; i ++) {
            if (argv [i].equals ("-D")) debug = true;
            else filename = argv [i];
        }
.sp 0.5
        if (filename != null)
            scanner.beginFile (new FileInputStream (filename));
.sp 0.5
        do {
            token = scanner.getToken ();
            count ++;
            if (debug) {
                String word = scanner.getWord ();
                System.err.println (scanner.attribute.position () + " " +
                    token + " " + word);
            }
        } while (token != <Scanner>.eofToken);
        scanner.finalize ();
        System.out.println (count);
    }
}
.)l
.sh 1 "Usage"
.de TH
..
.lf 1 ./rex.1
.TH REX 1 "" "CoCoLab Germany"
.SH NAME
rex \- generator of lexical analyzers
.SH SYNOPSIS
rex [ -options ] [ -k{124} ] [ -f\fIfile\fP ] [ -l\fIdirectory\fP ] [ \fIfile\fP ]
.SH DESCRIPTION
.I Rex
generates program code to be used in lexical analysis of text.
A typical application is the generation of scanners for compilers.
The generated scanners can handle single byte input as well as Unicode input.
The input
.I file
contains regular expressions to be searched for, and actions written in the
implementation language to be executed when strings according to the expressions
are found. Unrecognized portions of the input are copied to standard output.
In order to be able to recognize tokens depending on their context,
\fIRex\fP provides start states to handle left context
and the right context can be specified by an additional regular expression.
If several regular expressions match the input characters, the
longest match is preferred. If there are still several possibilities, the
regular expression given first in the specification is chosen.
.PP
\fIRex\fP generated scanners automatically provide the line and column position
of every token. For languages like Pascal and Ada where the case of letters is
insignificant tokens can be normalized to lower or upper case. There are
predefined rules to skip white space such as blanks, tabs, or newlines
and there is a mechanism to handle include files.
The generated scanners are implemented as table-driven deterministic finite
automatons.
.SH OPTIONS
.IP a
generate all (= ds)
.IP c
generate a lexical analyzer in C
.IP +
generate a lexical analyzer in C++
.IP m
generate a lexical analyzer in Modula-2 (default)
.IP u
generate a lexical analyzer in Ada
.IP e
generate a lexical analyzer in Eiffel
.IP j
generate a lexical analyzer in Java
.IP d
generate a header file or definition module
.IP s
generate support modules:
.br
- a source module for input
.br
- a main program to be used as test driver
.IP v
do not predefine rules for skipping of white space
.IP x
require explicit definitions for used identifiers
.br
(default: undefined identifiers are treated as strings)
.IP y
do not generate dummy labels
(might cause compiler messages such as 'statement not reached')
(default: generate dummy labels, might cause compiler messages such as 'label not used'.)
.IP r
reduce the number of generated case/switch labels, might be necessary due to compiler
restrictions. Effects: slower scanner (2-4%), larger tables, same scanner size
.IP i
use ISO 8 bit code (default: ASCII 7 bit code)
.IP k<n>
generate scanner for characters having n bytes (default: 1)
(n > 1 implies -z and disables CHARACTER_SET)
.IP z[<n>]
map characters to classes at run time, use an array of n elements, n >= 256
(default: 16384)
.IP o
optimize table size.
Effects: slower scanner (0-15%), small tables, long generation time (factor 1-10).
.IP n
do not optimize table size.
Effects: fast scanner, large tables (factor 1-10), short generation time.
.IP " "
default: improve table size.
Effects: slower scanner (0-5%), medium size tables (factor 1-2), medium generation time (factor 1-2).
.IP w
suppress warnings
.IP g
generate # line directives
.IP b
do not partition character set into blocks during generation (implies -k1)
.IP t
touch output files only if necessary
.IP p
print information about ambiguous rules
.IP 1
print statistics about the generated lexical analyzer
.IP h
print help information
.IP -f\fIfile\fP
specify a file to be used as skeleton for the scanner
.IP -l\fIdir\fP
specify the directory dir where rex finds its data files
.SH FILES
.nf
.ta 2i
if output is in C:
.sp 0.5
<Scanner>.h	header file of the generated scanner
<Scanner>.c	body of the generated scanner
<Scanner>Source.h	header file of support module source
<Scanner>Source.c	body of support module source
<Scanner>Drv.c	body of the scanner driver (main program)
.sp 0.5
if output is in C++:
.sp 0.5
<Scanner>.h	header file of the generated scanner
<Scanner>.cxx	body of the generated scanner
<Scanner>Source.h	header file of support module source
<Scanner>Source.cxx	body of support module source
<Scanner>Drv.cxx	body of the scanner driver (main program)
.sp 0.5
if output is in Modula-2:
.sp 0.5
<Scanner>.md	definition module of the generated scanner
<Scanner>.mi	implementation module of the generated scanner
<Scanner>Source.md	definition module of support module source
<Scanner>Source.mi	implementation module of support module source
<Scanner>Drv.mi	implementation module of the scanner driver
.sp 0.5
if output is in Ada:
.sp 0.5
<Scanner>.ads	package of the generated scanner
<Scanner>.adb	package body of the generated scanner
<Scanner>source.ads	package of support module source
<Scanner>source.adb	package body of support module source
<Scanner>drv.adb	package body of the scanner driver
.sp 0.5
if output is in Eiffel:
.sp 0.5
<Scanner>.e	class of the generated scanner
<Scanner>buffer.e	class of the character buffer for the scanner
<Scanner>drv.e	class of the scanner driver (main program)
<Scanner>.txt	tables controlling the generated scanner (ASCII format)
source.e	support class for input
attribute.e	support class for the description of properties of nonterminals
scanattribute.e	support class for the description of properties of tokens
position.e	support class for the representation of source positions
rfile.e 	support class extending the class FILE
rsystem.e	support class for system specific properties
.sp 0.5
if output is in Java:
.sp 0.5
<Scanner>.java	class of the generated scanner
<Scanner>Drv.java	class of the scanner driver (main program)
.fi
.SH SEE\ ALSO
J. Grosch: "Rex - A Scanner Generator",
CoCoLab Germany, Document No. 5
.sp 0.5
J. Grosch: "Efficient Generation of Lexical Analyzers",
Software - Practice & Experience, 19 (11), 1089-1103, Nov. 1989
.sp 0.5
J. Grosch: "Efficient Generation of Table-Driven Scanners",
CoCoLab Germany, Document No. 2
.lf 2961 /tmp/.doc
.sh 1 "Implementation"
.pp
Rex is implemented by a 12,000 line Modula-2 program.
The program makes heavy use of a library of reusable Modula-2 modules
currently comprising 9,000 lines of code
\*([[Groa\*(],Grob\*(]].
Of the 12,000 lines of Rex around 4,900 lines are generated by tools:
.ip -
2100 lines for the scanner are generated by Rex itself.
.ip -
1500 lines for the parser are generated by the LALR(1) parser generator
.i lark.
.ip -
1100 lines for a tree data structure are generated by the abstract syntax tree tool
.i ast.
.ip -
250 lines for an attribute evaluator are generated by the attribute evaluator
generator
.i ag.
.pp
How can Rex generate a part of itself before its existence? Well, the
scanner has been bootstrapped using LEX. The first version of the scanner
was a separate C program generated by LEX which wrote the internal
representation of the tokens on a file.
A simple hand written scanner read the tokens from this file during
construction of Rex. After Rex was operational it could generate its own
scanner in Modula-2.
.pp
And how is Rex working? It differentiates between constant regular
expressions and non-constant ones as defined in\*([<\*([[Gro89\*(]]\*(>].
The non-constant regular expressions constitute a nondeterministic finite
automaton.
The so-called subset construction algorithm is used for conversion into a
deterministic finite automaton.
Then an algorithm to minimize the number of states is applied. After
extending the automaton to a tunnel automaton the constant regular
expressions are added in linear time using the algorithm described in
\*([[Gro89\*(]].
The sparse matrix to control the automaton is compressed into a data
structure called "comb vector"\*([<\*([[ASU86\*(]]\*(>] to save space.
.pp
The key to the performance of scanners generated by Rex lies in the
following facts:
.ip -
access to the "comb vector" table is fast
.ip -
input happens rarely because blocks of characters are transferred
.ip -
no check for the last character of a block is necessary because of
the sentinel technique used
.ip -
the same holds for the check of stack underflow for the stack to record the
passed states
.ip -
the treatment of right context is efficient and only necessary in a few
cases because partial evaluation has been applied
.sh 1 "Differences to LEX"
.lp
Some specialists might want to know about the differences between Rex and
LEX\*([<\*([[Les75\*(]]\*(>] (see Table):
.(z L
.sp 0.5
.ce
Table: Syntactical differences between Rex and LEX:
.sp 0.5
.TS
center;
l l l.
Meaning	LEX	Rex
_
delimiter for character classes	[ ]	{ }
complement of character classes	[^ ]	- { }
any character	.	ANY
left justification	^	<
right justification	$	>
replicator	{n}	[n]
replicator	{m,n}	[m-n]
delimiter for start states	< >	# #
escape representation for characters	\\octal	\\decimal
scanner routine	yylex	<Scanner>_GetToken
access to matched string	yytext	<Scanner>_GetWord ( )
length of matched string	yyleng	result of <Scanner>_GetWord ( )
output of matched string	ECHO	yyEcho
retain part of matched string	yyless	yyLess
initial start state	INITIAL	STD
change of start state	BEGIN	yyStart ( )
character set	%T	CHARACTER_SET
action at end of input	yywrap	EOF section
.TE
.)z
.lp
Advantages of Rex:
.ip +
Rex can generate scanners for Unicode.
.ip +
The standard or initial start state has a documented name: STD.
.ip +
The list of start states can be inverted using the operator NOT to specify
that a rule is valid in all states except the listed ones.
.ip +
The specifications can be written unformatted - white space in the form of
blanks, tabs, and newlines is skipped.
.ip +
Identifiers used to refer to named regular expressions are written without
enclosing braces '{' '}'.
.ip +
Rex automatically calculates the source position of the tokens in the
fields Line and Column of the variable <Scanner>_Attribute.
.ip +
There are predefined rules to skip the white space characters.
.ip +
Include files with an unlimited nesting depth can be processed.
.ip +
Routines are provided to normalize tokens to upper or lower case characters.
.ip +
No adjustment of the internal data structures are necessary to be able to
process large specifications.
.lp
Disadvantages of Rex:
.ip \-
The action statement yymore is not available.
.ip \-
The action statement REJECT is not available - Rex can only find one
solution and not all like LEX.
.bp
.uh "Appendix 1: Syntax of the Specification Language"
.sp
.lp
.nf
.FT
specification   : decls rules
                .
decls           :
                | decls name
                | decls code
.mc \(bv
                | decls characterSet
.mc
                | decls define
                | decls start
                .
name            : SCANNER [Ident]
                | SCANNER DottedIdent /* Java only */
                .
code            : IMPORT  TargetCode
                | EXPORT  TargetCode
                | GLOBAL  TargetCode
                | LOCAL   TargetCode
                | BEGIN   TargetCode
                | CLOSE   TargetCode
                | DEFAULT TargetCode
                | EOF     TargetCode
                .
characterSet    : CHARACTER_SET '{' charDef * '}'
                .
define          : DEFINE definition *
                .
.mc \(bv
start           : START [identList] ['-' identList]
.mc
                .
rules           : RULE  rule *
                | RULES rule *
                .
charDef         : CsChar   CsNumber
                | CsNumber CsNumber
                .
definition      : Ident '=' regExpr '.'
                .
identList       : Ident
                | identList Ident
                | identList ',' Ident
                .
rule            : patternList ':'  TargetCode
                | patternList ':-' TargetCode
                .
patternList     : pattern
                | patternList ',' pattern
                .
pattern         : [startStates] ['<'] regExpr ['/' regExpr] ['>']
                .
startStates     : '#' identList '#'
.mc \(bv
                | '#' '*' '#'
.mc
                | NOT '#' identList '#'
.mc \(bv
                | '-' '#' identList '#'
                .
regExpr         : regExpr '|' regTerm
                | regTerm
.mc
                .
.mc \(bv
regTerm         : regTerm regFactor
                | regFactor
                .
regFactor       : regFactor '+'
                | regFactor '*'
                | regFactor '?'
                | regFactor '[' Number ']'
                | regFactor '[' Number '-' Number ']'
.mc
                | '(' regExpr ')'
                | charSet
                | Char
                | Ident
                | String
                | Number
                .
charSet         : '-' charSet
                | '{' range * '}'
                .
range           : Char
                | Char '-' Char
                .
Char            : CsChar
                | '\\' decimal_number
                | '\\' hex_number
                | '\\' ('x' | 'X') hex_digit *
                | '\\' ('u' | 'U') hex_digit *
                .
Ident           : letter letter_or_digit *
                .
DottedIdent     : Ident
                | DottedIdent '.' Ident
                .
letter_or_digit : letter
                | digit
                | '_'
                .
String          : '"' character * '"'
                .
Number          : decimal_number
                .
Target_code     : '{' character * '}'
                .
CsChar          : character
.mc \(bv
                | '\\' a
.mc
                | '\\' n
                | '\\' t
                | '\\' v
                | '\\' b
                | '\\' r
                | '\\' f
                | '\\' character
                .
CsNumber        : octal_number
                | decimal_number
                | hex_number
                .
octal_number    : '0' octal_digit *
                .
decimal_number  : digit +
                .
hex_number      : '0' ('x' | 'X') hex_digit *
                .
.bp
.uh "Appendix 2: Example Specification of a Modula-2-Scanner in C"
.sp
.lp
.nf
.FT
.sz 10
GLOBAL  {
# include "Memory.h"
# include "StringM.h"
# include "Idents.h"
.sp 0.5
int level = 0;
.sp 0.5
void ErrorAttribute (Token, Attribute)
   int Token;
   tScanAttribute Attribute;
   {
   }
}
.sp 0.5
LOCAL   {
   char         Word [256];
   tIdent       ident   ;
   tStringRef   ref     ;
   int          length  ;
}
.sp 0.5
DEFAULT {
   printf ("illegal character: "); yyEcho; printf ("\\n");
}
.sp 0.5
DEFINE
.sp 0.5
   digit        = {0-9}         .
   letter       = {a-z A-Z}     .
   cmt          = - {*(\\t\\n}    .
.sp 0.5
START   comment
.sp 0.5
RULE
           "(*"         :- {++ level; yyStart (comment);}
#comment#  "*)"         :- {-- level; if (level == 0) yyStart (STD);}
#comment#  "(" | "*" | cmt + :- {}
.sp 0.5
   /* The procedure PutString is imported from the module StringM(emory).
      It is used to store the string representation of some tokens.       */
.sp 0.5
#STD# digit +           ,
#STD# digit + / ".."    : {length = GetWord (Word);
                           ref = PutString (Word, length);
                           return 1;}
#STD# {0-7} + B         : {length = GetWord (Word);
                           ref = PutString (Word, length);
                           return 2;}
#STD# {0-7} + C         : {length = GetWord (Word);
                           ref = PutString (Word, length);
                           return 3;}
#STD# digit {0-9 A-F} * H : {
                           length = GetWord (Word);
                           ref = PutString (Word, length);
                           return 4;}
#STD# digit + "." digit * (E {+\\-} ? digit +) ? : {
                           length = GetWord (Word);
                           ref = PutString (Word, length);
                           return 5;}
.sp 0.5
#STD# ' - {\\n'} * '     |
      \\" - {\\n"} * \\"   : {length = GetWord (Word);
                           ref = PutString (Word, length);
                           return 6;}
.sp 0.5
#STD# "#"               : {return 7;}
#STD# "&"               : {return 8;}
#STD# "("               : {return 9;}
#STD# ")"               : {return 10;}
#STD# "*"               : {return 11;}
#STD# "+"               : {return 12;}
#STD# ","               : {return 13;}
#STD# "-"               : {return 14;}
#STD# "."               : {return 15;}
#STD# ".."              : {return 16;}
#STD# "/"               : {return 17;}
#STD# ":"               : {return 18;}
#STD# ":="              : {return 19;}
#STD# ";"               : {return 20;}
#STD# "<"               : {return 21;}
#STD# "<="              : {return 22;}
#STD# "<>"              : {return 23;}
#STD# "="               : {return 24;}
#STD# ">"               : {return 25;}
#STD# ">="              : {return 26;}
#STD# "["               : {return 27;}
#STD# "]"               : {return 28;}
#STD# "^"               : {return 29;}
#STD# "{"               : {return 30;}
#STD# "|"               : {return 31;}
#STD# "}"               : {return 32;}
#STD# "~"               : {return 33;}
.sp 0.5
#STD# AND               : {return 34;}
#STD# ARRAY             : {return 35;}
#STD# BEGIN             : {return 36;}
#STD# BY                : {return 37;}
#STD# CASE              : {return 38;}
#STD# CONST             : {return 39;}
#STD# DEFINITION        : {return 40;}
#STD# DIV               : {return 41;}
#STD# DO                : {return 42;}
#STD# ELSE              : {return 43;}
#STD# ELSIF             : {return 44;}
#STD# END               : {return 45;}
#STD# EXIT              : {return 46;}
#STD# EXPORT            : {return 47;}
#STD# FOR               : {return 48;}
#STD# FROM              : {return 49;}
#STD# IF                : {return 50;}
#STD# IMPLEMENTATION    : {return 51;}
#STD# IMPORT            : {return 52;}
#STD# IN                : {return 53;}
#STD# LOOP              : {return 54;}
#STD# MOD               : {return 55;}
#STD# MODULE            : {return 56;}
#STD# \\NOT              : {return 57;}
#STD# OF                : {return 58;}
#STD# OR                : {return 59;}
#STD# POINTER           : {return 60;}
#STD# PROCEDURE         : {return 61;}
#STD# QUALIFIED         : {return 62;}
#STD# RECORD            : {return 63;}
#STD# REPEAT            : {return 64;}
#STD# RETURN            : {return 65;}
#STD# SET               : {return 66;}
#STD# THEN              : {return 67;}
#STD# TO                : {return 68;}
#STD# TYPE              : {return 69;}
#STD# UNTIL             : {return 70;}
#STD# VAR               : {return 71;}
#STD# WHILE             : {return 72;}
#STD# WITH              : {return 73;}
.sp 0.5
#STD# letter (letter | digit) * : {
                           ident = MakeIdent (TokenPtr, TokenLength);
                           return 74;}
.bp
.uh "Appendix 3: Example Specification of a Modula-2-Scanner in Modula-2"
.sp
.lp
.nf
.FT
.sz 10
GLOBAL  {
   FROM Strings         IMPORT tString          ;
   FROM StringM         IMPORT tStringRef       , PutString     ;
   FROM Idents          IMPORT tIdent           , MakeIdent     ;
.sp 0.5
   VAR level            : CARDINAL;
.sp 0.5
   PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
      BEGIN
      END ErrorAttribute;
}
.sp 0.5
LOCAL   {
   VAR
      Word              : tString;
      ident             : tIdent;
      ref               : tStringRef;
}
.sp 0.5
BEGIN   { level := 0; }
.sp 0.5
DEFAULT {
IO.WriteS (IO.StdOutput, "illegal character: "); yyEcho; IO.WriteNl (IO.StdOutput);
}
.sp 0.5
DEFINE
.sp 0.5
   digit        = {0-9}         .
   letter       = {a-z A-Z}     .
   cmt          = - {*(\\t\\n}    .
.sp 0.5
START   comment
.sp 0.5
RULE
           "(*"         :- {INC (level); yyStart (comment);}
#comment#  "*)"         :- {DEC (level); IF level = 0 THEN yyStart (STD); END;}
#comment#  "(" | "*" | cmt + :- {}
.sp 0.5
#STD# digit +           ,
#STD# digit + / ".."    : {GetWord (Word);
                           ref := PutString (Word);
                           RETURN 1;}
#STD# {0-7} + B         : {GetWord (Word);
                           ref := PutString (Word);
                           RETURN 2;}
#STD# {0-7} + C         : {GetWord (Word);
                           ref := PutString (Word);
                           RETURN 3;}
#STD# digit {0-9 A-F} * H : {
                           GetWord (Word);
                           ref := PutString (Word);
                           RETURN 4;}
#STD# digit + "." digit * (E {+\\-} ? digit +) ? : {
                           GetWord (Word);
                           ref := PutString (Word);
                           RETURN 5;}
.sp 0.5
#STD# ' - {\\n'} * '     |
      \\" - {\\n"} * \\"   : {GetWord (Word);
                           ref := PutString (Word);
                           RETURN 6;}
.sp 0.5
#STD# "#"               : {RETURN 7;}
#STD# "&"               : {RETURN 8;}
#STD# "("               : {RETURN 9;}
#STD# ")"               : {RETURN 10;}
#STD# "*"               : {RETURN 11;}
#STD# "+"               : {RETURN 12;}
#STD# ","               : {RETURN 13;}
#STD# "-"               : {RETURN 14;}
#STD# "."               : {RETURN 15;}
#STD# ".."              : {RETURN 16;}
#STD# "/"               : {RETURN 17;}
#STD# ":"               : {RETURN 18;}
#STD# ":="              : {RETURN 19;}
#STD# ";"               : {RETURN 20;}
#STD# "<"               : {RETURN 21;}
#STD# "<="              : {RETURN 22;}
#STD# "<>"              : {RETURN 23;}
#STD# "="               : {RETURN 24;}
#STD# ">"               : {RETURN 25;}
#STD# ">="              : {RETURN 26;}
#STD# "["               : {RETURN 27;}
#STD# "]"               : {RETURN 28;}
#STD# "^"               : {RETURN 29;}
#STD# "{"               : {RETURN 30;}
#STD# "|"               : {RETURN 31;}
#STD# "}"               : {RETURN 32;}
#STD# "~"               : {RETURN 33;}
.sp 0.5
#STD# AND               : {RETURN 34;}
#STD# ARRAY             : {RETURN 35;}
#STD# BEGIN             : {RETURN 36;}
#STD# BY                : {RETURN 37;}
#STD# CASE              : {RETURN 38;}
#STD# CONST             : {RETURN 39;}
#STD# DEFINITION        : {RETURN 40;}
#STD# DIV               : {RETURN 41;}
#STD# DO                : {RETURN 42;}
#STD# ELSE              : {RETURN 43;}
#STD# ELSIF             : {RETURN 44;}
#STD# END               : {RETURN 45;}
#STD# EXIT              : {RETURN 46;}
#STD# EXPORT            : {RETURN 47;}
#STD# FOR               : {RETURN 48;}
#STD# FROM              : {RETURN 49;}
#STD# IF                : {RETURN 50;}
#STD# IMPLEMENTATION    : {RETURN 51;}
#STD# IMPORT            : {RETURN 52;}
#STD# IN                : {RETURN 53;}
#STD# LOOP              : {RETURN 54;}
#STD# MOD               : {RETURN 55;}
#STD# MODULE            : {RETURN 56;}
#STD# \\NOT              : {RETURN 57;}
#STD# OF                : {RETURN 58;}
#STD# OR                : {RETURN 59;}
#STD# POINTER           : {RETURN 60;}
#STD# PROCEDURE         : {RETURN 61;}
#STD# QUALIFIED         : {RETURN 62;}
#STD# RECORD            : {RETURN 63;}
#STD# REPEAT            : {RETURN 64;}
#STD# RETURN            : {RETURN 65;}
#STD# SET               : {RETURN 66;}
#STD# THEN              : {RETURN 67;}
#STD# TO                : {RETURN 68;}
#STD# TYPE              : {RETURN 69;}
#STD# UNTIL             : {RETURN 70;}
#STD# VAR               : {RETURN 71;}
#STD# WHILE             : {RETURN 72;}
#STD# WITH              : {RETURN 73;}
.sp 0.5
#STD# letter (letter | digit) * : {
                           GetWord (Word);
                           ident := MakeIdent (Word);
                           RETURN 74;}
.bp
.uh "Appendix 4: Example Specification of a Scanner for Rex"
.sp
.lp
.nf
.FT
.sz 10
EXPORT  {

FROM Idents     IMPORT tIdent   ;
FROM StringM    IMPORT tStringRef;
FROM Texts      IMPORT tText    ;
FROM Position   IMPORT tPosition;
.mc \(bv
FROM UniCode    IMPORT UCHAR    ;
.mc

TYPE
   tScanAttribute       = RECORD
              Position  : tPosition     ;
         CASE : INTEGER OF
         | 1: Ident     : tIdent        ;
         | 2: Number    : SHORTCARD     ;
         | 3: String    : tStringRef    ;
.mc \(bv
         | 4: Ch        : UCHAR         ;
.mc
         | 5: Text      : tText         ;
         END;
      END;

.mc \(bv
VAR ErrorCount  : CARDINAL;

.mc
PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
.mc \(bv
PROCEDURE startCode     ;
PROCEDURE startCharset  ;
PROCEDURE startSet      ;
PROCEDURE startRules    ;
.mc
}

GLOBAL  {

.mc \(bv
FROM Strings    IMPORT tString, Concatenate, Char, SubString, cMaxStrLength,
                        StringToInt, StringToNumber, AssignEmpty, Length,
                        ArrayToString, IntToString;
.mc
FROM Texts      IMPORT MakeText, Append;
FROM StringM    IMPORT tStringRef, PutString;
.mc \(bv
FROM Idents     IMPORT tIdent, MakeIdent, NoIdent, GetString;
FROM Errors     IMPORT Message, Error, Restriction;
FROM ScanGen    IMPORT Language, tLanguage, Procedures, AppendLine,
                        pGetWord, pGetLower, pGetUpper, pinput, pyyPush, pyyPop;
.mc
FROM Position   IMPORT tPosition;
.mc \(bv
FROM UniCode    IMPORT MaxUCHAR;
.mc

CONST
   SymIdent             = 1     ;
   SymNumber            = 2     ;
   SymString            = 3     ;
   SymChar              = 4     ;
   SymTargetcode        = 5     ;
   SymScanner           = 37    ;
.mc \(bv
   SymImport            = 39    ;
.mc
   SymExport            = 32    ;
   SymGlobal            = 6     ;
   SymLocal             = 31    ;
   SymBegin             = 7     ;
   SymClose             = 8     ;
   SymEof               = 34    ;
   SymDefault           = 36    ;
.mc \(bv
   SymCharSet           = 38    ;
.mc
   SymDefine            = 9     ;
   SymStart             = 10    ;
   SymRules             = 11    ;
   SymDot               = 12    ;
   SymComma             = 13    ;
   SymEqual             = 14    ;
   SymColon             = 15    ;
   SymColonMinus        = 35    ;
   SymNrSign            = 33    ;
   SymSlash             = 16    ;
   SymBar               = 17    ;
   SymPlus              = 18    ;
   SymMinus             = 19    ;
   SymAsterisk          = 20    ;
   SymQuestion          = 21    ;
   SymLParen            = 22    ;
   SymRParen            = 23    ;
   SymLBracket          = 24    ;
   SymRBracket          = 25    ;
   SymLBrace            = 26    ;
   SymRBrace            = 27    ;
   SymLess              = 28    ;
   SymGreater           = 29    ;
.mc \(bv
   SymRule              = 30    ;
.mc

VAR
   level        : INTEGER       ;
.mc \(bv
   string, TargetCode   : tString       ;
.mc
   NoString     : tStringRef    ;
.mc \(bv
   StartPosition, StringPosition: tPosition     ;
   PrevState    : SHORTCARD     ;
   IsChar       : BOOLEAN       ;
.mc

.mc \(bv
PROCEDURE ErrorAttribute (Token: CARDINAL; VAR Attribute: tScanAttribute);
.mc
   BEGIN
.mc \(bv
      pAttribute.Position := Attribute.Position;
.mc
      CASE Token OF
      |  SymIdent       : Attribute.Ident  := NoIdent;
      |  SymNumber      : Attribute.Number := 0;
      |  SymString      : Attribute.String := NoString;
.mc \(bv
      |  SymChar        : Attribute.Ch     := ORD ('?');
.mc
      |  SymTargetcode  : MakeText (Attribute.Text);
      ELSE
      END;
   END ErrorAttribute;
.mc \(bv

PROCEDURE startCode;
  BEGIN
    yyStart (targetcode);
    MakeText (Attribute.Text);
    AssignEmpty (TargetCode);
    level := 1;
  END startCode;

PROCEDURE startCharset;
  BEGIN
    yyStart (charset);
    IsChar := TRUE;
  END startCharset;

PROCEDURE startSet;
  BEGIN
    yyStart (set);
  END startSet;

PROCEDURE startRules;
  BEGIN
    yyStart (rules);
  END startRules;
.mc
}

.mc \(bv
LOCAL   {
VAR
   String, Word : tString;
   n, PPLine    : LONGCARD;

PROCEDURE AppendCode;
   BEGIN
      GetWord (Word);
      Concatenate (TargetCode, Word);
   END AppendCode;
}
.mc

BEGIN   {
   level := 0;
   AssignEmpty (string);
   NoString := PutString (string);
.mc \(bv
   ErrorCount := 0;
}

DEFAULT {
   Message ("illegal character", Error, Attribute.Position);
   INC (ErrorCount);
.mc
}

EOF     {
   CASE yyStartState OF
   | targetcode ,
.mc \(bv
     set        : Message ("terminating '}' missing", Error, StartPosition);
                  INC (ErrorCount);
   | comment    : Message ("unterminated comment", Error, StartPosition);
                  INC (ErrorCount);
.mc
   | CStr1, CStr2,
.mc \(bv
     AStr1, AStr2,
     Str1, Str2 : Message ("unterminated string", Error, StringPosition);
                  INC (ErrorCount);
.mc
   ELSE
   END;
   yyStart (STD);
}

DEFINE
   letter       = {A-Z a-z}     .
   digit        = {0-9}         .
.mc \(bv
   octdigit     = {0-7}         .
   hexdigit     = {0-9 A-F a-f} .
.mc
   string       = - {"\\n}       .
   cmtch        = - {*\\t\\n}     .
.mc \(bv
   code         = - {{\\}\\t\\n\\r\\\\'"gGiy#} .
.mc
   StrCh1       = - {'\\t\\n}     .
   StrCh2       = - {"\\t\\n}     .
   CStrCh1      = - {'\\t\\n\\\\}   .
   CStrCh2      = - {"\\t\\n\\\\}   .
.mc \(bv
   AStrCh       = {\\ !#-~}      .
.mc

.mc \(bv
START targetcode, set, rules, comment,
      Str1, Str2, CStr1, CStr2, AStr1, AStr2, charset, PPline
.mc

RULES

.mc \(bv
#targetcode#    "{"     :- {
                           AppendCode;
.mc
                           INC (level);
                        }

#targetcode#    "}"     :- {
                           DEC (level);
                           IF level = 0 THEN
                              yyStart (PrevState);
                              Append (Attribute.Text, TargetCode);
                              Attribute.Position := Position;
                              RETURN SymTargetcode;
                           ELSE
.mc \(bv
                              AppendCode;
.mc
                           END;
                        }

.mc \(bv
#targetcode#    code + | {gGiy\\r#} :- { AppendCode; }

#targetcode#    GetWord :- {IF Language # Java THEN
                              INCL (Procedures, pGetWord);
                            END; AppendCode; }
#targetcode#    getWord :- {IF Language = Java THEN
                              INCL (Procedures, pGetWord);
                            END; AppendCode; }
#targetcode#    GetLower:- {IF Language # Java THEN
                              INCL (Procedures, pGetLower);
                            END;  AppendCode; }
#targetcode#    getLower:- {IF Language = Java THEN
                              INCL (Procedures, pGetLower);
                            END;  AppendCode; }
#targetcode#    GetUpper:- {IF Language # Java THEN
                              INCL (Procedures, pGetUpper);
                            END;  AppendCode; }
#targetcode#    getUpper:- {IF Language = Java THEN
                              INCL (Procedures, pGetUpper);
                            END;  AppendCode; }

#targetcode#    input   :- { INCL (Procedures, pinput   ); AppendCode; }
#targetcode#    yyPush  :- { INCL (Procedures, pyyPush  ); AppendCode; }
#targetcode#    yyPop   :- { INCL (Procedures, pyyPop   ); AppendCode; }
.mc

#targetcode#    \\t      :- {
                           Strings.Append (TargetCode, 11C);
                           yyTab;
                        }

.mc \(bv
#targetcode#    \\r ? \\n :- {
.mc
                           Append (Attribute.Text, TargetCode);
                           AssignEmpty (TargetCode);
                           yyEol (0);
                        }

#targetcode#    \\\\ ANY  :- {
                           GetWord (Word);
                           Strings.Append (TargetCode, Char (Word, 2));
                        }

.mc \(bv
#targetcode#    \\\\ / \\r ? \\n,
#targetcode#    \\\\      :- { Strings.Append (TargetCode, '\\'); }
.mc

#targetcode#    '       : {
                   GetWord (String);
.mc \(bv
                   IF (Language = C) OR (Language = Cpp) THEN yyStart (CStr1);
                   ELSIF Language = Ada THEN yyStart (AStr1);
.mc
                   ELSE yyStart (Str1);
                   END;
.mc \(bv
                   StringPosition := Attribute.Position;
.mc
                        }

#targetcode#    \\"      : {
                   GetWord (String);
.mc \(bv
                   IF (Language = C) OR (Language = Cpp) THEN yyStart (CStr2);
                   ELSIF Language = Ada THEN yyStart (AStr2);
.mc
                   ELSE yyStart (Str2);
                   END;
.mc \(bv
                   StringPosition := Attribute.Position;
.mc
                        }

#Str1#  StrCh1 +        ,
#Str2#  StrCh2 +        ,
#CStr1# CStrCh1 + | \\\\ ANY ? ,
.mc \(bv
#CStr2# CStrCh2 + | \\\\ ANY ? ,
#AStr2# AStrCh +        :- {GetWord (Word); Concatenate (String, Word);}
.mc

.mc \(bv
#CStr1, CStr2# \\\\ \\r ? \\n:- {Strings.Append (String, '\');
                             Strings.Append (String, 12C); yyEol (0);}
.mc

#Str1, CStr1# '         ,
.mc \(bv
#Str2, CStr2, AStr2# \\" ,
#AStr1# ANY ' ?         :- {GetWord (Word); Concatenate (String, Word);
.mc
                            yyPrevious; Concatenate (TargetCode, String);
                        }

#Str1, Str2, CStr1, CStr2# \\t :- {Strings.Append (String, 11C); yyTab;}

.mc \(bv
#Str1, Str2, CStr1, CStr2, AStr2# \\r ? \\n :- {
                 (* Message ("unterminated string", Error, Attribute.Position);
                    INC (ErrorCount); *)
                    Strings.Append (String, 12C);
.mc
                    yyEol (0); yyPrevious; Concatenate (TargetCode, String);
                        }

.mc \(bv
#Str1, Str2, CStr1, CStr2# \\r :- {Strings.Append (String, 15C);}

#STD, rules, charset#
          "/*"          :  {yyStart (comment);
                            StartPosition := Attribute.Position; }
.mc
#comment# "*" | cmtch + :- {}
#comment# "*/"          :- {yyPrevious;}

.mc \(bv
#STD, rules, charset# "//" ANY * :- {}

#STD# IMPORT            : {PrevState := STD; RETURN SymImport   ;}
#STD# EXPORT            : {PrevState := STD; RETURN SymExport   ;}
#STD# GLOBAL            : {PrevState := STD; RETURN SymGlobal   ;}
#STD# LOCAL             : {PrevState := STD; RETURN SymLocal    ;}
#STD# BEGIN             : {PrevState := STD; RETURN SymBegin    ;}
#STD# CLOSE             : {PrevState := STD; RETURN SymClose    ;}
#STD# DEFAULT           : {PrevState := STD; RETURN SymDefault  ;}
#STD# EOF               : {PrevState := STD; RETURN SymEof      ;}
.mc
#STD# SCANNER           : {RETURN SymScanner    ;}
.mc \(bv
#STD# CHARACTER_SET     : {RETURN SymCharSet    ;}
.mc
#STD# DEFINE            : {RETURN SymDefine     ;}
#STD# START             : {RETURN SymStart      ;}
.mc \(bv
#STD# RULE              : {RETURN SymRule       ;}
#STD# RULES             : {RETURN SymRules      ;}
.mc

#STD, rules#    letter (letter | digit | _) * : {
                           GetWord (Word);
                           Attribute.Ident  := MakeIdent (Word);
                           RETURN SymIdent;
                        }

#STD, rules#    digit + : {
                           GetWord (Word);
                           Attribute.Number := StringToInt (Word);
                           RETURN SymNumber;
                        }

#STD, rules#    \\" string * \\" : {
.mc \(bv
   IF TokenLength > cMaxStrLength THEN
      Message ("string too long (max. 255)", Restriction, Attribute.Position);
      INC (ErrorCount);
      ArrayToString (" ", TargetCode);
   ELSIF TokenLength = 2 THEN
      Message ("string length > 0 required", Error, Attribute.Position);
      INC (ErrorCount);
      ArrayToString (" ", TargetCode);
   ELSE
.mc
      GetWord (Word);
      SubString (Word, 2, Length (Word) - 1, TargetCode);
.mc \(bv
   END;
.mc
   Attribute.String := PutString (TargetCode);
   RETURN SymString;
                        }

#STD#           "."     : {RETURN SymDot        ;}
#STD#           "="     : {RETURN SymEqual      ;}
#STD, set#      "}"     : {yyPrevious;          RETURN SymRBrace        ;}
#STD, set, rules# "-"   : {RETURN SymMinus      ;}
#STD, rules#    ","     : {RETURN SymComma      ;}
#STD, rules#    "|"     : {RETURN SymBar        ;}
#STD, rules#    "+"     : {RETURN SymPlus       ;}
#STD, rules#    "*"     : {RETURN SymAsterisk   ;}
#STD, rules#    "?"     : {RETURN SymQuestion   ;}
#STD, rules#    "("     : {RETURN SymLParen     ;}
#STD, rules#    ")"     : {RETURN SymRParen     ;}
#STD, rules#    "["     : {RETURN SymLBracket   ;}
#STD, rules#    "]"     : {RETURN SymRBracket   ;}
.mc \(bv
#STD, rules#    "{"     : {StartPosition := Attribute.Position;
                           RETURN SymLBrace     ;}
.mc
#rules#         "#"     : {RETURN SymNrSign     ;}
#rules#         "/"     : {RETURN SymSlash      ;}
#rules#         "<"     : {RETURN SymLess       ;}
#rules#         ">"     : {RETURN SymGreater    ;}
.mc \(bv
#rules#         ":"     : {PrevState := rules; RETURN SymColon      ;}
#rules#         ":-"    : {PrevState := rules; RETURN SymColonMinus ;}
.mc

.mc \(bv
#STD, set, rules# \\\\ a  : {Attribute.Ch := 012C; RETURN SymChar;}
#STD, set, rules# \\\\ b  : {Attribute.Ch := 010C; RETURN SymChar;}
#STD, set, rules# \\\\ t  : {Attribute.Ch := 011C; RETURN SymChar;}
.mc
#STD, set, rules# \\\\ n  : {Attribute.Ch := 012C; RETURN SymChar;}
#STD, set, rules# \\\\ v  : {Attribute.Ch := 013C; RETURN SymChar;}
.mc \(bv
#STD, set, rules# \\\\ f  : {Attribute.Ch := 014C; RETURN SymChar;}
.mc
#STD, set, rules# \\\\ r  : {Attribute.Ch := 015C; RETURN SymChar;}

#STD, set, rules# \\\\ digit + : {
                   GetWord (Word);
                   SubString (Word, 2, Length (Word), TargetCode);
.mc \(bv
                   n := LONGCARD (StringToInt (TargetCode));
                   IF n <= MaxUCHAR THEN
                      Attribute.Ch := n;
                   ELSE
                      Message ("number out of range", Error, Attribute.Position);
                      INC (ErrorCount);
                      Attribute.Ch := 0;
                   END;
                   RETURN SymChar;
                        }

#STD, set, rules# \\\\ "0" {xX} hexdigit + : {
                   GetWord (Word);
                   SubString (Word, 4, Length (Word), TargetCode);
                   n := StringToNumber (TargetCode, 16);
                   IF n <= MaxUCHAR THEN
                      Attribute.Ch := n;
                   ELSE
                      Message ("number out of range", Error, Attribute.Position);
                      INC (ErrorCount);
                      Attribute.Ch := 0;
                   END;
                   RETURN SymChar;
                        }

#STD, set, rules# \\\\ {xXuU} hexdigit + : {
                   GetWord (Word);
                   SubString (Word, 3, Length (Word), TargetCode);
                   n := StringToNumber (TargetCode, 16);
                   IF n <= MaxUCHAR THEN
                      Attribute.Ch := n;
                   ELSE
                      Message ("number out of range", Error, Attribute.Position);
                      INC (ErrorCount);
                      Attribute.Ch := 0;
                   END;
.mc
                   RETURN SymChar;
                        }

#STD, set, rules# \\\\ ANY : {
                           GetWord (Word);
.mc \(bv
                           Attribute.Ch := ORD (Char (Word, 2));
.mc
                           RETURN SymChar;
                        }

.mc \(bv
#STD, set, rules# \\\\ / \\r \\n : {
                           Attribute.Ch := ORD ('\\');
                           RETURN SymChar;
                        }

#STD, set, rules# - {\\ \\t\\n\\f\\r\\26} : {
.mc
                           GetWord (Word);
.mc \(bv
                           Attribute.Ch := ORD (Char (Word, 1));
.mc
                           RETURN SymChar;
                        }

.mc \(bv
\\f , \\r , \\26           :- {}

#charset# digit         : {
                           IsChar := NOT IsChar;
                           GetWord (Word);
                           IF NOT IsChar THEN
                              Attribute.Ch := ORD (Char (Word, 1));
                              RETURN SymChar;
                           ELSE
                              Attribute.Number := StringToInt (Word);
                              RETURN SymNumber;
                           END;
                        }

#charset# "0" octdigit *: {
                           IsChar := NOT IsChar;
                           GetWord (Word);
                           Attribute.Number := StringToNumber (Word, 8);
                           RETURN SymNumber;
                        }

#charset# digit +       : {
                           IsChar := NOT IsChar;
                           GetWord (Word);
                           Attribute.Number := StringToInt (Word);
                           RETURN SymNumber;
                        }

#charset# "0" {xX} hexdigit + : {
                           IsChar := NOT IsChar;
                           GetWord (Word);
                           SubString (Word, 3, Length (Word), TargetCode);
                           Attribute.Number := StringToNumber (TargetCode, 16);
                           RETURN SymNumber;
                        }

#charset# \\\\ a : {Attribute.Ch := ORD (007C); IsChar := FALSE; RETURN SymChar;}
#charset# \\\\ b : {Attribute.Ch := ORD (010C); IsChar := FALSE; RETURN SymChar;}
#charset# \\\\ t : {Attribute.Ch := ORD (011C); IsChar := FALSE; RETURN SymChar;}
#charset# \\\\ n : {Attribute.Ch := ORD (012C); IsChar := FALSE; RETURN SymChar;}
#charset# \\\\ v : {Attribute.Ch := ORD (013C); IsChar := FALSE; RETURN SymChar;}
#charset# \\\\ f : {Attribute.Ch := ORD (014C); IsChar := FALSE; RETURN SymChar;}
#charset# \\\\ r : {Attribute.Ch := ORD (015C); IsChar := FALSE; RETURN SymChar;}

#charset# \\\\ ANY        : {
                           IsChar := FALSE;
                           GetWord (Word);
                           Attribute.Ch := ORD (Char (Word, 2));
                           RETURN SymChar;
                        }

#charset# - {\\ \\t\\n\\f\\r\\26\\}} : {
                           IsChar := FALSE;
                           GetWord (Word);
                           Attribute.Ch := ORD (Char (Word, 1));
                           RETURN SymChar;
                        }

#charset# "}" / {\\ \\t\\n} * digit : {
                           IsChar := FALSE;
                           Attribute.Ch := ORD ('}');
                           RETURN SymChar;
                        }

#charset# "}"           : {yyStart (STD); RETURN SymRBrace;}

.hc ~
< "#@" " " * "line" " " +:{yyPush (PPline);}

#PPline# {0-9} +        :- {GetWord (Word);
                            PPLine := StringToInt (Word) - 1;
                            (* -1 to compensate for the following yyEol () *)
                        }

#PPline# \\" -{\\n"} + \\" :- {GetWord (Word);
                            SubString (Word, 2, Length (Word) - 1, Word);
                            yyLineCount := PPLine;
                            (* change the line only if there is a file name *)
                            Attribute.Position.File := MakeIdent (Word);
                        }

#PPline# " " * \\r ? \\n  :- {yyPop ();
                            CASE yyStartState OF
                            | targetcode:
                              AppendLine (TargetCode, yyLineCount,
                                          Attribute.Position.File);
                            ELSE
                            END;
                            yyEol (0); (* don't move yyEol before CASE *)
                        }
.mc
.fi
.sp
.ne 2c
.sz 12
.[]
.[-
.ds [F ASU86
.ds [A A\*(p]\*(a]V\*(p] Aho
.as [A \*(c]R\*(p] Sethi
.as [A \*(m]J\*(p]\*(a]D\*(p] Ullman
.ds [T Compilers: Principles, Techniques, and Tools
.ds [I Addison Wesley
.ds [C Reading, M\&A
.ds [D 1986
.][
.[-
.ds [F Gro89
.ds [A J\*(p] Grosch
.ds [T Efficient Generation of Lexical Analysers
.ds [J Software\(emPractice & Experience
.ds [V 19
.ds [N 11
.nr [P 1
.ds [P 1089-1103
.ds [D Nov. 1989
.][
.[-
.ds [F Groa
.ds [A J\*(p] Grosch
.ds [T Reusable Software - A Collection of Modula-Modules
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 4
.ds [N 4
.][
.[-
.ds [F Grob
.ds [A J\*(p] Grosch
.ds [T Reusable Software - A Collection of C-Modules
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 30
.ds [N 30
.][
.[-
.ds [F Les75
.ds [A M\*(p]\*(a]E\*(p] Lesk
.ds [T LEX \(em A Lexical Analyzer Generator
.ds [R Computing Science Technical Report 39
.ds [I Bell Telephone Laboratories
.ds [C Murray Hill, NJ
.ds [D 1975
.][
.bp 1
.lp
.b Contents
.sp
.xp
