.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.EQ
delim off
.EN
.hc ~
.ds ], , 
.T0


	Toolbox Introduction


	J. Grosch


.T1
.T2 "" "Toolbox Introduction" "Josef Grosch" "Sept. 25, 2002" 25 2002
.bp 1
.ce 99
.b "Toolbox Introduction"
.ce 0
.sp
.uh Abstract
.lp
This document introduces into the usage of the Karlsruhe Toolbox for Compiler Construction.
It should be read by those who effectively want to use the toolbox as first document.
Those who want to learn about the toolbox and its contents in general are referred
to the document "A Toolbox for Compiler Construction".
.lp
This document gives an overview about the documentation of the toolbox. It describes
how the individual tools interact in order to generate a complete compiler. The general
structure of a makefile to control the tools is discussed.
.(z L
.ce
Table 1: Document Set
.sp 0.5
.TS
center box;
l | l | n.
Filename	Title	Pages
_
.mc \(bv
intro	Toolbox Introduction	14
.mc
toolbox	A Tool Box for Compiler Construction	11
werkzeug	Werkzeuge f\*ur den \*Ubersetzerbau	11
reuseC	Reusable Software - A Collection of C-Modules	31
reuseJava	Reusable Software - A Java Package	3
reuse	Reusable Software - A Collection of Modula-2-Modules	27
prepro	Preprocessors	17
rex	Rex - A Scanner Generator	58
scanex	Selected Examples of Scanner Specifications	21
scangen	Efficient Generation of Table-Driven Scanners	12
.mc \(bv
lark	Lark - An LALR(2) Parser Generator With Backtracking	90
.mc
ell-bnf	The Parser Generator Ell	28
lalr	Lalr - A Generator for Efficient Parsers	18
ell	Efficient and Comfortable Error Recovery in Recursive Descent Parsers	15
highspee	Generators for High-Speed Front-Ends	11
autogen	Automatische Generierung effizienter Compiler	10
.mc \(bv
ast	Ast - A Generator for Abstract Syntax Trees	74
.mc
toolsupp	Tool Support for Data Structures	12
.mc \(bv
ag	Ag - An Attribute Evaluator Generator	38
.mc
ooags	Object-Oriented Attribute Grammars	10
multiple	Multiple Inheritance in Object-Oriented Attribute Grammars	11
objects	Object-Orientation in the Cocktail Toolbox	6
.mc \(bv
puma	Puma - A Generator for the Transformation of Attributed Trees	39
.mc
trafo	Transformation of Attributed Trees Using Pattern Matching	15
wag	Efficient Evaluation of Well-Formed Attribute Grammars And Beyond	11
minilax	Specification of a MiniLAX-Interpreter	37
cookbook	Semantic Analysis Cookbook - Part 1: Declarations	93
faq	Cocktail FAQ - Frequently Asked Questions	9
.\" begmanual	BEG - a Back End Generator - User Manual	71
.\" mtc	Entwurf und Implementierung eines \*Ubersetzers von Modula-2 nach C	105
.\" estra	Spezifikation und Implementierung der Transformation attributierter B\*aume	79
.TE
.)z
.sh 1 "Document Overview"
.lp
The documentation of the Karlsruhe Toolbox for Compiler Construction consists of
separate user's manuals for the individual tools and additional papers describing
further aspects such as implementation details, examples, and applications. The
documents are written in English. For a few of them there are German versions as well.
.\" Only the two master thesis about \fIestra\fP and \fImtc\fP exist in German, only.
.sh 2 Format
.lp
The documents exist in several formats: Postscript, PDF, troff, and ASCII text.
The documentation of the Java version of the library reuse is in the format
HTML.
The formats are distinguished by the file suffixes .ps, .pdf, .me, .txt, and
.html.
The Postscript files are formatted for two paper sizes: letter format and A4
format.
The troff files need processing with the program \fIpic\fP and the device
independent version of troff called
.i ditroff
using me-macros or even better the GNU version of troff using commands such as
.(b
.FT
pic | tbl | eqn | ditroff -me
groff -pte -me | lpr
.)b
Depending on the format, the documents are located in the directories
doc.ps, doca4.ps, doc.pdf, doc.me, doc.txt, or doc.html. The pictures
are missing in the ASCII text format because of obvious limitations.
.sh 2 Documents
.lp
Table 1 lists the titles of the documents, the corresponding filenames (without
suffix), and the number of pages.
.sh 2 Outlines
.lp
In the following the contents of every document is outlined shortly:
.ip "Toolbox Introduction"
An introduction for effective users of the toolbox which should be consulted first.
It gives an overview about the document set and describes how the tools interact.
.ip "A Tool Box for Compiler Construction"
Explains the contents of the toolbox and the underlying design. The individual tools
are sketched shortly and some application experiences are reported.
.ip "Werkzeuge f\*ur den \*Ubersetzerbau"
A German version of the previous document.
.ip "Reusable Software - A Collection of Modula-2-Modules"
Describes a library of useful routines written in Modula-2 which are oriented towards
compiler construction. The output of some tools has to be linked with this library.
.ip "Reusable Software - A Collection of C-Modules"
Describes a library of useful routines written in C which are oriented towards
compiler construction. The output of some tools has to be linked with this library.
.ip "Reusable Software - A Java Package"
A brief description of a useful package of reusable classes written in Java
is given. The package is oriented towards compiler construction.
.ip "Preprocessors"
Describes several preprocessors for the extraction of scanner specifications out of
parser specifications and for the conversion of \fIlex\fP/\fIyacc\fP input to
\fIrex\fP/\fIlark\fP input or vice versa. There are eight preprocessors:
.(b
lpp -z	converts an attribute grammar to \fIlark\fP input
rpp	combines a grammar and a scanner specification to \fIrex\fP input
l2r	converts \fIlex\fP input to \fIrex\fP input
y2l	converts \fIyacc\fP input to \fIlark\fP input
r2l	converts \fIrex\fP input to \fIlex\fP input
lpp -u	converts an attribute grammar to \fIyacc\fP input
bnf	converts a grammar from EBNF to BNF
l2cg	converts \fIlark\fP input to an attribute grammar
.)b
.ip "Rex - A Scanner Generator"
The user's manual for the scanner generator \fIrex\fP.
.ip "Selected Examples of Scanner Specifications"
A collection of scanner specifications for \fIrex\fP dealing mostly with pathological cases.
.ip "Efficient Generation of Table-Driven Scanners"
Describes internals of the scanner generator \fIrex\fP like the so-called tunnel
automaton and the linear time algorithm for constant regular expressions.
.mc \(bv
.br
.mc
.ip "Lark - A LALR(2) Parser Generator With Backtracking"
.mc \(bv
.mc
The user's manual for the LR(1) and LALR(2) parser generator \fIlark\fP.
This tool is able to parse non-LR(k) languages with its backtracking capability.
.ip "The Parser Generator Ell"
The user's manual for the LL(1) parser generator \fIell\fP (recursive descent)
and the grammar transformation tool \fIbnf\fP.
It describes the input language common to both tools.
.ip "Lalr - A Generator for Efficient Parsers"
Describes details of the implementation of the parsers generated by
\fIlark\fP and \fIlalr\fP (a predecessor of \fIlark\fP)
and further outstanding features of these tools.
.ip "Efficient and Comfortable Error Recovery in Recursive Descent Parsers"
Describes the implementation of the parsers generated by \fIell\fP especially with respect to
automatic error recovery.
.ip "Generators for High-Speed Front-Ends"
A summary of the highlights of the scanner and parser generators and a comparison to
\fIlex\fP/\fIyacc\fP and \fIflex\fP/\fIbison\fP.
.ip "Automatische Generierung effizienter Compiler"
A German version of the previous document.
.ip "Ast - A Generator for Abstract Syntax Trees"
The user's manual of \fIast\fP, a tool supporting the definition and manipulation of attributed
trees and graphs.
.ip "Tool Support for Data Structures"
Also describes \fIast\fP, but less precise than the previous document.
.ip "Ag - An Attribute Evaluator Generator"
The user's manual of \fIag\fP, a generator for evaluators of ordered attribute grammars (OAG).
.ip "Object-Oriented Attribute Grammars"
Also describes \fIag\fP, like the previous document, with emphasis on the object-oriented
features.
.ip "Multiple Inheritance in Object-Oriented Attribute Grammars"
Extends the object-oriented attribute grammars described in the previous document to
multiple inheritance.
.ip "Object-Orientation in the Cocktail Toolbox"
Surveyes the aspects of object-orientation that appear at the specification level of
several tools.
.\" .ip "Spezifikation und Implementierung der Transformation attributierter B\*aume"
.\" Diploma thesis in German about the design and implementation of \fIestra\fP, a generator for the
.\" transformation of attributed trees.
.ip "Puma - A Generator for the Transformation of Attributed Trees"
The user's manual of \fIpuma\fP, a tool for the
transformation of attributed trees which is based on pattern matching and unification.
.ip "Transformation of Attributed Trees Using Pattern Matching"
Also describes \fIpuma\fP using a more introductory style and compares it to similar tools.
.ip "Specification of a MiniLAX-Interpreter"
The annotated input to generate a compiler for the example language MiniLAX.
.ip "Semantic Analysis Cookbook - Part 1: Declarations"
A collection of recipes for name analysis and symbol tables using attribute grammars.
.ip "Cocktail FAQ - Frequently Asked Questions"
This list answers some frequently asked questions primarily with respect to
efficiency.
.\" .ip "BEG - a Back End Generator - User Manual"
.\" The user's manual of the back-end-generator \fIbeg\fP.
.\" .ip "Entwurf und Implementierung eines \*Ubersetzers von Modula-2 nach C"
.\" Diploma thesis in German about the design and implementation of the Modula-to-C translator
.\" \fImtc\fP.
.lp
For readers intending to use the tools the following documents are of primary interest:
.(b
.ta 3c
intro	Toolbox Introduction
toolbox	A Tool Box for Compiler Construction
prepro	Preprocessors
rex	Rex - A Scanner Generator
.mc \(bv
lark	Lark - A LALR(2) Parser Generator With Backtracking
.mc
ell-bnf	The Parser Generator Ell
ast	Ast - A Generator for Abstract Syntax Trees
ag	Ag - An Attribute Evaluator Generator
puma	Puma - A Generator for the Transformation of Attributed Trees
.\" begmanual	BEG - a Back End Generator - User Manual
.)b
.(z
.PS
linewid	= linewid * 1.2
boxwid	= boxwid * 1.7
boxht	= boxht * 1.2
circlerad = circlerad * 1.2
bh	= boxht * 1.7
bw	= boxwid * 0.5

	right

S1:	box wid bw height bh invis
SP:	box wid boxwid * 1.6 "Scanner spec:" "regular expressions"
	arrow
T:	circle "rex"
	arrow
I1:	box "Scanner"

S2:	box at S1 - (0, bh) wid bw height bh invis
P:	box wid boxwid * 1.6 "Parser spec:" "concrete syntax (grammar)" "mapping: concrete \(-> abstract"
	arrow
	circle "lark" "ell"
	arrow
I2:	box "Parser"

S3:	box at S2 - (0, bh) wid bw height bh invis
	box wid boxwid * 1.6 "Tree spec:" "abstract syntax" "(grammar)"
	arrow
	circle "ast"
	arrow
I3:	box "Tree"

S4:	box at S3 - (0, bh) wid bw height bh invis
	box wid boxwid * 1.6 "Semantic spec:" "attribute grammar"
	arrow
	circle "ag"
	arrow
I4:	box "Semantic"

S5:	box at S4 - (0, bh) wid bw height bh invis
	box wid boxwid * 1.6 "Trafo spec:" "mapping:" "abstract \(-> intermediate"
	arrow
	circle "puma"
	arrow
I5:	box "Trafo"

S6:	box at S5 - (0, bh) wid bw height bh invis
	box wid boxwid * 1.6 "Intermediate spec:" "intermediate language" "(grammar)"
	arrow
	circle "ast"
	arrow
I6:	box "Intermediate"

S7:	box at S6 - (0, bh) wid bw height bh invis
	box wid boxwid * 1.6 "Codegenerator spec:" "mapping:" "intermediate \(-> machine"
	arrow
	circle "puma"
	arrow
I7:	box "Codegenerator"

	box invis "Specification" at SP + (0, bh)
	box invis "Tool" at T + (0, bh)
	box invis "Compiler" "Module" at I1 + (0, bh)

	line from I1.n up boxht * 0.9 <-
	arrow from I1.s to I2.n
	arrow from I2.s to I3.n
	arrow from I3.s to I4.n <->
	arc from I3.se to I5.ne at I4 -> cw
	arrow from I5.s to I6.n
	arrow from I6.s to I7.n
	arrow from I7.s down boxht * 0.9
.PE
.sp 0.5
.ce
Fig. 1: Compiler Structure
.)z
.ne 2c
Of secondary interest might be:
.(b
.ta 3c
reuseC	Reusable Software - A Collection of C-Modules
reuseJava	Reusable Software - A Java Package
reuse	Reusable Software - A Collection of Modula-2-Modules
scanex	Selected Examples of Scanner Specifications
faq	Cocktail FAQ - Frequently Asked Questions
.)b
The other documents either describe internals of the tools or are excerpts of the above.
.sh 1 "Generating a Compiler"
.lp
A compiler usually consists of several modules where every module handles a certain task.
The toolbox gives very much freedom for the design of a compiler and supports various
structures.
.pp
Figure 1 presents our preferred compiler structure. In the right column are the main modules
that constitute a compiler. The left column contains the necessary specifications. In
between there are the tools which are controlled by the specifications and which produce the
modules. The arrows represent the data flow in part during generation time and in part during
run time of the compiler.
.pp
In principle the compiler model works as follows: A scanner and a parser read the source,
check the concrete syntax, and construct an abstract syntax tree. They may perform several
normalizations, simplifications, or transformations in order to keep the abstract syntax
relatively simple. Semantic analysis is performed on the abstract syntax tree. Optionally
attributes for code generation may be computed. Afterwards the abstract syntax tree is
transformed into an intermediate representation. The latter is the input of the code generator
which finally produces the machine code.
.pp
The picture in Figure 1 is relatively abstract by just listing the main tasks of a compiler.
Every task is generated by a tool out of a separate specification which is oriented towards
the problem at hand. The generation processes seem to be independent of each other.
.(z
.PS
scale	= 2.54
boxwid	= 2.0
boxht	= 1.0
circlerad = 0.75
linewid	= 1.2
lineht	= 0.75

	right
SC:	box ".scn"
	arrow
RPP:	circle "rpp"
	arrow
	box ".rex"
	arrow
REX:	circle "rex"
	arrow

PA:	box ".prs" at SC + (0, -4)
	arrow
XZ:	circle "lpp"
	arrow
	box ".lrk"
	arrow
LALR:	circle "lark"
	arrow

	arrow at XZ.n up
	box "Scanner" ".rpp"
	arrow

	right
DOT:	box ".ell" at PA + (0, -2)
ELL:	circle "ell" at LALR + (0, -2)
	arrow
	arrow from DOT.e to ELL.w

	down
AG:	circle "ag/cg" at XZ + (0, -4)
	arrow
STORE:	box ".ST"
	arrow
AST:	circle "ast/cg"
	arrow
	box ".TS"
	arrow
PUMA:	circle "puma"

	box ".cg" at STORE + (-3, 0)
	arrow from last box.ne to AG.sw
	arrow from last box.se to AST.nw
	box ".pum" at PUMA + (-3, 0)
	arrow from last box.e to PUMA.w

SO:	box "Source" at REX + (3, 0); arrow right at last box.e
SCA:	box "Scanner" at last box + (0, -2); arrow right at last box.e
PA:	box "Parser" at last box + (0, -2); arrow right at last box.e
ER:	box "Errors" at last box + (0, -2); arrow right at last box.e
EV:	box "Eval" at last box + (0, -2); arrow right at last box.e
SU:	box "Support" at last box + (0, -2); arrow right at last box.e
TR:	box "Tree" at last box + (0, -2); arrow right at last box.e
RE:	box "Reuse" at last box + (0, -2); arrow right at last box.e
TRA:	box "Trafo" at last box + (0, -2); arrow right at last box.e

	arrow from REX.se to SCA.nw
	arrow from LALR.se to ER.nw
	arrow from ELL.ne to PA.sw
	arrow from AG.e to EV.w
	arrow from AST.e to TR.w
	arrow from PUMA.e to TRA.w

	down
	arrow from SO + (boxwid * 0.5 + linewid, 0) to TRA + (boxwid * 0.5 + linewid, -1.5)
	circle "compile" "+ link"
	arrow
	box ".exe"
.PE
.sp
.ce
Fig. 2: Interaction and data flow among the tools
.)z
.pp
For a real user a more closer look than the one of Figure 1 is necessary. Figure 2
describes the actual interaction among the tools.
It describes the data flow starting from specifications and ending in
an executable compiler. Boxes represent files, circles represent tools, and arrows show the
data flow. The input specifications are contained in the files at the left-hand side.
The tools generate modules containing source code in the implementation languages
C or Modula-2. This modules are shown at the right-hand side. Every module conists
of two files with the following suffixes:
.ta 2c
.ip "implementation language C:"
\&.h	header or interface file
.br
\&.c	implementation part
.ip "implementation language Modula-2:"
\&.md	definition module
.br
\&.mi	implementation module
.pp
Files outside the left- and right-hand side columns contain intermediate data.
The various kinds of information in the files are distinguished by different file types
as explained in Table 2.
The few dependencies between tools are shown by the data flow via intermediate files.
These dependencies are explained in more detail in the next sections.
.(b L
.sp 0.5
.ce
Table 2: File Types
.sp 0.5
.TS
center box;
l | l.
Suffix	Meaning
_
\&.prs	scanner and parser specification (including S-attribution)
\&.scn	rest of scanner specification
\&.rpp	intermediate data: scanner description extracted from .prs
\&.rex	scanner specification understood by \fIrex\fP
\&.lrk	parser specification understood by \fIlark\fP
\&.ell	input for \fIell\fP (= input for \fPlark\fP with EBNF constructs)
\&.cg	input for \fIast\fP and \fIag\fP
\&.pum	input for \fIpuma\fP
\&.ST	intermediate data: storage assignment for attributes
\&.TS	intermediate data: description of attributed tree
_
\&.h	C source: header or interface file
\&.c	C source: implementation part
\&.md	Modula-2 source: definition module
\&.mi	Modula-2 source: implementation module
\&.exe	compiled and linked executable compiler
.TE
.)b
.sh 2 "Scanning and Parsing"
.lp
Three parser generators are contained in the toolbox.
First, the user has to decide which one to use.
I will not start arguing here in favour of one or the other grammar class.
If I am asked, I recommend to use LALR(1) grammars and the tool \fIlark\fP.
The parser generators and their common
input language (types .lrk and .ell) are documented in
"The Parser Generator Ell" and
.mc \(bv
"Lark - A LALR(2) Parser Generator With Backtracking".
.mc
From the syntactic point of view all three tools understand almost the same input language. The
only incompatibility concerns the different notation to access attributes. From the semantic
point of view there are of course differences with respect to the grammar class and the kind
of attribution evaluable during parsing. Whereas \fIlark\fP
accepts LALR(2) grammars and is able to evaluate an S-attribution (SAG) during
parsing, \fIell\fP accepts LL(1) grammars and is able to evaluate an L-attribution
(LAG). All, \fIlark\fP and \fIell\fP generate a module with the default
name \fIParser\fP which serves as basename for the file name, too. This module name can be
chosen freely using an appropriate directive in the input of the parser generators.
Both parser generators can also supply a module called \fIErrors\fP. This is a
simple prototype for handling error messages that just prints the messages.
However, it is recommended to use the more comfortable module \fIErrors\fP from the library
.i reuse .
In simple cases, this module is just linked to the user's program. If modifications are
necessary this module should be copied from the library along with its companion module
.i Position
into the user's directory. The module
.i Position
defines a data structure to describe source positions.
.pp
The scanner generator \fIrex\fP and its input language (type .rex) are documented in
"Rex - A Scanner Generator".
\fIrex\fP generates a module with the default name \fIScanner\fP which serves as basename
for the file name, too.
.i rex
can also generate a module called \fISource\fP which
isolates the task of providing input for the scanner.
By default it reads from a file or from standard input.
Again, it is recommended to use the module \fISource\fP from the library
.i reuse .
In simple cases, this module is just linked to the user's program. If modifications are
necessary or the module should provide input for a scanner with a name different to
.i Scanner
then this module must be requested from
.i rex .
.pp
It is possible to combine several scanners and parsers either generated by
.i lark
or
.i ell
into one program as long as different module names are chosen.
.pp
If the parser generator \fIell\fP is to be used, the inputs of \fIrex\fP and \fIell\fP have
to be specified in the languages directly understood by these tools (types .rex and .ell).
If the LALR(2) parser generator \fIlark\fP is to be used,
a more comfortable kind of input language is available. It is possible
to extract most of a scanner specification out of a parser grammar.
Therefore it is recommended to specify scanner and parser by two files of
types .scn and .prs. Further
advantageous of this approach are that concrete syntax, abstract syntax, and
attribute grammar are written in one common language (types .prs and .cg) and that the
attribution to be evaluated during parsing is written using named attributes.
This attribution is checked for completeness and whether it obeys the SAG property.
The language to describe concrete and abstract syntax is documented in:
"Ast - A Generator for Abstract Syntax Trees".
The addition of attribute declarations and attribute computations are documented in:
"Ag - An Attribute Evaluator Generator".
The use of this language especially as input for scanner and parser
generation is documented in:
"Preprocessors".
This document also describes the preprocessors \fIlpp\fP and \fIrpp\fP. \fIlpp\fP
converts input of type .prs into input directly understood by
\fIlark\fP (type .lrk) and it extracts most of the scanner specification which
is written on the intermediate file
named Scanner.rpp. The \fIrex\fP preprocessor \fIrpp\fP merges this extracted scanner
specification with additional parts provided by the user (type .scn) and produces
input directly understood by \fIrex\fP. The language in files of type .scn is an extension
of the input language of \fIrex\fP. These extensions are also documented in:
"Preprocessors".
.(z L
.sp 0.5
.ce
Table 3: Library Units Needed by Generated Modules
.sp 0.5
.TS
center box;
l | l | l | l.
Tool	Module	C	Modula-2
_
rex	Source	rSystem                 	rSystem
rex	Scanner	rSystem, General, Source,	rSystem, Checks, General, Strings, IO,
		DynArray, Position       	Pack, DynArray, Position, Source
lark	Parser	rMemory, DynArray, Sets,	Pack, DynArray, Sets, Strings, IO
		Position, Errors,          	Position, Errors
ell	Parser	Errors                    	rSystem, Strings, Position, Errors
ell	Errors	rSystem, Sets, Idents,     	rSystem, Strings, Idents, Sets, IO,
		Position                 	Position
reuse	Errors	rSystem, rMemory, Sets,     	rSystem, rMemory, Strings, StringM,
		Idents, Position          	Idents, Sets, IO, Position, Sort
ast	Tree	rSystem, General, rMemory,	rSystem, General, rMemory, DynArray,
		DynArray, StringM,      	IO, Layout, StringM, Strings,
	 	Idents, Sets, Position     	Idents, Texts, Sets, Position
ag	Eval	-                         	IO
puma	Trafo	rSystem, General          	rSystem, IO
.TE
.)z
.sh 2 "Semantic Analysis and Transformation"
.lp
Our preferred compiler design constructs an abstract syntax tree as underlying data structure
for semantic analysis. Afterwards this tree is usually mapped to some kind of intermediate
language by a phase termed transformation.
.pp
The syntax tree as central data structure is managed by the module \fITree\fP. This module
is generated by the tool \fIast\fP out of a specification in a file of type .cg.
The tool \fIast\fP and its input language are documented in:
"Ast - A Generator for Abstract Syntax Trees".
The construction of trees is usually done during parsing. It is specified within the semantic
actions of the input of the parser generator.
.(z L
.sp 0.5
.ce
Table 4: Modules in the Library Reuse
.sp 0.5
.TS
box center;
l | l | c | c.
Module	Task	C	Modula-2
_
rMemory	dynamic storage (heap) with free lists          	y	y
Heap	dynamic storage (heap) without free lists          	-	y
DynArray	dynamic and flexible arrays                    	y	y
Strings	string handling for single byte character strings	-	y
WStrings	string handling for double byte character strings	-	y
StringM	string memory                                   	y	y
Idents	identifier table - unambiguous encoding of strings	y	y
Lists	lists of arbitrary objects                             	-	y
Texts	texts are lists of strings (lines)                    	-	y
Sets	sets of scalar values (without run time checks)        	y	y
SetsC	sets of scalar values (with run time checks)          	-	y
HugeSets	sets of scalar values (up to 2**32)      	-	y
Relation	binary relations between scalar values         	-	y
RelatsC	binary relations of scalar values (with run time checks)	-	y
IO	buffered input and output                              	-	y
StdIO	buffered IO for standard files                    	-	y
Layout	more routines for input and output                    	-	y
Position	handling of source positions            	y	y
Errors	error handler for parsers and compilers            	y	y
Source	provides input for scanners                        	y	y
Sort	quicksort for arrays with elements of arbitrary type	-	y
Pack	compresses (scanner and parser) tables into strings	-	y
General	miscellaneous functions                              	y	y
rSystem	interface to the operating system                  	y	y
rString	portable string handling        	y	-
rGetopt	portable version of Unix getopt  	y	-
rFsearch	support for searching files	y	-
rSrcMem	storage for source code         	y	-
.TE
.)z
.pp
One possibility for the specification of semantic analysis is the use of an attribute grammar.
The tool \fIag\fP generates an evaluator module (named \fIEval\fP by default) out of an
attribute grammar. As this tool also has to know the structure of the abstract syntax tree
both, \fIast\fP and \fIag\fP usually process the same input file.
The tool \fIag\fP and the extensions to the input language of \fIast\fP for attribute
grammars are documented in:
"Ag - An Attribute Evaluator Generator".
.pp
The optimizer of \fIag\fP decides how to implement attributes. They can be either stored
in the tree or in global stacks or global variables. This information is communicated
from \fIag\fP to \fIast\fP in files of type .ST. (This feature is not implemented yet.)
.pp
The tool \fIpuma\fP generates transformers (named \fITrafo\fP by default) that map
attributed trees to arbitrary output. As this tool also has to know about the structure
of the tree this information is communicated from \fIast\fP to \fIpuma\fP via a file
of type .TS. The tool \fIpuma\fP and its input language are documented in:
"Puma - A Generator for the Transformation of Attributed Trees".
.pp
The names of the modules produced by the tools \fIast\fP, \fIag\fP, and \fIpuma\fP can be
controlled by directives in the
input. Figure 2 uses the default names. By chosing different names it is possible
to combine several tree modules, attribute evaluators, and transformers in one program.
.sh 2 "Compiling and Linking"
.lp
All the source modules generated by the tools have to be compiled by a compiler appropriate
for the implementation language (C or Modula-2). Additional hand-written modules can be added
as necessary. In Figure 2 the module \fISupport\fP indicates this possibility.
In the last step all binaries have to be linked together with a few modules of the
library \fIreuse\fP to yield an executable compiler.
.pp
The use of modules from the library \fIreuse\fP depends on the implementation language and
the used tools. There is a C and a Modula-2 version of this library.
The Modula-2 version is documented in:
"Reusable Software - A Collection of Modula-2-Modules".
The C version is documented in:
"Reusable Software - A Collection of C-Modules".
Table 3 lists the library units needed by tool generated modules.
Additionally the user may engage further modules from this library for various tasks.
Table 4 lists the modules that might be of interest. The right-hand side columns describe the
availability of the modules with regard to the implementation language.
.sh 1 Makefile
.lp
.mc \(bv
The tools of the toolbox are conveniently controlled by an appropriate makefile.
This eases the invocation of the tools and minimizes
.mc
the amount of regeneration after changes. Figure 2 can be used to derive a makefile because
it describes most of the dependencies among tools and files. The following makefiles control
.mc \(bv
the generation of compilers for the example language MiniLAX in the target
languages C, C++, and Modula-2.
.mc
The annotated specification of this language is documented in:
"Specification of a MiniLAX-Interpreter".
The makefiles are examples a user can start with.
.pp
The makefiles in the next sections deviate in the following from the fundamental structure
presented in Figure 2:
.ip -
The attribute evaluator module is called \fISemantic\fP instead of \fIEval\fP.
.ip -
The transformation module is called \fIICode\fP instead of \fITrafo\fP.
.ip -
The hand-written modules are called \fIICodeInt\fP and \fIminilax\fP.
The latter constitutes the main program.
.ip -
There are two support modules for semantic analysis called \fIDefs\fP and
\fITypes\fP. These are generated by tools (\fIast/cg\fP and \fIpuma\fP), too.
.sh 2 C
.lp
The macro LIB specifies the directory where the compiled library \fIreuse\fP is
located. The name of this library is \fIlibreuse.a\fP.
The -I flag in the macro CFLAGS specifies the directory where the header files
of the library modules are located.
.pp
The first command (target minilax) is for linking the compiled modules to an
executable compiler. The succeeding entries describe the dependencies during the
generation phase and the invocation of the tools.
.mc \(bv
The dependencies before the target clean are those needed during compilation.
.bp
.mc
.nf
.FT
LIB     = $(HOME)/lib
INCDIR  = $(LIB)/include
CFLAGS  = -I$(INCDIR)
CC      = cc
.sp 0.5
.mc \(bv
OBJS    = minilax.o Scanner.o Parser.o Tree.o \\
.mc
          Types.o Defs.o Semantic.o ICode.o ICodeInt.o
.sp 0.5
.mc \(bv
minilax:        $(OBJS)
        $(CC) $(CFLAGS) $(OBJS) $(LIB)/libreuse.a -o minilax -lm
.mc
.sp 0.5
Scanner.rpp Parser.lrk:        minilax.prs
.mc \(bv
        lpp -cxzj minilax.prs
.mc
.sp 0.5
minilax.rex:    minilax.scn Scanner.rpp
.mc \(bv
        rpp < minilax.scn > minilax.rex
.mc
.sp 0.5
Scanner.h Scanner.c:    minilax.rex
.mc \(bv
        rex -cd minilax.rex
.mc
.sp 0.5
Parser.h Parser.c:      Parser.lrk
.mc \(bv
        lark -cdi Parser.lrk
.mc
.sp 0.5
Tree.h Tree.c:  minilax.cg
.mc \(bv
        ast -cdimRDI0 minilax.cg
.mc
.sp 0.5
Semantic.h Semantic.c:        minilax.cg
.mc \(bv
        ag -cDI0 minilax.cg
.mc
.sp 0.5
Defs.h Defs.c Defs.TS:     Defs.cg
.mc \(bv
        ast -cdim4 Defs.cg
.mc
.sp 0.5
Tree.TS:        minilax.cg
.mc \(bv
        echo SELECT AbstractSyntax Output | cat - minilax.cg | ast -c4
.mc
.sp 0.5
Types.h Types.c:        Types.pum Tree.TS
.mc \(bv
        puma -cdipk Types.pum
.mc
.sp 0.5
ICode.h ICode.c:        ICode.pum Tree.TS Defs.TS
.mc \(bv
        puma -cdi ICode.pum
.mc
.sp 0.5
Parser.o:       Parser.h Scanner.h Tree.h Types.h Defs.h
Semantic.o:     Semantic.h Tree.h Defs.h Types.h
Tree.o:         Tree.h
Defs.o:         Defs.h Tree.h
Types.o:        Tree.h Types.h
ICode.o:        Tree.h Types.h ICodeInt.h
minilax.o:      Scanner.h Parser.h Tree.h Semantic.h Defs.h ICode.h \\
                ICodeInt.h Types.o
.sp 0.5
clean:
        rm -f Scan*.? Parser.? Tree.? Sema*.? Defi*.? Types.? ICode.? *.TS
        rm -f core _Debug minilax mini*.rex Parser.lrk Scan*.rpp yy*.h *.o
.sp 0.5
\&.c.o:
.mc \(bv
        $(CC) $(CFLAGS) -c $*.c
.FR
.fi
.sh 2 C++
.lp
The macro LIB specifies the directory where the compiled library \fIreuse\fP is
located. The name of this library is \fIlibrucpp.a\fP.
The -I flag in the macro CFLAGS specifies the directory where the header files
of the library modules are located.
.pp
The first command (target minilax) is for linking the compiled modules to an
executable compiler. The succeeding entries describe the dependencies during the
generation phase and the invocation of the tools.
The dependencies before the target clean are those needed during compilation.
.sp
.nf
.FT
LIB     = $(HOME)/lib
INCDIR  = $(LIB)/cplusinc
CFLAGS  = -I$(INCDIR)
CPPC    = g++
.sp 0.5
OBJS    = minilax.o Scanner.o Parser.o Tree.o \\
          Defs.o Types.o Semantic.o ICode.o ICodeInt.o
.sp 0.5
minilax:        $(OBJS)
        $(CPPC) -o minilax $(OBJS) -lm $(LIB)/librucpp.a
.sp 0.5
Scanner.rpp Parser.lrk: minilax.prs
        lpp -c++xzj minilax.prs
.sp 0.5
minilax.rex:    minilax.scn Scanner.rpp
        rpp < minilax.scn > minilax.rex
.sp 0.5
Scanner.h Scanner.cxx:  minilax.rex
        rex -c++d minilax.rex
.sp 0.5
Parser.h Parser.cxx:    Parser.lrk
        lark -c++dis Parser.lrk
.sp 0.5
Tree.h Tree.cxx:        minilax.cg
        ast -c++dimRDI0 -e minilax.cg
.sp 0.5
Semantic.h Semantic.cxx:        minilax.cg
        ag -c++DI0 minilax.cg
.sp 0.5
Defs.h Defs.cxx Defs.TS:        Defs.cg
        ast -c++dim4 Defs.cg
.sp 0.5
Tree.TS:        minilax.cg
        echo SELECT AbstractSyntax Output | cat - minilax.cg | ast -c++4
.sp 0.5
Types.h Types.cxx:      Types.pum Tree.TS
        puma -c++dipku Types.pum
.sp 0.5
ICode.h ICode.cxx:      ICode.pum Tree.TS Defs.TS
        puma -c++diu ICode.pum
.sp 0.5
Defs.o:         Defs.cxx Defs.h Tree.h Types.h
ICode.o:        ICode.cxx ICode.h Tree.h Defs.h Types.h ICodeInt.h
ICodeInt.o:     ICodeInt.cxx ICodeInt.h
Parser.o:       Parser.cxx Parser.h Scanner.h Tree.h Defs.h Types.h
Scanner.o:      Scanner.cxx Scanner.h
Semantic.o:     Semantic.cxx Semantic.h Tree.h Defs.h Types.h
Tree.o:         Tree.cxx Tree.h Defs.h Types.h
Types.o:        Types.cxx Types.h Tree.h Defs.h
minilax.o:      minilax.cxx Parser.h Scanner.h Tree.h Defs.h Types.h \\
                Semantic.h ICode.h ICodeInt.h
.sp 0.5
clean:
        rm -f Scanner.*[hcx] Parser.*[hcx] Tree.*[hcx] Semantic.*[hcx] \\
           Defs.*[hcx] Types.*[hcx] ICode.*[hcx] *.TS \\
           core* *.dbg minilax minilax.rex Parser.lrk Scanner.rpp yy*.h *.o
.sp 0.5
.SUFFIXES:      .cxx .o
.sp 0.5
\&.cxx.o:
        $(CPPC) $(CFLAGS) -c $*.cxx
.mc
.FR
.fi
.bp
.sh 2 Modula-2
.lp
The first command (target minilax) describes compilation and linking using the GMD Modula-2
compiler MOCKA. This compiler does its own dependency analysis among the sources. Therefore
the makefile does not contain any dependency descriptions between sources and binaries.
The -d flag of the compiler call mc specifies the directory where the library \fI reuse\fP is
located. The rest of the makefile describes the generation phase and the invocation of the
tools.
.sp
.nf
.FT
SOURCES = Scanner.md Scanner.mi Parser.md Parser.mi \\
          Tree.md Tree.mi Semantic.md Semantic.mi \\
          Types.md Types.mi Defs.md Defs.mi \\
          ICode.md ICode.mi ICodeInt.md ICodeInt.mi minilax.mi

minilax:        $(SOURCES)
        echo p minilax | mc -d ../../reuse/src

Scanner.rpp Parser.lrk:        minilax.prs
.mc \(bv
        lpp -xzj minilax.prs
.mc

minilax.rex:    minilax.scn Scanner.rpp
.mc \(bv
        rpp < minilax.scn > minilax.rex
.mc

Scanner.md Scanner.mi:      minilax.rex
.mc \(bv
        rex -d minilax.rex
.mc

Parser.md Parser.mi: Parser.lrk
.mc \(bv
        lark -ci Parser.lrk
.mc

Tree.md Tree.mi:        minilax.cg
.mc \(bv
        ast -dimRDI0 minilax.cg
.mc

Semantic.md Semantic.mi:      minilax.cg
.mc \(bv
        ag -DI0 minilax.cg
.mc

Defs.md Defs.mi Defs.TS:   Defs.cg
.mc \(bv
        ast -dim4 Defs.cg
.mc

Tree.TS:        minilax.cg
.mc \(bv
        echo SELECT AbstractSyntax Output | cat - minilax.cg | ast -4
.mc

Types.md Types.mi:      Types.pum Tree.TS
.mc \(bv
        puma -dipk Types.pum
.mc

ICode.md ICode.mi:      ICode.pum Tree.TS Defs.TS
.mc \(bv
        puma -di ICode.pum
.mc

clean:
        rm -f Scan*.m? Parser.m? Tree.m? Sema*.m? Defi*.m? Types.m? ICode.m?
        rm -f core *.TS *.[dimor] _Debug minilax mini*.rex Parser.lrk
        rm -f Scan*.rpp
.FR
.fi
.bp 1
.lp
.b Contents
.sp
.xp
