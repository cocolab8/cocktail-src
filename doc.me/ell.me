.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.ds ], , 
.EQ
gsize 12
delim $$
.EN
.de FR
.ft R
.sz +2
..
.T0


	Efficient and Comfortable
	Error Recovery in
	Recursive Descent Parsers

	J. Grosch

.T1
.T2 "" "Efficient and Comfortable Error Recovery in Recursive Descent Parsers" "Josef Grosch" "Dec. 11, 1989" 19 1994
.bp 1
.ce 99
.b "Efficient and Comfortable Error Recovery in Recursive Descent Parsers"
.ce 0
.sp 2
.uh Abstract
.pp
This paper describes the interesting features of the recursive descent
parser generator
.i Ell
from the user's point of view. Some of the interesting implementation
aspects are discussed. The
generated parsers are extremely fast and run at speed of 55,000 tokens per
second or 900,000 lines per minute on a MC 68020 processor. The outstanding
features of
.i Ell
are the L-attribution mechanism, its ability to handle non LL(1) grammars,
and its comfortable error handling, which includes error reporting,
recovery, and repair.
.sh 1 Introduction
.pp
Recursive descent parsing is an established technique for the analysis of
LL(1) languages since many years.
.\" It is described in every text book on compiler construction.
It can be implemented easily by a hand-written program or by using one of the
existing parser generators such as\*([<\*([[DuW81\*(],Gra88a\*(],ReM85\*(]]\*(>].
In real life applications, issues such as good quality error recovery and
high run time performance are essential. These requirements are
rarely discussed in the literature and seldom achieved by the existing
parser generators. This explains the reasons for implementing yet another
LL(1) parser generator and to describe some details of the generated code.
.pp
This paper presents how comfortable features like error recovery, error
repair, and L-attribution are implemented in the high performance parsers
generated by the parser generator
.i Ell
\*([[Gro88\*(],GrV\*(]].
.i Ell
generates recursive descent parsers from LL(1) grammars given
in extended BNF. The grammar rules may be associated with semantic actions
consisting of arbitrary statements which are executed whenever they are
passed during a left-to-right parse. An L-attribution may be evaluated
during parsing.
.i Ell
offers possibilities to resolve the LL(1) conflicts of non LL(1) grammars.
The generated parsers automatically include error reporting, recovery, and
repair. Parsers can be generated in the target languages C and Modula-2. The
parsers are extremely fast and run at speed of 55,000 tokens per
second or 900,000 lines per minute on a MC 68020 processor.
.pp
This paper addresses only the interesting features of
.i Ell .
The mechanism for L-attribution and the error recovery are described from
the user's point of view as well as from the implementation view. We
also present how LL(1) conflicts are resolved and discuss further
implementation issues such as testing for set membership or the pitfalls of
CASE (switch) statements. The examples are taken from a parser for Modula-2 and also
use Modula-2 as target language.
.sh 1 "L-Attribution"
.pp
According to\*([<\*([[Wil79\*(]]\*(>] an attribute grammar which can be evaluated
during LL(1)-parsing is called an L-attributed grammar. The notion
L-attribution means that all attributes can be evaluated in a single top-down
left-to-right tree walk.
.sh 2 "User's View"
.pp
The specification language of
.i Ell
distinguishes three kinds of grammar symbols: nonterminals, terminals, and
literals. Literals are similar to terminals and are denoted by strings.
Terminals and
nonterminals are denoted by identifiers. Terminals and nonterminals can be
associated with arbitrary many attributes of arbitrary types. The
computation of the attribute values takes place in the semantic action parts
of a rule. The attributes are accessed by an attribute designator which
consists of the name of the grammar symbol, a dot character, and the name of
the attribute. As several grammar symbols with the same name can occur
within a rule, the grammar symbols are denoted unambiguously by appending
numbers to their names. The left-hand side symbol always receives the number
zero. For every (outermost) alternative of the right-hand side, the symbols
with the same name are counted starting from one.
.(b
Example:
.sp 0.5
.FT
expr    : ( [ '+' ] term { expr0.value :=   term1.value;                }
          | '-' term     { expr0.value := - term2.value;                }
          )
          ( '+' term     { INC (expr0.value, term3.value);              }
          | '-' term     { DEC (expr0.value, term4.value);              }
          ) *
        .
term    : fact           { term0.value := fact1.value;                  }
          ( '*' fact     { term0.value := term0.value * fact2.value;    }
          | '/' fact     { term0.value := term0.value DIV fact3.value;  }
          ) *
        .
fact    : const          { fact0.value := const1.value;                 }
        | '(' expr ')'   { fact0.value := expr1.value;                  }
        .
.)b
.pp
The above example specifies the evaluation of simple arithmetic expressions
using one attribute called
.i value .
The operator "*" denotes repetition zero, once, or more times.
The attributes have to be declared as members of a record type called
.i tParsAttribute .
.(b
Example:
.sp 0.5
.FT
TYPE tParsAttribute = RECORD value: INTEGER; END;
.)b
.sh 2 Implementation
.pp
The implementation of the L-attribution in the generated parsers is very
simple. As usual, every nonterminal is analyzed by a procedure. Every
procedure has one (reference) parameter referring to the left-hand side
attributes. As all attributes are declared as members of one (record)
type, one parameter suffices to pass an arbitrary number of attributes.
For all right-hand side symbols with attributes, local variables are declared.
This solution provides very efficient stacking of attributes via the usual
procedure call mechanism. Stacking is necessary for the attribute evaluation
of recursive grammar rules.
.(b
Example:
.sp 0.5
.FT
PROCEDURE expr (...; VAR expr0: tParsAttribute);
VAR term1, term2, term3, term4: tParsAttribute;
BEGIN
\&   ...
END expr;
.)b
.sh 1 "Non LL(1) Grammars"
.pp
Sometimes grammars do not obey the LL(1) property. They are said to
contain LL(1) conflicts. A well-known example is the dangling-else problem
of Pascal: in case of nested it-then-else statements it may not be clear to
which IF an ELSE belongs. It is very easy to solve this conflicts in
hand-written solutions.
.i Ell
handles LL(1) conflicts in the following ways:
.ip -
Several alternatives (operator |) cause a conflict if their
FIRST sets are not disjoint: the alternative given first is selected.
.ip -
An optional part (operators [] and *) causes a conflict if its FIRST set is
not disjoint from its FOLLOW set: the optional part will be analyzed because
otherwise it would be useless.
.ip -
Parts that may be repeated at least once cause a conflict if their FIRST and
FOLLOW sets are not disjoint (as above): the repetition will be continued
because otherwise it would be executed only once.
.pp
With the above rules it can happen that alternatives are never taken or that
it is impossible for a repetition to terminate for any correct input. These
cases as well as left recursion are considered to be serious design faults in
the grammar and are reported as errors. Otherwise LL(1) conflicts are
resolved as described above and reported as warnings.
.sh 1 "Error Recovery"
.sh 2 "User's View"
.(z L
.vs 12
Source Program:
.sp 0.5
.FT
MODULE test;
BEGIN
   IF (a = ] 1 write (a) END;
END test.
.sp 0.5
.FR
Error Messages:
.sp 0.5
.FT
3, 12: Error       syntax error
3, 12: Information expected symbols: Ident Integer Real String '(' '+' '-' '{' 'NOT' 
3, 14: Information restart point
3, 16: Error       syntax error
3, 16: Information restart point
3, 16: Repair      symbol inserted : ')'
3, 16: Repair      symbol inserted : 'THEN'

.FR
Fig. 1: Example of Automatic Error Messages
.)z
.pp
The generated parsers include information and program code to handle syntax
errors completely automatically and provide expressive error
reporting, recovery, and repair. Every incorrect input
is "virtually" transformed into a syntactically correct program with the
consequence of executing only a "correct" sequence of semantic actions.
Therefore the following compiler phases like semantic analysis don't have to
bother with syntax errors. \fIEll\fP provides a prototype error module which
prints messages as shown in Figure 1.
Appendix 4 contains a larger example demonstrating the behaviour of our method.
Internally the error recovery works as follows:
.ip - 0.5c
The location of the syntax error is reported.
.ip - 0.5c
If possible, the tokens that would be a legal continuation of the program are reported.
.ip - 0.5c
The tokens that can serve to continue parsing are computed. A minimal
sequence of tokens is skipped until one of these tokens is found.
.ip - 0.5c
The recovery location (restart point) is reported.
.ip - 0.5c
Parsing continues in the so-called repair mode. In this mode the parser
behaves as usual except that no tokens are read from the input. Instead a
minimal sequence of tokens is synthesized to repair the error.
The parser stays in this mode until the input token can be accepted.
The synthesized tokens are reported as inserted symbols.
The program can be regarded as
repaired, if the skipped tokens are replaced by the synthesized ones.
Upon leaving repair mode, parsing continues as usual.
.sh 2 Implementation
.pp
During LL(1) analysis the following kinds of syntax errors can occur: at the analysis
of a terminal the current (look-ahead) token can be different from the expected terminal.
At the analysis of alternatives the current token can be
member of none of the FIRST sets of the possible branches.
At the analysis of optional or iterated parts the current token can be
member of neither the FIRST set nor the FOLLOW set of the construct.
In order to achieve good quality error recovery, the latter test has to be
performed before the analysis of an optional part and before every iteration.
This section discusses the interesting aspects of error recovery:
how the sets of expected tokens are defined,
how parsing is continued after syntax errors,
how error repair works,
and how an efficient implementation is achieved.
.sh 3 "Expected Symbols"
.pp
At the location of a syntax error, we try to report the set of expected tokens.
To be able to report the exact set of expected tokens, syntax errors have to be detected as
early as possible. Furthermore, information must be maintained during parsing because the
exact sets depend on the dynamic call hierarchy. Early detection of errors requires the
knowledge of the exact FOLLOW sets which also depend on the call hierarchy.
In order to gain efficiency, we report only the subset of the expected tokens
which can be computed at generation time.
This set is necessary for every potential error location. In case of a
terminal the expected token is just this terminal. In case of alternatives
the set of expected tokens is the union of the FIRST sets of the alternatives.
In case of optional or iterated parts the set of expected tokens is the union
of the FIRST set and of the local FOLLOW set of the construct.
All the sets are computed at generation time and stored in the generated parsers.
.sh 3 "Recovery Sets"
.pp
For every possible syntax error a so-called recovery set is determined
containing the tokens where parsing can continue. We present the
definition of recovery sets for plain BNF, first.
Appendix 3 shows the extension to extended BNF using an attribute grammar formalism.
In case of a syntax error the situation is as follows (see Fig. 2):
.ip -
Analysis of the productions $ p sub 1 , ... ,~p sub n $ has started.
.ip -
Every production $ p sub i $ is processed by a procedure called $ X sub i $.
.ip -
Every procedure $ X sub i $ calls a procedure $ X sub i+1 $ to analyze a
nonterminal of the right-hand side.
.ip -
Procedure $ X sub n $  detects an error at position $ Z $.
.ip -
The current call hierarchy is $ X sub 1 , ... ,~X sub n $.
.sp
.(b L
.TS
tab(;) center;
l l l l l l l l l l.
$p sub 1 :$;$X sub 1$;\(->;$Y sub 11$;...;;$X sub 2$;$Y sub 1j sub 1$;...;$Y sub 1n sub 1$
$p sub 2 :$;$X sub 2$;\(->;$Y sub 21$;...;;$X sub 3$;$Y sub 2j sub 2$;...;$Y sub 2n sub 2$
\&...
$p sub n-1 :$;$X sub n-1$;\(->;$Y sub n-1,1$;...;$Y sub n-1,i sub n-1$;$X sub n$;$Y sub n-1,j sub n-1$;...;$Y sub n-1,n sub n-1$
$p sub n :$;$X sub n$;\(->;$Y sub n1$;...;$Y sub ni sub n$;$Z$;$Y sub nj sub n$;...;$Y sub nn sub n$
.TE
.sp
.ce
Fig. 2: Situation in case of a syntax error ($p sub i~\(mo~P$, $X sub i~\(mo~N$, $Y sub ij~\(mo~V$, $Z~\(mo V$)
.)b
.pp
Let us concentrate first on the situation locally in production $ p sub n $.
Parsing could continue at the symbols $Y sub nj sub n , ... ,~Y sub nn sub n$.
The set of tokens that allow to continue parsing, or in other words the local
recovery set $ R sub n $ is therefore the union of the FIRST sets of
$Y sub nj sub n , ... ,~Y sub nn sub n$:
.EQ
R sub n~=~union from {k=j sub n} to {n sub n}~FIRST~( Y sub nk )
.EN
.pp
However, in general there may be no token behind the location of the error
which is member of the local recovery set $ R sub n $. Therefore, the
productions $ p sub n-1 , ... ,~p sub 1 $ have to be taken into account, too.
Parsing can continue at all symbols not analyzed yet:
.sp
.TS
tab(;) center;
l l l.
$Y sub n-1,j sub n-1$;...;$Y sub n-1,n sub n-1$
;...
$Y sub 2j sub 2$;...;$Y sub 2n sub 2$
$Y sub 1j sub 1$;...;$Y sub 1n sub 1$
.TE
.sp
Therefore in general we need all local recovery sets $ R sub i $:
.EQ
R sub i~=~union from {k=j sub i} to {n sub i}~FIRST~( Y sub ik )~~~~~i~=~1 , ... ,~n
.EN
The global recovery set $ R $ is the union of all involved local recovery
sets:
.EQ
R~=~union from i=1 to n~R sub i
.EN
.pp
The global recovery set $ R $ is used to stop skipping of tokens. Tokens are
skipped until one is reached that is member of $ R $. This location is
called a restart point. This method of recovery terminates because only
symbols not yet analyzed are considered as potential restart points. Their
processing is contained in the current call hierarchy.
.pp
In extreme cases the complete rest of the input is skipped. To guarantee
termination of skipping, a special token for end of file (\fC\s-2sEof\s+2\fP)
has to be member of $ R $.
This is assured by augmenting the grammar by the following rule:
.EQ
p sub 0 :~X sub 0~\(->~X sub 1~\fCsEof\fP
.EN
where $ X sub 1 $ is the original and $ X sub 0 $ is the new start symbol of
the grammar.
.pp
The definition of $ R $ can be modified in some ways. First, if the
symbol $ Z $ is a terminal it can be included in $ R $ in order to improve the
behaviour of error recovery in case of superfluous tokens. Second,
it is possible to exclude some elements (except \fC\s-2sEof\s+2\fP) from $ R $
without causing the recovery to fail. However, its behaviour becomes more
coarse because eventually more tokens are skipped. If only
\fC\s-2sEof\s+2\fP remains in $ R $, we arrive at panic mode:
after skipping the rest of the input no more errors can be found.
.pp
The computation of the global recovery set $ R $ can consume a considerable
amount of run time. For efficiency reasons, we found the following solution
quite satisfactory:
The local recovery sets can be computed at generation time. For every
right-hand side symbol (or position) a local recovery set is computed and
stored.
The global recovery set has to be computed at run time, as it depends on
the current call hierarchy. The union of the local recovery sets is computed
only in the case of an error. As long as there is no error, it suffices to
maintain a simple data structure that allows to compute the union on demand.
.pp
If the local recovery sets are stored in an array of sets it is enough to
know the index of a set in this array. The global restart set is represented
as a list of such indices. This list allows to effectively compute the
global restart set whenever needed.
.pp
A list representing the global restart set is passed via a second parameter
to every procedure. In case of an error, the local recovery set is added to
the list and then the real set union is accomplished. Before calling another
procedure to analyze a nonterminal, the list is extended by a suitable
element. The list elements are declared as local variable of the procedures.
This way, allocation and deallocation of storage is for free.
For details see Fig. 3 as well as Appendix 1.
.(z
.FT 
TYPE tUnionPtr  = POINTER TO tUnion;
TYPE tUnion     = RECORD             (* type for list elements             *)
                    GlobalRecoverySet   : tUnionPtr;
                    LocalRecoverySet    : SHORTCARD;
                  END;
                                     (* procedure for a nonterminal        *)
PROCEDURE Module (GlobalRecoverySet: tUnionPtr; VAR Module0: tParsAttribute);
VAR
  Union : tUnion;
  Ident1: tScanAttribute;
  Block1: tParsAttribute;
  ...
BEGIN
  Union.GlobalRecoverySet := GlobalRecoverySet;
.sp 0.5
  IF Token # sMODULE THEN            (* analysis of a literal              *)
    RecoveryLiteral (sMODULE, 138, GlobalRecoverySet);
  ELSE
    Token := GetToken (); IsRepairMode := FALSE;
  END;
.sp 0.5
  IF Token # sIdent THEN             (* analysis of an attributed terminal *)
    RecoveryTerminal (sIdent, 138, GlobalRecoverySet, Ident1);
  ELSE
    Ident1 := Attribute;             (* receive attribute from scanner     *)
    Token := GetToken (); IsRepairMode := FALSE;
  END;
.sp 0.5
  Union.LocalRecoverySet := 57;      (* analysis of a nonterminal          *)
  Block (SYSTEM.ADR (Union), Block1);
.sp 0.5
END Module;

.FR
Fig. 3: Scheme of the Code for Error Recovery
.)z
.sh 3 "Error Repair"
.pp
Every incorrect program is repaired (or transformed) into a syntactically
correct program. Error repair is accomplished by skipping tokens as
described above and by imaginary inserting tokens. This insertion is
realized relatively easy by continuing parsing as nothing would have
happened. Whenever a terminal is expected which is different from the
current input token, it is reported as inserted. Whenever alternatives are
analyzed and the current input token is member of none of the possible FIRST
sets, an arbitrary branch, which is non-recursive, is selected. The
restriction to non-recursive branches is necessary to guarantee
termination. There always exists a non-recursive branch as long as the
grammar is reduced. Semantic actions are executed during error repair as usual.
.pp
Error recovery and error repair is combined in mainly three procedures to handle
literals, terminals, and alternatives or EBNF constructs, respectively (see Appendix 2).
To avoid superfluous error messages the parser knows two modes. In
.i normal
mode errors are reported, tokens are skipped, and the mode is changed to
.i repair
mode. In
.i repair
mode neither errors are reported nor tokens are skipped. Instead the
inserted tokens are reported. The mode is switched back to normal when the
analysis of a terminal is successful. Then error recovery is finished and
parsing continues normally.
.pp
The local variable \fC\s-2Union\s+2\fP is a list element for the
representation of
the global recovery set. It suffices to append this element to the list once
in every procedure. Before calling another procedure to analyze a
nonterminal the index of a local recovery set is assigned to the list
element (here: 57). The extended list is passed as parameter.
The procedures for error recovery called
ErrorRecovery, RecoveryTerminal, and RecoveryLiteral
are given in Appendix 2. They are called only in case of syntax errors.
As errors are considered to be a rare event, these procedures do not have to
care about efficiency. Their parameters describe the expected token
(here: \fC\s-2sMODULE\s+2\fP and \fC\s-2sIdent\s+2\fP), the index of the local recovery
set (here: 138), and the global recovery set. For attributed terminals
a fourth parameter specifies the variable receiving the attributes
from the scanner. The interface to the scanner consists primarily of the
following objects: the procedure GetToken returns the next input token, the
global variable Attribute contains the attributes of the current token, and
the procedure ErrorAttribute (see Appendix 2) is called by the parser to get
attribute values for synthesized tokens.
.sh 1 "Related Work"
.pp
Much work has been published about error recovery. We limit this discussion on giving reasons
for our solution and mention a few similar methods.
The design of our error recovery was guided by the following requirements:
.ip -
automatic derivation of error recovery from the grammar
.ip -
efficient parsing in terms of run time
.ip -
provision of error repair
.pp
Efficiency implies a backtrack-free strategy and asks for a clever implementation.
Automatic derivation and a backtrack-free strategy imply more or less the definition of
recovery sets as given above.
.pp
We consider error repair to be important because error recovery should not consider
syntactical aspects only. Syntax analysis is usually combined with semantic analysis.
Although error repair might not transform an error the way the programmer originally intended,
it does transform every erroneous program into a syntactically correct one with the
consequence that only syntactically correct information is passed to semantic analysis. This
allows great simplifications in the latter because it does not have to care about syntax
errors.
.pp
The definition for the recovery sets given above is not new as it is somehow inherent in the
problem. Similar definitions have been presented previously e. g. by
\*([[Iro63\*(],ReM85\*(],SMM84\*(]].
Hand-written recursive descent parsers usually implement similar designs
\*([[Wir86\*(]]. The advantages of our solution are the provision of error
repair and the efficient implementation of error recovery. The compiler generators Coco
\*([[ReM85\*(]] and Coco/R\*([<\*([[M\\90\*(]]\*(>] use the same strategy for error recovery
but do not provide error repair. The efficiency of the parsers generated by Coco/R
is comparable to the efficiency of our method.
Using Coco/R, error recovery has to be tailored by giving simple directives.
.i Ell
does not require any user engagement and produces error recovery automatically. Appendix 4
presents the behaviour of our method applied to the example program used in\*([<\*([[M\\90\*(]]\*(>].
The rather long listing of messages is the direct output of the information provided by the
parser. The final layout of the messages can be easily adapted to the ideas of the user.
.sh 1 "Implementation Issues"
.pp
Parsing is implemented using recursive procedures as outlined above. The operators
of extended BNF are mapped to statements of the target language as given in Appendix 1.
In obvious cases simple optimizations are exploited. For example
the checks for terminals and literals can be omitted in some cases.
.pp
More sophisticated implementation decisions concern the CASE/switch statements
and the test for set membership. If C is used as target language,
it turned out that many C compilers optimize
switch statements in favour of storage. If the set of case labels is
non-compact, a sorted list of values and addresses is generated. A run time
system routine performs binary search in this table in order to map the
current switch value to the address of a case branch.
To trick the C compiler,
.i Ell
inserts dummy labels to make the set of case labels compact. Then the C compilers
use a jump table which executes considerably faster. Generating compact
sets of case labels improved the over all run time of the parsers by 30%.
.(z L
.sp 0.5
.PS
scale	= 2.54
define set #
	right
	box invis $1 wid boxwid/2
	box; box; box; box; box; box
#
define dbox #
	box
	line from last box.sw + (boxwid * 0.00, 0) to last box.nw + (boxwid * 0.25, 0)
	line from last box.sw + (boxwid * 0.25, 0) to last box.nw + (boxwid * 0.50, 0)
	line from last box.sw + (boxwid * 0.50, 0) to last box.nw + (boxwid * 0.75, 0)
	line from last box.sw + (boxwid * 0.75, 0) to last box.nw + (boxwid * 1.00, 0)
	move down boxht * 0.5; right
#
define dset #
	right
	box invis $1 wid boxwid/2
	dbox(); dbox(); dbox(); dbox(); dbox(); dbox()
#
boxwid	= 2.0
boxht	= 1.0

	move to (0,  1)
	box invis wid boxwid/2
	box invis "0"
	box invis "1"
	box invis
	box invis "e / 32"
	box invis
	box invis "k"

	move to (0, -0)
	set("0")
	move to (0, -1)
	set("1")
	move right 1
	" word (BITSET)" ljust
	move to (0, -2)
	set()
	move right 1
	" element (bit)" ljust
	move to (0, -3)
	dset("i")
	move right 1
	" set" ljust
	move to (0, -4)
	set()
	move to (0, -5)
	set("n")
.sz -4
	"0"	at (7.15, -2.35)
	"e mod 32"	at (8.00, -2.35)
	"31"	at (8.75, -2.35)
.sz +4
	line from (12, -1) to (14, -1)
	line from ( 8, -3) to (14, -2)
	line from (12, -3) to (14, -3)

	line from (7.95, -2.5) to (7.95, -3.5)
	line from (8.05, -2.5) to (8.05, -3.5)
.PE
.sp 2
.ce
Fig. 4: horizontal set
.)z
.pp
Sets are implemented as bit vectors if they contain more than one element.
In general an array of memory words is needed to store the bits of one set
(see Fig. 4). The membership test would be coded as follows:
.(b
.FT
Seti: ARRAY [0..k] OF BITSET;
.sp 0.5
e \(mo Seti   \(==   (e MOD 32) IN Seti [e DIV 32]
.)b
On a MC 68020 processor this produces the following six machine instructions
including two divide instructions:
.(b
.FT
        movl    _e:l,d1
        divsll  #0x20,d2:d1
        movl    _e:l,d3
        divsl   #0x20,d3
        movl    (_Set:l,d3:w:4),d3
        btst    d2,d3
.)b
.(z L
.sp 0.5
.PS
define word #
	box invis $1 wid boxwid/2
	right
	box
	line from last box.n + (0.1, 0) to last box.s + (0.1, 0)
	line from last box.n to last box.s
	move to last box.e
#
boxwid	= 2.0
boxht	= 1.0

.sz -2
	move to (0, 0.65)
	box invis wid boxwid/2
	box invis "0        i      31"
.sz +2
	move to (0,  0)
	word("0")
	move to (0, -1)
	word("1")
	move to (0, -2)
	word()
	move right 1
	" word (BITSET)" ljust
	move to (0, -3)
	word("e")
	move right 1
	" element (bit)" ljust
	move to (0, -4)
	word()
	move right 1
	" set" ljust
	move to (0, -5)
	word("m")

	line from (2.50, -2) to (4, -2)
	line from (2.05, -3) to (4, -3)
	line from (2.05, -4) to (4, -4)

	line from (2.05, -2.5) to (2.05, -3.5)
	move to (-5, 0)
.PE
.sp 2
.ce
Fig. 5: vertical set
.)z
.pp
It is much more advantageous to store the sets
.i vertically
instead of
.i horizontally
as above. 32 sets can be stored side by side in a sufficient
number of words (see Fig. 5). The membership test is coded as follows:
.(b
.FT
Set: ARRAY [0..m] OF BITSET;
.sp 0.5
e \(mo Seti   \(==   i IN Set [e]
.)b
Note, that i is a constant. Now on a MC 68020 processor two machine instructions suffice:
.(b
.FT
        movw    _e+2:l,d4
        btst    #4,(_Set:l,d4:w:4)
.)b
If the global variables e and Set could be stored in registers,
the membership test could be done even with one machine instruction, only:
.(b
.FT
        btst    #4,a0@(0,d0:l)
.)b
This implementation of the membership test has been previously described in
\*([[Gra88b\*(]]. In our case, the two ways of the membership test account for a
difference of another 30% in the over all run time of the parser.
.sh 1 Summary
.pp
We presented the interesting features of the recursive descent
parser generator
.i Ell
from the user's point of view and from the implementation aspects.
The outstanding features of
.i Ell
are the L-attribution mechanism, its ability to handle non LL(1) grammars,
and its automatic and comfortable error handling, which includes error
reporting, recovery, and repair.
.pp
The generated parsers are extremely efficient in terms of run time. For
example a Modula-2 parser runs at a speed of 55,000 tokens per
second or 900,000 lines per minute on a MC 68020 processor (excluding
scanning). The size of the parser is 25 K bytes and the run time of the
generator is 10 seconds.
.uh  Acknowledgements
.pp
Whereas the author designed the generated code and the error recovery, the generator
.i Ell
was programmed by D. Kuske. The implementation of the global recovery sets
was discovered independently by D. Schwartz-Hertzner and D. Kuske. B.
Vielsack added the generation of C code, the L-attribution mechanism, and
the disambiguating rules for non LL(1) grammars. The implementation of the
set membership test is due to W. M. Waite and B. Gray.
.[]
.[-
.ds [F DuW81
.ds [A R\*(p]\*(a]C\*(p] Dunn
.as [A \*(n]W\*(p]\*(a]M\*(p] Waite
.ds [T SYNPUT
.ds [I Department of Electrical Engineering, Univ. of Colorado
.ds [C Boulder, CO
.ds [D Feb. 1981
.][
.[-
.ds [F Gra88a
.ds [A R\*(p]\*(a]W\*(p] Gray
.ds [T Automatic Error Recovery in a Fast Parser
.ds [J Summer USENIX Conference
.ds [D 1988
.][
.[-
.ds [F Gra88b
.ds [A R\*(p]\*(a]W\*(p] Gray
.ds [T \\(*g-GLA - A Generator for Lexical Analyzers That Programmers can Use
.ds [I University of Colorado, Boulder
.ds [D 1988
.][
.[-
.ds [F Gro88
.ds [A J\*(p] Grosch
.ds [T Generators for High-Speed Front-Ends
.ds [V 371
.ds [J LNCS
.ds [C Berlin
.ds [I Springer Verlag
.nr [P 1
.ds [P 81-92
.ds [D Oct. 1988
.][
.[-
.ds [F GrV
.ds [A J\*(p] Grosch
.as [A \*(n]B\*(p] Vielsack
.ds [T The Parser Generators Lalr and Ell
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 8
.ds [N 8
.][
.[-
.ds [F Iro63
.ds [A E\*(p]\*(a]T\*(p] Irons
.ds [T An Error Correcting Parse Algorithm
.nr [P 1
.ds [P 669-673
.ds [J Comm. ACM
.ds [V 6
.ds [D Nov. 1963
.ds [N 11
.][
.[-
.ds [F M\\90
.ds [A H\*(p] M\\*ossenb\\*ock
.ds [T Coco/R - A Generator for Fast Compiler Front-Ends
.ds [R Report No. 127
.ds [I Departement Informatik, ETH Z\\*urich
.ds [D Feb. 1990
.][
.[-
.ds [F ReM85
.ds [A P\*(p] Rechenberg
.as [A \*(n]H\*(p] M\\*ossenb\\*ock
.ds [T Ein Compiler-Generator f\\*ur Mikrocomputer
.ds [I Hanser
.ds [C M\\*unchen
.ds [D 1985
.][
.[-
.ds [F SMM84
.ds [A M\*(p] Spenke
.as [A \*(c]H\*(p] M\\*:uhlenbein
.as [A \*(c]M\*(p] Mevenkamp
.as [A \*(c]F\*(p] Mattern
.as [A \*(m]C\*(p] Beilken
.ds [T A Language Independent Error Recovery Method for LL(1) Parsers
.nr [P 1
.ds [P 1095-1107
.ds [J Software\(emPractice & Experience
.ds [V 14
.ds [N 11
.ds [D Nov. 1984
.][
.[-
.ds [F Wil79
.ds [A R\*(p] Wilhelm
.ds [T Attributierte Grammatiken
.ds [J Informatik Spektrum
.ds [V 2
.ds [N 3
.nr [P 1
.ds [P 123-130
.ds [D 1979
.ds [W Grosch
.ds [X gelesen
.][
.[-
.ds [F Wir86
.ds [A N\*(p] Wirth
.ds [T Compilerbau
.ds [S Teubner Studienb\\*ucher Informatik
.ds [C Stuttgart
.ds [I Teubner
.ds [D 1986
.][
.bp
.uh "Appendix 1: Scheme of the Code Generated for EBNF Constructs"
.sp 1
.nf
.FT
                                (* Literal t                            *)
IF Token # t THEN RecoveryLiteral (t, Recover(t), GlobalrecoverySet);
ELSE Token := GetToken (); IsRepairMode := FALSE;
END;
                                (* Terminal t (with attribute ti)       *)
IF Token # t THEN RecoveryTerminal (t, Recover(t), GlobalrecoverySet, ti);
ELSE ti := Attribute; Token := GetToken (); IsRepairMode := FALSE;
END;
                                (* Nonterminal X (with attribute Xi)    *)
Union.LocalRecoverySet := Recover(X); X (SXSTEM.ADR (Union), Xi);

LOOP                            (* Optional part X = [ Y ]              *)
  IF Token \(mo FIRST (Y) THEN <Y> EXIT;
  ELSIF Token \(mo FOLLOW (X) OR IsRepairMode THEN EXIT; END;
  ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
END;

LOOP                            (* Iteration X = Y * or X = { Y }       *)
  IF Token \(mo FIRST (Y) THEN <Y>
  ELSIF Token \(mo FOLLOW (X) OR IsRepairMode THEN EXIT;
  ELSE ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
  END;
END;

LOOP                            (* Iteration X = Y + or X = Y { Y }     *)
  <Y>
  IF Token \(nm FIRST (Y) THEN
    IF Token \(mo FOLLOW (X) THEN EXIT; END;
    ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
    IF Token \(nm FIRST (Y) THEN EXIT; END;
  END;
END;

LOOP                            (* Iteration X = Y || Z or X = Y { Z Y } *)
  <Y>
  IF Token \(nm FIRST (Z) THEN
    IF Token \(mo FOLLOW (X) THEN EXIT; END;
    ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
    IF Token \(nm (FIRST (Y) \(cu FIRST (Z)) THEN EXIT; END;
  END;
  <Z>
END;

LOOP                            (* Alternative = X = Y1 | ... | Yn      *)
  CASE Token OF
  | FIRST (Y1) & FOLLOW (Y1): <Y1> EXIT;
      ...
  | FIRST (Yn) & FOLLOW (Yn): <Yn> EXIT;
  ELSE          (* Yd (1 <= d <= n): default alternative for error case *)
                (*                   duplication of one of the above    *)
    IF IsRepairMode THEN <Yd> EXIT; END;
    ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
  END;
END;
.bp
.uh "Appendix 2: Procedures for Error Recovery"
.sp 2
.nf
.FT
TYPE tUnionPtr  = POINTER TO tUnion;
TYPE tUnion     = RECORD                    (* type for list elements      *)
                    GlobalRecoverySet   : tUnionPtr;
                    LocalRecoverySet    : SHORTCARD;
                  END;
TYPE tSet       = ARRAY [0..Upb] OF BITSET; (* type for bit sets           *)

VAR SetMemory   : ARRAY [0..169] OF tSet;   (* storage for horizontal sets *)

                                            (* test for set membership     *)
PROCEDURE IsElement (Set: tSet; Element: SHORTCARD): BOOLEAN;
  BEGIN
    RETURN Element MOD BitsPerBitset IN Set [Element DIV BitsPerBitset];
  END IsElement;
                            (* compute global recovery set and skip tokens *)
PROCEDURE SkipTokens (LocalRecoverySet: SHORTCARD; GlobalRecoverySet: tUnionPtr);
  VAR RecoverySet: tSet; i: SHORTCARD;
  BEGIN
    RecoverySet := SetMemory [LocalRecoverySet];
    INCL (RecoverySet [0], sEof);
    WHILE GlobalRecoverySet # NIL DO
      FOR i := 0 TO Upb DO RecoverySet [i] :=
        RecoverySet [i] + SetMemory [GlobalRecoverySet^.LocalRecoverySet] [i];
      END;
      GlobalRecoverySet := GlobalRecoverySet^.GlobalRecoverySet;
    END;
    WHILE NOT IsElement (RecoverySet, Token) DO
      Token := GetToken ();
    END;
    ErrorMessage (RestartPoint, Information, Line, Column);
    IsRepairMode := TRUE;
  END SkipTokens;

PROCEDURE ErrorRecovery (ExpectedSet      : SHORTCARD;
                         LocalRecoverySet : SHORTCARD;
                         GlobalRecoverySet: tUnionPtr);
  BEGIN
    IF NOT IsRepairMode THEN
      INC (ErrorCount);
      ErrorMessage (SyntaxError, Error, Line, Column);
      ErrorMessageI (ExpectedSymbols, Information, Line, Column, TokenSet,
                     SYSTEM.ADR (SetMemory [ExpectedSet]));
      SkipTokens (LocalRecoverySet, GlobalRecoverySet);
    END;
  END ErrorRecovery;
.bp
PROCEDURE RecoveryTerminal (Expected         : SHORTCARD;
                            LocalRecoverySet : SHORTCARD;
                            GlobalRecoverySet: tUnionPtr;
               VAR RepairAttribute: tScanAttribute); (* for terminals only *)
  BEGIN
    IF NOT IsRepairMode THEN
      INC (ErrorCount);
      ErrorMessage (SyntaxError, Error, Line, Column);
      ErrorMessageI (ExpectedSymbols, Information, Line, Column, Symbol,
                     SYSTEM.ADR (Expected));
      SkipTokens (LocalRecoverySet, GlobalRecoverySet);
    END;
    IF Token # Expected THEN
      ErrorMessageI (SymbolInserted, Repair, Line, Column, Symbol,
                     SYSTEM.ADR (Expected));
      ErrorAttribute (Expected, RepairAttribute);    (* for terminals only *)
    ELSE
      RepairAttribute := Attribute;                  (* for terminals only *)
      IF Token # sEof THEN Token := GetToken (); END;
      IsRepairMode := FALSE;
    END;
  END RecoveryTerminal;

PROCEDURE ErrorRecoveryLiteral (Expected         : SHORTCARD;
                                LocalRecoverySet : SHORTCARD;
                                GlobalRecoverySet: tUnionPtr);

   (* like ErrorRecoveryTerminal except as marked above *)
.uh "Appendix 3: Attribute Grammar to Compute the Recovery Sets"
.sp 2
.nf
.ta 3c
N	nonterminal
E	expression
t	terminal or literal
R	recovery set
In, Out	temporary attributes
.sp 2
.FT
.ta 16.5c
N = E           {E.In := \(es;	}
E = t           {E.R := FIRST (t) \(cu E.In; E.Out := E.R;	}
E = N           {E.R := E.In; E.Out := FIRST (N) \(cu E.In;	}
E = [ E1 ]      {E1.In := E.In; E.R := FIRST (E1) \(cu E.In; E.Out := E.R;	}
E = E1 *        {E1.In := E.In; E.R := FIRST (E1) \(cu E.In; E.Out := E.R;	}
E = E1 +        {E1.In := E.In; E.R := FIRST (E1) \(cu E.In; E.Out := E.R;	}
E = E1 || E2    {E1.In := FIRST (E2) \(cu E.In; E2.In := FIRST (E1) \(cu E.In;
                 E.R := FIRST (E1) \(cu FIRST (E2) \(cu E.In; E.Out := E.R;	}
E = E1 |...| En {E1.In := E.In; ... En.In := E.In;
                 E.R := FIRST (E1) \(cu ... \(cu FIRST (En) \(cu E.In; E.Out := E.R;	}
E = E1 E2       {E2.In := E.In; E1.In := E2.Out; E.R := E1.Out; E.Out := E.R;	}
.bp
.uh "Appendix 4: Example of Error Recovery"
.sp 2
.nf
Source Program:
.sp 0.5
.FT
    1   MODULE Error;
    2   CONST M := 10, N = 100  X = 10;
    3   VAR , a, b, c;
    4   
    5   PROCEDURE P;
    6   BEGIN
    7     s := 0; a = 5 * (b - 1 END;
    8   
    9   BEGIN
   10     > a > b;
   11     WHILE a DO
   12       BEGIN > b; - c := 0;
   13       WHILE a > 0 BEGIN
   14         IF ODD a c := c * - b;
   15         b := 2 * b a := a /2
   16       END;
   17       P := 0; P; 666;
   18     END .
.sp 0.5
.FR
Error Messages:
.sp 0.5
.FT
2, 9:   Error       syntax error
2, 9:   Information expected symbols: '='
2, 12:  Information restart point
2, 12:  Repair      symbol inserted : '='
2, 14:  Error       syntax error
2, 14:  Information expected symbols: ';'
2, 16:  Information restart point
2, 16:  Repair      symbol inserted : ';'
2, 25:  Error       syntax error
2, 25:  Information restart point
2, 25:  Repair      symbol inserted : ';'
3, 5:   Error       syntax error
3, 7:   Information restart point
3, 14:  Error       syntax error
3, 14:  Information expected symbols: ':'
3, 14:  Information restart point
3, 14:  Repair      symbol inserted : ':'
3, 14:  Repair      symbol inserted : Ident
7, 13:  Error       syntax error
7, 13:  Information expected symbols: '(' ':=' ';' 
7, 19:  Information restart point
7, 26:  Error       syntax error
7, 26:  Information restart point
7, 26:  Repair      symbol inserted : ')'
7, 29:  Error       syntax error
7, 29:  Information expected symbols: Ident
7, 29:  Information restart point
7, 29:  Repair      symbol inserted : Ident
10, 3:  Error       syntax error
10, 3:  Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
10, 5:  Information restart point
10, 7:  Error       syntax error
10, 7:  Information expected symbols: '(' ':=' ';' 
10, 9:  Information restart point
10, 9:  Repair      symbol inserted : ';'
12, 5:  Error       syntax error
12, 5:  Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
12, 13: Information restart point
12, 16: Error       syntax error
12, 16: Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
12, 18: Information restart point
13, 17: Error       syntax error
14, 7:  Information restart point
14, 7:  Repair      symbol inserted : 'DO'
14, 14: Error       syntax error
14, 14: Information restart point
14, 14: Repair      symbol inserted : 'THEN'
14, 16: Error       syntax error
14, 16: Information restart point
14, 16: Repair      symbol inserted : ';'
14, 25: Error       syntax error
14, 25: Information expected symbols: Ident Integer Real String '(' '{' 'NOT' 
14, 25: Information restart point
14, 25: Repair      symbol inserted : Integer
15, 18: Error       syntax error
15, 18: Information restart point
15, 18: Repair      symbol inserted : ';'
17, 16: Error       syntax error
17, 16: Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
17, 19: Information restart point
18, 7:  Error       syntax error
18, 7:  Information restart point
18, 7:  Repair      symbol inserted : 'END'
18, 7:  Repair      symbol inserted : 'END'
18, 7:  Repair      symbol inserted : Ident
.fi
.sz 12
.bp 1
.lp
.b Contents
.sp
.xp
.ex



.he ''''
.bp
.(l L
.FT
expr    : ( [ '+' ] term { expr0.value :=   term1.value;                }
          | '-' term     { expr0.value := - term2.value;                }
          )
          ( '+' term     { INC (expr0.value, term3.value);              }
          | '-' term     { DEC (expr0.value, term4.value);              }
          ) *
        .
term    : fact           { term0.value := fact1.value;                  }
          ( '*' fact     { term0.value := term0.value * fact2.value;    }
          | '/' fact     { term0.value := term0.value DIV fact3.value;  }
          ) *
        .
fact    : const          { fact0.value := const1.value;                 }
        | '(' expr ')'   { fact0.value := expr1.value;                  }
        .
.)l
.sp 4c
.(l L
.FT
TYPE tParsAttribute = RECORD value: INTEGER; END;
.)l
.sp 4c
.(l L
.FT
PROCEDURE expr (...; VAR expr0: tParsAttribute);
VAR term1, term2, term3, term4: tParsAttribute;
BEGIN
\&   ...
END expr;
.)l



.bp
.(l L
.vs 12
Source Program:
.sp 0.5
.FT
MODULE test;
BEGIN
   IF (a = ] 1 write (a) END;
END test.
.sp 0.5
.FR
Error Messages:
.sp 0.5
.FT
3, 12: Error       syntax error
3, 12: Information expected symbols: Ident Integer Real String '(' '+' '-' '{' 'NOT' 
3, 14: Information restart point
3, 16: Error       syntax error
3, 16: Information restart point
3, 16: Repair      symbol inserted : ')'
3, 16: Repair      symbol inserted : 'THEN'
.)l
.sp 4c
.(l L
.FT 
TYPE tUnionPtr  = POINTER TO tUnion;
TYPE tUnion     = RECORD             (* type for list elements             *)
                    GlobalRecoverySet   : tUnionPtr;
                    LocalRecoverySet    : SHORTCARD;
                  END;
                                     (* procedure for a nonterminal        *)
PROCEDURE Module (GlobalRecoverySet: tUnionPtr; VAR Module0: tParsAttribute);
VAR
  Union : tUnion;
  Ident1: tScanAttribute;
  Block1: tParsAttribute;
  ...
BEGIN
  Union.GlobalRecoverySet := GlobalRecoverySet;
.sp 0.5
  IF Token # sMODULE THEN            (* analysis of a literal              *)
    RecoveryLiteral (sMODULE, 138, GlobalRecoverySet);
  ELSE
    Token := GetToken (); IsRepairMode := FALSE;
  END;
.sp 0.5
  IF Token # sIdent THEN             (* analysis of an attributed terminal *)
    RecoveryTerminal (sIdent, 138, GlobalRecoverySet, Ident1);
  ELSE
    Ident1 := Attribute;             (* receive attribute from scanner     *)
    Token := GetToken (); IsRepairMode := FALSE;
  END;
.sp 0.5
  Union.LocalRecoverySet := 57;      (* analysis of a nonterminal          *)
  Block (SYSTEM.ADR (Union), Block1);
.sp 0.5
END Module;
.)l



.bp
.(l L
.PS
scale	= 2.54
define set #
	right
	box invis $1 wid boxwid/2
	box; box; box; box; box; box
#
define dbox #
	box
	line from last box.sw + (boxwid * 0.00, 0) to last box.nw + (boxwid * 0.25, 0)
	line from last box.sw + (boxwid * 0.25, 0) to last box.nw + (boxwid * 0.50, 0)
	line from last box.sw + (boxwid * 0.50, 0) to last box.nw + (boxwid * 0.75, 0)
	line from last box.sw + (boxwid * 0.75, 0) to last box.nw + (boxwid * 1.00, 0)
	move down boxht * 0.5; right
#
define dset #
	right
	box invis $1 wid boxwid/2
	dbox(); dbox(); dbox(); dbox(); dbox(); dbox()
#
boxwid	= 2.0
boxht	= 1.0

	move to (0,  1)
	box invis wid boxwid/2
	box invis "0"
	box invis "1"
	box invis
	box invis "e / 32"
	box invis
	box invis "k"

	move to (0, -0)
	set("0")
	move to (0, -1)
	set("1")
	move right 1
	" word (BITSET)" ljust
	move to (0, -2)
	set()
	move right 1
	" element (bit)" ljust
	move to (0, -3)
	dset("i")
	move right 1
	" set" ljust
	move to (0, -4)
	set()
	move to (0, -5)
	set("n")
.sz -4
	"0"	at (7.15, -2.35)
	"e mod 32"	at (8.00, -2.35)
	"31"	at (8.75, -2.35)
.sz +4
	line from (12, -1) to (14, -1)
	line from ( 8, -3) to (14, -2)
	line from (12, -3) to (14, -3)

	line from (7.95, -2.5) to (7.95, -3.5)
	line from (8.05, -2.5) to (8.05, -3.5)
.PE
.)l
.sp 4c
.(l L
.FT
Seti: ARRAY [0..k] OF BITSET;
.sp 0.5
e \(mo Seti   \(==   (e MOD 32) IN Seti [e DIV 32]
.)l
.sp 4c
.(l L
.FT
        movl    _e:l,d1
        divsll  #0x20,d2:d1
        movl    _e:l,d3
        divsl   #0x20,d3
        movl    (_Set:l,d3:w:4),d3
        btst    d2,d3
.)l
.sp 4c
.(l L
.PS
define word #
	box invis $1 wid boxwid/2
	right
	box
	line from last box.n + (0.1, 0) to last box.s + (0.1, 0)
	line from last box.n to last box.s
	move to last box.e
#
boxwid	= 2.0
boxht	= 1.0

.sz -2
	move to (0, 0.65)
	box invis wid boxwid/2
	box invis "0        i      31"
.sz +2
	move to (0,  0)
	word("0")
	move to (0, -1)
	word("1")
	move to (0, -2)
	word()
	move right 1
	" word (BITSET)" ljust
	move to (0, -3)
	word("e")
	move right 1
	" element (bit)" ljust
	move to (0, -4)
	word()
	move right 1
	" set" ljust
	move to (0, -5)
	word("m")

	line from (2.50, -2) to (4, -2)
	line from (2.05, -3) to (4, -3)
	line from (2.05, -4) to (4, -4)

	line from (2.05, -2.5) to (2.05, -3.5)
	move to (-5, 0)
.PE
.)l
.sp 4c
.(l L
.FT
Set: ARRAY [0..m] OF BITSET;
.sp 0.5
e \(mo Seti   \(==   i IN Set [e]
.)l
.sp 4c
.(l L
.FT
        movw    _e+2:l,d4
        btst    #4,(_Set:l,d4:w:4)
.)l
.sp 4c
.(l L
.FT
        btst    #4,a0@(0,d0:l)
.)l
.bp
.nf
.FT
                                (* Literal t                            *)
IF Token # t THEN RecoveryLiteral (t, Recover(t), GlobalrecoverySet);
ELSE Token := GetToken (); IsRepairMode := FALSE;
END;
                                (* Terminal t (with attribute ti)       *)
IF Token # t THEN RecoveryTerminal (t, Recover(t), GlobalrecoverySet, ti);
ELSE ti := Attribute; Token := GetToken (); IsRepairMode := FALSE;
END;
                                (* Nonterminal X (with attribute Xi)    *)
Union.LocalRecoverySet := Recover(X); X (SXSTEM.ADR (Union), Xi);

LOOP                            (* Optional part X = [ Y ]              *)
  IF Token \(mo FIRST (Y) THEN <Y> EXIT;
  ELSIF Token \(mo FOLLOW (X) OR IsRepairMode THEN EXIT; END;
  ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
END;

LOOP                            (* Iteration X = Y * or X = { Y }       *)
  IF Token \(mo FIRST (Y) THEN <Y>
  ELSIF Token \(mo FOLLOW (X) OR IsRepairMode THEN EXIT;
  ELSE ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
  END;
END;

LOOP                            (* Iteration X = Y + or X = Y { Y }     *)
  <Y>
  IF Token \(nm FIRST (Y) THEN
    IF Token \(mo FOLLOW (X) THEN EXIT; END;
    ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
    IF Token \(nm FIRST (Y) THEN EXIT; END;
  END;
END;

LOOP                            (* Iteration X = Y || Z or X = Y { Z Y } *)
  <Y>
  IF Token \(nm FIRST (Z) THEN
    IF Token \(mo FOLLOW (X) THEN EXIT; END;
    ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
    IF Token \(nm (FIRST (Y) \(cu FIRST (Z)) THEN EXIT; END;
  END;
  <Z>
END;

LOOP                            (* Alternative = X = Y1 | ... | Yn      *)
  CASE Token OF
  | FIRST (Y1) & FOLLOW (Y1): <Y1> EXIT;
      ...
  | FIRST (Yn) & FOLLOW (Yn): <Yn> EXIT;
  ELSE          (* Yd (1 <= d <= n): default alternative for error case *)
                (*                   duplication of one of the above    *)
    IF IsRepairMode THEN <Yd> EXIT; END;
    ErrorRecovery (Expected (X), Recover (X), GlobalRecoverySet);
  END;
END;
.FR
.bp
.nf
.FT
TYPE tUnionPtr  = POINTER TO tUnion;
TYPE tUnion     = RECORD                    (* type for list elements      *)
                    GlobalRecoverySet   : tUnionPtr;
                    LocalRecoverySet    : SHORTCARD;
                  END;
TYPE tSet       = ARRAY [0..Upb] OF BITSET; (* type for bit sets           *)

VAR SetMemory   : ARRAY [0..169] OF tSet;   (* storage for horizontal sets *)

                                            (* test for set membership     *)
PROCEDURE IsElement (Set: tSet; Element: SHORTCARD): BOOLEAN;
  BEGIN
    RETURN Element MOD BitsPerBitset IN Set [Element DIV BitsPerBitset];
  END IsElement;
                            (* compute global recovery set and skip tokens *)
PROCEDURE SkipTokens (LocalRecoverySet: SHORTCARD; GlobalRecoverySet: tUnionPtr);
  VAR RecoverySet: tSet; i: SHORTCARD;
  BEGIN
    RecoverySet := SetMemory [LocalRecoverySet];
    INCL (RecoverySet [0], sEof);
    WHILE GlobalRecoverySet # NIL DO
      FOR i := 0 TO Upb DO RecoverySet [i] :=
        RecoverySet [i] + SetMemory [GlobalRecoverySet^.LocalRecoverySet] [i];
      END;
      GlobalRecoverySet := GlobalRecoverySet^.GlobalRecoverySet;
    END;
    WHILE NOT IsElement (RecoverySet, Token) DO
      Token := GetToken ();
    END;
    ErrorMessage (RestartPoint, Information, Line, Column);
    IsRepairMode := TRUE;
  END SkipTokens;

PROCEDURE ErrorRecovery (ExpectedSet      : SHORTCARD;
                         LocalRecoverySet : SHORTCARD;
                         GlobalRecoverySet: tUnionPtr);
  BEGIN
    IF NOT IsRepairMode THEN
      INC (ErrorCount);
      ErrorMessage (SyntaxError, Error, Line, Column);
      ErrorMessageI (ExpectedSymbols, Information, Line, Column, TokenSet,
                     SYSTEM.ADR (SetMemory [ExpectedSet]));
      SkipTokens (LocalRecoverySet, GlobalRecoverySet);
    END;
  END ErrorRecovery;
.bp
PROCEDURE RecoveryTerminal (Expected         : SHORTCARD;
                            LocalRecoverySet : SHORTCARD;
                            GlobalRecoverySet: tUnionPtr;
               VAR RepairAttribute: tScanAttribute); (* for terminals only *)
  BEGIN
    IF NOT IsRepairMode THEN
      INC (ErrorCount);
      ErrorMessage (SyntaxError, Error, Line, Column);
      ErrorMessageI (ExpectedSymbols, Information, Line, Column, Symbol,
                     SYSTEM.ADR (Expected));
      SkipTokens (LocalRecoverySet, GlobalRecoverySet);
    END;
    IF Token # Expected THEN
      ErrorMessageI (SymbolInserted, Repair, Line, Column, Symbol,
                     SYSTEM.ADR (Expected));
      ErrorAttribute (Expected, RepairAttribute);    (* for terminals only *)
    ELSE
      RepairAttribute := Attribute;                  (* for terminals only *)
      IF Token # sEof THEN Token := GetToken (); END;
      IsRepairMode := FALSE;
    END;
  END RecoveryTerminal;

PROCEDURE ErrorRecoveryLiteral (Expected         : SHORTCARD;
                                LocalRecoverySet : SHORTCARD;
                                GlobalRecoverySet: tUnionPtr);

   (* like ErrorRecoveryTerminal except as marked above *)
.FR
.bp
.nf
.FT
.ta 16.5c
N = E           {E.In := \(es;	}
E = t           {E.R := FIRST (t) \(cu E.In; E.Out := E.R;	}
E = N           {E.R := E.In; E.Out := FIRST (N) \(cu E.In;	}
E = [ E1 ]      {E1.In := E.In; E.R := FIRST (E1) \(cu E.In; E.Out := E.R;	}
E = E1 *        {E1.In := E.In; E.R := FIRST (E1) \(cu E.In; E.Out := E.R;	}
E = E1 +        {E1.In := E.In; E.R := FIRST (E1) \(cu E.In; E.Out := E.R;	}
E = E1 || E2    {E1.In := FIRST (E2) \(cu E.In; E2.In := FIRST (E1) \(cu E.In;
                 E.R := FIRST (E1) \(cu FIRST (E2) \(cu E.In; E.Out := E.R;	}
E = E1 |...| En {E1.In := E.In; ... En.In := E.In;
                 E.R := FIRST (E1) \(cu ... \(cu FIRST (En) \(cu E.In; E.Out := E.R;	}
E = E1 E2       {E2.In := E.In; E1.In := E2.Out; E.R := E1.Out; E.Out := E.R;	}
.FR
.sp 4c
.nf
.FT
    1   MODULE Error;
    2   CONST M := 10, N = 100  X = 10;
    3   VAR , a, b, c;
    4   
    5   PROCEDURE P;
    6   BEGIN
    7     s := 0; a = 5 * (b - 1 END;
    8   
    9   BEGIN
   10     > a > b;
   11     WHILE a DO
   12       BEGIN > b; - c := 0;
   13       WHILE a > 0 BEGIN
   14         IF ODD a c := c * - b;
   15         b := 2 * b a := a /2
   16       END;
   17       P := 0; P; 666;
   18     END .
.FR
.bp
.nf
.FT
2, 9:   Error       syntax error
2, 9:   Information expected symbols: '='
2, 12:  Information restart point
2, 12:  Repair      symbol inserted : '='
2, 14:  Error       syntax error
2, 14:  Information expected symbols: ';'
2, 16:  Information restart point
2, 16:  Repair      symbol inserted : ';'
2, 25:  Error       syntax error
2, 25:  Information restart point
2, 25:  Repair      symbol inserted : ';'
3, 5:   Error       syntax error
3, 7:   Information restart point
3, 14:  Error       syntax error
3, 14:  Information expected symbols: ':'
3, 14:  Information restart point
3, 14:  Repair      symbol inserted : ':'
3, 14:  Repair      symbol inserted : Ident
7, 13:  Error       syntax error
7, 13:  Information expected symbols: '(' ':=' ';' 
7, 19:  Information restart point
7, 26:  Error       syntax error
7, 26:  Information restart point
7, 26:  Repair      symbol inserted : ')'
7, 29:  Error       syntax error
7, 29:  Information expected symbols: Ident
7, 29:  Information restart point
7, 29:  Repair      symbol inserted : Ident
10, 3:  Error       syntax error
10, 3:  Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
10, 5:  Information restart point
10, 7:  Error       syntax error
10, 7:  Information expected symbols: '(' ':=' ';' 
10, 9:  Information restart point
10, 9:  Repair      symbol inserted : ';'
12, 5:  Error       syntax error
12, 5:  Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
12, 13: Information restart point
12, 16: Error       syntax error
12, 16: Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
12, 18: Information restart point
13, 17: Error       syntax error
14, 7:  Information restart point
14, 7:  Repair      symbol inserted : 'DO'
14, 14: Error       syntax error
14, 14: Information restart point
14, 14: Repair      symbol inserted : 'THEN'
14, 16: Error       syntax error
14, 16: Information restart point
14, 16: Repair      symbol inserted : ';'
14, 25: Error       syntax error
14, 25: Information expected symbols: Ident Integer Real String '(' '{' 'NOT' 
14, 25: Information restart point
14, 25: Repair      symbol inserted : Integer
15, 18: Error       syntax error
15, 18: Information restart point
15, 18: Repair      symbol inserted : ';'
17, 16: Error       syntax error
17, 16: Information expected symbols: Ident ';' 'CASE' 'EXIT' 'FOR' 'IF' 'LOOP'
                                      'REPEAT' 'RETURN' 'WHILE' 'WITH' 
17, 19: Information restart point
18, 7:  Error       syntax error
18, 7:  Information restart point
18, 7:  Repair      symbol inserted : 'END'
18, 7:  Repair      symbol inserted : 'END'
18, 7:  Repair      symbol inserted : Ident
.FR
