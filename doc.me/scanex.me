.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.EQ
gsize 12
delim $$
.EN
.T0


	Selected Examples of
	Scanner Specifications

	J. Grosch


.T1
.T2 "Scanner Specification" "Selected Examples of Scanner Specifications" "Josef Grosch" "May 28, 1997" 7 1997
.hc @
.bp 1
.sh 1 Introduction
.pp
Among the tokens to be recognized by scanners are a few that require non
trivial processing: comments, strings, and character constants.
Even identifiers and keywords may cause some trouble if the language defines
upper-case and lower-case letters to have the same meaning.
The problems with these tokens are the following:
.ip -
maintaining the line count during tokens extending on several lines
.ip -
maintaining the column count during tokens containing tab characters
.ip -
computation of the source position of tokens extending on several lines or
of compound tokens which are recognized as a sequence of subtokens
.ip -
nested comments
.ip -
report unclosed strings and comments as errors
.ip -
computing the internal representation of strings
.ip -
conversion of escape sequences such as doubled string delimiters or
preceding escape characters
.ip -
normalization of upper-case and lower-case letters
.lp
The following chapters contain solutions to the above problems for the
languages Pascal, Modula, C, and Ada. The solutions are scanner specifications
suitable as input for the scanner generator Rex\*([<\*([[Gro\*(]]\*(>].
The primary intention of this paper is to serve as a reference manual
containing examples for non trivial cases.
All specifications use C as target language except the chapter on Modula
which uses Modula.
The Appendix contains a complete scanner specification for Ada with Modula
as target language.
.sh 1 Pascal
.pp
.sh 2 Comments
.lp
Problems to solve:
.ip -
unclosed comments
.ip -
newline characters
.ip -
tab characters
.lp
.(b L
Solution:
.sp 0.5
.FT
EOF     {IF yyStartState = Comment THEN Error ("unclosed comment"); END;}

DEFINE  CmtCh   = - {*\\}\\t\\n}.

START   Comment

RULE

           "(*" | "{"     :- {yyStart (Comment);}
#Comment#  "*)" | "}"     :- {yyStart (STD);}
#Comment#  "*"  | CmtCh + :- {}
.)b
.pp
Comments are processed in a separate start state called
.i Comment.
Everything is skipped in this state except closing comment
brackets which switch back to start state STD.
The single characters '*' or '}'
which can start a closing comment bracket have to be skipped
separately. Otherwise closing comment brackets would not be
recognized because of the "longest match" rule of Rex.
An unclosed comment is indicated by reaching end of file while in start state
.i Comment.
We presuppose the existence of a procedure
.i Error
to report this condition.
We don't need to care about tab and newline characters other than excluding
them from the set
.i CmtCh
because the two rules needed for this problem are already predefined by
Rex:
.lp
.(b L
.FT
#Comment#  \\t :- {yyTab;}
#Comment#  \\n :- {yyEol (0);}
.)b
.sh 2 Identifiers
.lp
Problems to solve:
.ip -
normalization of upper-case and lower-case letters
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "Idents.h"
# include "Position.h"
typedef struct {
   tPosition Position;
   tIdent    Ident;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokIdentifier ...
void ErrorAttribute (Token, Attribute)
   int Token;
   tScanAttribute * Attribute;
   {
      Attribute->Ident = NoIdent;
   }
}

LOCAL   {char String [256]; int Length;}

DEFINE  letter  = {A-Z a-z}.
        digit   = {0-9}.

RULE

letter (letter | digit) * : {Length = GetLower (String);
                             Attribute.Ident = MakeIdent (String, Length);
                             return TokIdentifier;}
.)b
.pp
Normalization of upper-case and lower-case letters to lower-case is done by the
predefined operation
.i GetLower
of Rex.
.bp
.sh 2 "Character Constants"
.lp
Problems to solve:
.ip -
conversion
.ip -
tab characters
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "Position.h"
typedef struct {
   tPosition Position;
   char      Char;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokCharConst ...
void ErrorAttribute (Token, Attribute)
   int Token;
   tScanAttribute * Attribute;
   {
      Attribute->Char = '\\0';
   }
}

RULE

\&''''    : {Attribute.Char = '\\''; return TokCharConst;}
\&' \\t '  : {Attribute.Char = '\\t'; yyTab1 (1); return TokCharConst;}
\&' ANY ' : {Attribute.Char = TokenPtr [1]; return TokCharConst;}
.)b
.pp
In this example the order of the rules is significant because the last rule
would also match the characters of the preceding one.
.bp
.sh 2 "Strings"
.lp
Problems to solve:
.ip -
conversion
.ip -
doubled delimiters
.ip -
tab characters
.ip -
unclosed strings (at end of lines)
.ip -
source position
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "StringM.h"
# include "Position.h"
typedef struct {
   tPosition  Position;
   tStringRef StringRef;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokString ...
void ErrorAttribute (Token, Attribute) ...
}

LOCAL   {char String [256]; int Length;}

DEFINE  StrCh   = - {'\\t\\n}.

START   string

RULE

#STD#    '      :  {yyStart (string); Length = 0;}
#string# StrCh +:- {Length += GetWord (& String [Length]);}
#string# ''     :- {String [Length ++] = '\\'';}
#string# '      :- {yyStart (STD); String [Length] = '\\0';
                    Attribute.StringRef = PutString (String, Length);
                    return TokString;}
#string# \\t     :- {String [Length ++] = '\\t'; yyTab;}
#string# \\n     :- {Error ("unclosed string"); yyEol (0);
                    yyStart (STD); String [Length] = '\\0';
                    Attribute.StringRef = PutString (String, Length);
                    return TokString;}
.)b
.pp
We presuppose the existence of a string memory module
.i StringM.
The procedure
.i PutString
stores a string in the string memory and returns a reference to it which can
be used as attribute of the token
.i TokString.
.bp
.sh 2 "Keywords"
.lp
Problems to solve:
.ip -
normalization of upper-case and lower-case letters
.lp
.(b L
Solution:
.sp 0.5
.FT
GLOBAL  {
# define TokAND       ...
   ...
# define TokWITH         ...
void ErrorAttribute (Token, Attribute) ...
}

DEFINE  A = {Aa}.
          ...
        Z = {Zz}.

RULE

A N D           : {return TokAND       ;}
  ...
W I T H         : {return TokWITH      ;}
.)b
.pp
The idea of the solution is to define identifiers A to Z to stand for the
corresponding upper-case as well as lower-case letters. Then specifying the
keywords in upper-case and spaced does the job.
.bp
.sh 1 Modula
.pp
.sh 2 Comments
.lp
Problems to solve:
.ip -
nested comments
.ip -
unclosed comments
.ip -
newline characters
.ip -
tab characters
.lp
.(b L
Solution:
.sp 0.5
.FT
GLOBAL  {VAR NestingLevel: CARDINAL;}

BEGIN   {NestingLevel := 0;}

EOF     {IF yyStartState = Comment THEN Error ("unclosed comment"); END;}

DEFINE  CmtCh   = - {*(\\t\\n}.

START   Comment

RULE

#STD, Comment# "(*" :- {INC (NestingLevel); yyStart (Comment);}
#Comment#  "*)" :- {DEC (NestingLevel);
                    IF NestingLevel = 0 THEN yyStart (STD); END;}
#Comment#  "(" | "*" | CmtCh + :- {}
.)b
.pp
We need a variable
.i NestingLevel
to count the nesting depth of comments because it is not possible to specify
nested comments by a regular expression. Comments are processed in a separate
start state called
.i Comment.
Everything is skipped in this state except opening or closing comment
brackets which
trigger a change of the nesting level. The single characters '(' and '*'
which can start opening or closing comment brackets have to be skipped
separately. Otherwise comment brackets within comment would not be
recognized because of the "longest match" rule of Rex.
An unclosed comment is indicated by reaching end of file while in start state
.i Comment.
We presuppose the existence of a procedure
.i Error
to report this condition.
We don't need to care about tab and newline characters other than excluding
them from the set
.i CmtCh
because the two rules needed for this problem are already predefined by
Rex:
.lp
.(b L
.FT
#Comment#  \\t :- {yyTab;}
#Comment#  \\n :- {yyEol (0);}
.)b
.bp
.sh 2 Strings
.lp
Problems to solve:
.ip -
conversion
.ip -
tab characters
.ip -
unclosed strings (at end of lines)
.ip -
source position
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
   FROM StringM   IMPORT tStringRef;
   FROM Position  IMPORT tPosition;
   TYPE tScanAttribute = RECORD
      Position  : tPosition;
      StringRef : tStringRef;
   END;
   PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
}
.sp 0.5
GLOBAL  {
   FROM Strings     IMPORT tString, AssignEmpty, Concatenate, Append;
   FROM StringM     IMPORT PutString;
.sp 0.5
   CONST TokString = ...;
.sp 0.5
   PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
      BEGIN Attribute.StringRef := ...; END ErrorAttribute;
}
.sp 0.5
LOCAL   {VAR String, S: tString;}
.sp 0.5
DEFINE  StrCh1  = - {'\\t\\n}.
        StrCh2  = - {"\\t\\n}.
.sp 0.5
START   Str1, Str2
.sp 0.5
RULE
.sp 0.5
#STD#   '       :  {AssignEmpty (String); yyStart (Str1);}
#Str1#  StrCh1+ :- {GetWord (S); Concatenate (String, S);}
#Str1#  '       :- {yyStart (STD);
                    Attribute.StringRef := PutString (String);
                    RETURN TokString;}
#STD#   \\"      :  {AssignEmpty (String); yyStart (Str2);}
#Str2#  StrCh2+ :- {GetWord (S); Concatenate (String, S);}
#Str2#  \\"      :- {yyStart (STD);
                    Attribute.StringRef := PutString (String);
                    RETURN TokString;}
#Str1, Str2# \\t :- {Append (String, 11C); yyTab;}
#Str1, Str2# \\n :- {Error ("unclosed string"); yyEol (0); yyStart (STD);
                    Attribute.StringRef := PutString (String);
                    RETURN TokString;}
.)b
.pp
Again two separate start states are used to recognize the two forms of
Modula-2 strings. We presuppose the existence of a string handling module
.i Strings
and a string memory module
.i StringM.
The procedure
.i PutString
stores a string in the string memory and returns a reference to it which can
be used as attribute of the token
.i TokString.
.bp
.sh 1 C
.pp
.sh 2 Comments
.lp
Problems to solve:
.ip -
unclosed comments
.ip -
newline characters
.ip -
tab characters
.lp
.(b L
Solution:
.sp 0.5
.FT
EOF     {if (yyStartState == Comment) Error ("unclosed comment");}

DEFINE  CmtCh   = - {*\\t\\n}.

START   Comment

RULE

           "/*" :- {yyStart (Comment);}
#Comment#  "*/" :- {yyStart (STD);}
#Comment#  "*" | CmtCh + :- {}
.)b
.pp
Comments are processed in a separate start state called
.i Comment.
Everything is skipped in this state except closing comment
brackets which switch back to start state STD.
The single character '*'
which can start a closing comment bracket has to be skipped
separately. Otherwise closing comment brackets would not be
recognized because of the "longest match" rule of Rex.
An unclosed comment is indicated by reaching end of file while in start state
.i Comment.
We presuppose the existence of a procedure
.i Error
to report this condition.
We don't need to care about tab and newline characters other than excluding
them from the set
.i CmtCh
because the two rules needed for this problem are already predefined by
Rex:
.lp
.(b L
.FT
#Comment#  \\t :- {yyTab;}
#Comment#  \\n :- {yyEol (0);}
.)b
.bp
.sh 2 "Character Constants"
.lp
Problems to solve:
.ip -
conversion
.ip -
escape sequences
.ip -
tab characters
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "Position.h"
typedef struct {
   tPosition Position;
   char      Char;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokChar ...
void ErrorAttribute (Token, Attribute)
   int Token;
   tScanAttribute * Attribute;
   {
      Attribute->Char = '\\0';
   }
}

RULE

\&' \\t '        : {Attribute.Char = '\\t'; yyTab1 (1); return TokChar;}
\&' ANY '       : {Attribute.Char = TokenPtr [1]; return TokChar;}
\&' \\\\ a '      : {Attribute.Char = '\\a'; return TokChar;}
\&' \\\\ b '      : {Attribute.Char = '\\b'; return TokChar;}
\&' \\\\ f '      : {Attribute.Char = '\\f'; return TokChar;}
\&' \\\\ n '      : {Attribute.Char = '\\n'; return TokChar;}
\&' \\\\ r '      : {Attribute.Char = '\\r'; return TokChar;}
\&' \\\\ t '      : {Attribute.Char = '\\t'; return TokChar;}
\&' \\\\ v '      : {Attribute.Char = '\\v'; return TokChar;}
\&' \\\\ {0-7}[1-3] ' : {unsigned int i; char String [8]; (void) GetWord (String);
                 (void) sscanf (String + 2, "%o", & i);
                 Attribute.Char = i; return TokChar;}
\&' \\\\ ANY '    : {Attribute.Char = TokenPtr [2]; return TokChar;}
.)b
.pp
In this example the order of the rules is significant because the second rule
would also match the characters of the first one. The same holds for the
group of following rules with respect to the last rule.
.bp
.sh 2 Strings
.lp
Problems to solve:
.ip -
conversion
.ip -
escape sequences
.ip -
tab characters
.ip -
strings ranging over several lines
.ip -
source position
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "StringM.h"
# include "Position.h"
typedef struct {
   tPosition  Position;
   tStringRef StringRef;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokString ...
void ErrorAttribute (Token, Attribute) ...
}

LOCAL   {char String [256]; int Length;}

DEFINE  StrCh   = - {"\\t\\n\\\\}.

START   string

RULE

#STD#    \\"     :  {yyStart (string); Length = 0;}
#string# StrCh+ :- {Length += GetWord (& String [Length]);}
#string# \\t     :- {String [Length ++] = '\\t'; yyTab;}
#string# \\\\ a   :- {String [Length ++] = '\\a';}
#string# \\\\ b   :- {String [Length ++] = '\\b';}
#string# \\\\ f   :- {String [Length ++] = '\\f';}
#string# \\\\ n   :- {String [Length ++] = '\\n';}
#string# \\\\ r   :- {String [Length ++] = '\\r';}
#string# \\\\ t   :- {String [Length ++] = '\\t';}
#string# \\\\ v   :- {String [Length ++] = '\\v';}
#string# \\\\ {0-7}[1-3] :- {unsigned int i; char S [5]; (void) GetWord (S);
                    (void) sscanf (S + 1, "%o", & i); String [Length ++] = i;}
#string# \\\\ ANY :- {String [Length ++] = TokenPtr [1];}
#string# \\\\ \\n  :- {yyEol (0);}
#string# \\"     :- {yyStart (STD); String [Length] = '\\0';
                    Attribute.StringRef = PutString (String, Length);
                    return TokString;}
#string# \\n     :- {Error ("unclosed string"); yyEol (0);
                    yyStart (STD); String [Length] = '\\0';
                    Attribute.StringRef = PutString (String, Length);
                    return TokString;}
.)b
.pp
We presuppose the existence of a string memory module
.i StringM.
The procedure
.i PutString
stores a string in the string memory and returns a reference to it which can
be used as attribute of the token
.i TokString.
.bp
.sh 1 Ada
.pp
.sh 2 Identifiers
.lp
Problems to solve:
.ip -
normalization of upper-case and lower-case letters
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "Idents.h"
# include "Position.h"
typedef struct {
   tPosition Position;
   tIdent    Ident;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokIdentifier ...
void ErrorAttribute (Token, Attribute) ...
}

LOCAL   {char String [256]; int Length;}

DEFINE  letter  = {A-Z a-z}.
        digit   = {0-9}.

RULE

letter (_? (letter | digit)+ )* : {Length = GetLower (String);
                                   Attribute.Ident = MakeIdent (String, Length);
                                   return TokIdentifier;}
.)b
.pp
Normalization of upper-case and lower-case letters to lower-case is done by the
predefined operation
.i GetLower
of Rex.
.bp
.sh 2 "Numeric Literals"
.lp
Problems to solve:
.ip -
conversion
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "StringM.h"
# include "Position.h"
typedef struct {
   tPosition  Position;
   tStringRef StringRef;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokDecimalLiteral ...
# define TokBasedLiteral ...
void ErrorAttribute (Token, Attribute) ...
}

DEFINE  digit           = {0-9}                 .
        extended_digit  = digit | {A-F a-f}     .
        integer         = digit (_? digit) *    .
        based_integer   = extended_digit (_? extended_digit) *  .
        exponent        = {Ee} {+\\-} ? integer .

RULE

integer ("." integer) ? exponent ? :
                {Attribute.StringRef = PutString (TokenPtr, TokenLength);
                 return TokDecimalLiteral;}

integer "#" based_integer ("." based_integer) ? "#" exponent ? :
                {Attribute.StringRef = PutString (TokenPtr, TokenLength);
                 return TokBasedLiteral;}
.)b
.pp
The conversion of numeric literals to numeric values is not really solved in
the above solution. By storing the external representation of numeric
literals in a string memory the values are treated symbolically and true
conversion is delayed to be done by other compiler phases.
.bp
.sh 2 "Character Literals"
.lp
Problems to solve:
.ip -
no problems to solve for character literals
.ip -
distinction between character literals and apostrophes
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "Idents.h"
# include "Position.h"
typedef struct {
   tPosition Position;
   char      Char;
   tIdent    Ident;
} tScanAttribute;
extern void ErrorAttribute ();
}

GLOBAL  {
# define TokIdentifier          ...
# define TokCharacterLiteral    ...
# define TokApostrophe          ...
# define TokLParenthesis        ...
# define TokRParenthesis        ...
void ErrorAttribute (Token, Attribute) ...
}

LOCAL   {char String [256]; int Length;}

DEFINE  character = {\\ -~}.
        letter    = {A-Z a-z}.
        digit     = {0-9}.

START   QUOTE

RULE

#STD#   ' character '   : {Attribute.Char = TokenPtr [1];
                           return TokCharacterLiteral;}
#QUOTE# '               : {yyStart (STD); return TokApostrophe;}
        "("             : {yyStart (STD); return TokLParenthesis;}
        ")"             : {yyStart (QUOTE); return TokRParenthesis;}
        letter (_? (letter | digit)+ )*
                        : {yyStart (QUOTE); Length = GetLower (Word);
                           Attribute.Ident = MakeIdent (Word, Length);
                           return TokIdentifier;}
.)b
.pp
The tokens
.i "Character Literal"
and
.i Apostrophe
can be distinguished in Ada only by consideration of some context. The
pathological input is for example something like
.lp
.(b
.FT
t'('a','b','c')
.)b
where t is a type_mark used as qualification for an aggregate of character
literals. It has to be taken care that 'a', 'b', and 'c' are recognized as
character literals and not '(', ',', and ','. Studying the Ada grammar one
can see that apostrophes are used following identifiers and closing
parentheses only. There are never character literals in this places.
.pp
This leads to the above solution with an additional start state called
.i QUOTE.
After recognition of an identifier or a closing parentheses the scanner is
switched to start state
.i QUOTE.
After recognition of all other tokens the scanner is switched back 
to start state
.i STD.
Apostrophes are recognized only in start state
.i QUOTE
and character literals only in start state
.i STD.
All the other tokens are recognized in both start states.
.\" bp
.sh 2 "String Literals"
.lp
Problems to solve:
.ip -
conversion
.ip -
doubled delimiters
.ip -
unclosed strings (at end of lines)
.ip -
source position
.lp
.(b L
Solution:
.sp 0.5
.FT
EXPORT  {
# include "StringM.h"
# include "Position.h"
typedef struct {
   tPosition  Position;
   tStringRef StringRef;
} tScanAttribute;
extern void ErrorAttribute ();
}
.sp 0.5
GLOBAL  {
# define TokStringLiteral ...
void ErrorAttribute (Token, Attribute) ...
}
.sp 0.5
LOCAL   {char String [256]; int Length;}
.sp 0.5
DEFINE  StrCh   = {\\ !#-~}.
.sp 0.5
START   string
.sp 0.5
RULE
.sp 0.5
#STD#    \\"     :  {yyStart (string); Length = 0;}
#string# StrCh+ :- {Length += GetWord (& String [Length]);}
#string# \\"\\"   :- {String [Length ++] = '\\"');}
#string# \\"     :- {yyStart (STD); String [Length] = '\\0';
                    Attribute.StringRef = PutString (String, Length);
                    return TokStringLiteral;}
#string# \\n     :- {Error ("unclosed string"); yyEol (0);
                    yyStart (STD); String [Length] = '\\0';
                    Attribute.StringRef = PutString (String, Length);
                    return TokStringLiteral;}
.)b
.pp
We presuppose the existence of a string memory module
.i StringM.
The procedure
.i PutString
stores a string in the string memory and returns a reference to it which can
be used as attribute of the token
.i TokString.
.bp
.sh 2 "Keywords"
.lp
Problems to solve:
.ip -
normalization of upper-case and lower-case letters
.lp
.(b L
Solution:
.sp 0.5
.FT
GLOBAL  {
# define TokABORT       ...
   ...
# define TokXOR         ...
void ErrorAttribute (Token, Attribute) ...
}

DEFINE  A = {Aa}.
          ...
        Z = {Zz}.

RULE

A B O R T       : {return TokABORT     ;}
  ...
X O R           : {return TokXOR       ;}
.)b
.pp
The idea of the solution is to define identifiers A to Z to stand for the
corresponding upper-case as well as lower-case letters. Then specifying the
keywords in upper-case and spaced does the job.
.bp
.uh "Appendix: Complete Scanner Specification for Ada"
.sp
.lp
.nf
.FT
.sz 10
GLOBAL  {
   FROM Strings         IMPORT tString, AssignEmpty, Concatenate, Append, Char;
   FROM StringM         IMPORT tStringRef, PutString;
   FROM Idents          IMPORT tIdent, MakeIdent;
.sp 0.5
   PROCEDURE ErrorAttribute (Token: INTEGER; VAR Attribute: tScanAttribute);
      BEGIN END ErrorAttribute;
.sp 0.5
CONST
   TokIdentifier        =  1    ;
   TokDecimalLiteral    =  2    ;
   TokBasedLiteral      =  3    ;
   TokCharLiteral       =  4    ;
   TokStringLiteral     =  5    ;
.sp 0.5
   TokArrow             =  6    ;       (* '=>'         *)
   TokDoubleDot         =  7    ;       (* '..'         *)
   TokDoubleStar        =  8    ;       (* '**'         *)
   TokBecomes           =  9    ;       (* ':='         *)
   TokNotEqual          = 10    ;       (* '/='         *)
   TokGreaterEqual      = 11    ;       (* '>='         *)
   TokLessEqual         = 12    ;       (* '<='         *)
   TokLLabelBracket     = 13    ;       (* '<<'         *)
   TokRLabelBracket     = 14    ;       (* '>>'         *)
   TokBox               = 15    ;       (* '<>'         *)
.sp 0.5
   TokAmpersand         = 16    ;       (* '&'          *)
   TokApostrophe        = 17    ;       (* '''          *)
   TokLParenthesis      = 18    ;       (* '('          *)
   TokRParenthesis      = 19    ;       (* ')'          *)
   TokStar              = 20    ;       (* '*'          *)
   TokPlus              = 21    ;       (* '+'          *)
   TokComma             = 22    ;       (* ','          *)
   TokMinus             = 23    ;       (* '-'          *)
   TokDot               = 24    ;       (* '.'          *)
   TokDivide            = 25    ;       (* '/'          *)
   TokColon             = 26    ;       (* ':'          *)
   TokSemicolon         = 27    ;       (* ';'          *)
   TokLess              = 28    ;       (* '<'          *)
   TokEqual             = 29    ;       (* '='          *)
   TokGreater           = 30    ;       (* '>'          *)
   TokBar               = 31    ;       (* '|'          *)
.sp 0.5
   TokABORT             = 32    ;       (* ABORT        *)
   TokABS               = 33    ;       (* ABS          *)
   TokACCEPT            = 34    ;       (* ACCEPT       *)
   TokACCESS            = 35    ;       (* ACCESS       *)
   TokALL               = 36    ;       (* ALL          *)
   TokAND               = 37    ;       (* AND          *)
   TokARRAY             = 38    ;       (* ARRAY        *)
   TokAT                = 39    ;       (* AT           *)
   TokBEGIN             = 40    ;       (* BEGIN        *)
   TokBODY              = 41    ;       (* BODY         *)
   TokCASE              = 42    ;       (* CASE         *)
   TokCONSTANT          = 43    ;       (* CONSTANT     *)
   TokDECLARE           = 44    ;       (* DECLARE      *)
   TokDELAY             = 45    ;       (* DELAY        *)
   TokDELTA             = 46    ;       (* DELTA        *)
   TokDIGITS            = 47    ;       (* DIGITS       *)
   TokDO                = 48    ;       (* DO           *)
   TokELSE              = 49    ;       (* ELSE         *)
   TokELSIF             = 50    ;       (* ELSIF        *)
   TokEND               = 51    ;       (* END          *)
   TokENTRY             = 52    ;       (* ENTRY        *)
   TokEXCEPTION         = 53    ;       (* EXCEPTION    *)
   TokEXIT              = 54    ;       (* EXIT         *)
   TokFOR               = 55    ;       (* FOR          *)
   TokFUNCTION          = 56    ;       (* FUNCTION     *)
   TokGENERIC           = 57    ;       (* GENERIC      *)
   TokGOTO              = 58    ;       (* GOTO         *)
   TokIF                = 59    ;       (* IF           *)
   TokIN                = 60    ;       (* IN           *)
   TokIS                = 61    ;       (* IS           *)
   TokLIMITED           = 62    ;       (* LIMITED      *)
   TokLOOP              = 63    ;       (* LOOP         *)
   TokMOD               = 64    ;       (* MOD          *)
   TokNEW               = 65    ;       (* NEW          *)
   TokNOT               = 66    ;       (* NOT          *)
   TokNULL              = 67    ;       (* NULL         *)
   TokOF                = 68    ;       (* OF           *)
   TokOR                = 69    ;       (* OR           *)
   TokOTHERS            = 70    ;       (* OTHERS       *)
   TokOUT               = 71    ;       (* OUT          *)
   TokPACKAGE           = 72    ;       (* PACKAGE      *)
   TokPRAGMA            = 73    ;       (* PRAGMA       *)
   TokPRIVATE           = 74    ;       (* PRIVATE      *)
   TokPROCEDURE         = 75    ;       (* PROCEDURE    *)
   TokRAISE             = 76    ;       (* RAISE        *)
   TokRANGE             = 77    ;       (* RANGE        *)
   TokRECORD            = 78    ;       (* RECORD       *)
   TokREM               = 79    ;       (* REM          *)
   TokRENAMES           = 80    ;       (* RENAMES      *)
   TokRETURN            = 81    ;       (* RETURN       *)
   TokREVERSE           = 82    ;       (* REVERSE      *)
   TokSELECT            = 83    ;       (* SELECT       *)
   TokSEPARATE          = 84    ;       (* SEPARATE     *)
   TokSUBTYPE           = 85    ;       (* SUBTYPE      *)
   TokTASK              = 86    ;       (* TASK         *)
   TokTERMINATE         = 87    ;       (* TERMINATE    *)
   TokTHEN              = 88    ;       (* THEN         *)
   TokTYPE              = 89    ;       (* TYPE         *)
   TokUSE               = 90    ;       (* USE          *)
   TokWHEN              = 91    ;       (* WHEN         *)
   TokWHILE             = 92    ;       (* WHILE        *)
   TokWITH              = 93    ;       (* WITH         *)
   TokXOR               = 94    ;       (* XOR          *)
}
.sp 0.5
LOCAL   {
   VAR
      String, S : tString       ;
      Word      : tString       ;
      ident     : tIdent        ;
      string    : tStringRef    ;
      ch        : CHAR          ;
}
.sp 0.5
DEFINE
   digit          = {0-9}               .
   extended_digit = digit | {A-F a-f}   .
   letter         = {a-z A-Z}           .
   character      = {\\ -~}              .
   stringch       = {\\ !#-~}            .
   integer        = digit (_? digit) *  .
   based_integer  = extended_digit (_? extended_digit) *  .
   illegal        = - {\\ \\t\\n}          .
.sp 0.5
   A            = {Aa}  .
   B            = {Bb}  .
   C            = {Cc}  .
   D            = {Dd}  .
   E            = {Ee}  .
   F            = {Ff}  .
   G            = {Gg}  .
   H            = {Hh}  .
   I            = {Ii}  .
   J            = {Jj}  .
   K            = {Kk}  .
   L            = {Ll}  .
   M            = {Mm}  .
   N            = {Nn}  .
   O            = {Oo}  .
   P            = {Pp}  .
   Q            = {Qq}  .
   R            = {Rr}  .
   S            = {Ss}  .
   T            = {Tt}  .
   U            = {Uu}  .
   V            = {Vv}  .
   W            = {Ww}  .
   X            = {Xx}  .
   Y            = {Yy}  .
   Z            = {Zz}  .
.sp 0.5
START   STRING, QUOTE
.sp 0.5
RULE
.sp 0.5
NOT #STRING# integer ("." integer) ? (E {+\\-} ? integer) ?
                        : {yyStart (STD); GetWord (Word);
                           string := PutString (Word);
                           RETURN TokDecimalLiteral;}
.sp 0.5
NOT #STRING#
    integer "#" based_integer ("." based_integer) ? "#" (E {+\\-} ? integer) ?
                        : {yyStart (STD); GetWord (Word);
                           string := PutString (Word);
                           RETURN TokBasedLiteral;}
.sp 0.5
    #STD#  ' character ': {GetWord (String); ch := Char (String, 2);
                           RETURN TokCharLiteral;}
.sp 0.5
NOT #STRING# \\"         :  {yyStart (STRING); AssignEmpty (String);}
    #STRING# stringch + :- {GetWord (S); Concatenate (String, S);}
    #STRING# \\"\\"       :- {Append (String, '"');}
    #STRING# \\"         :- {yyStart (STD); string := PutString (String);
                            RETURN TokStringLiteral;}
    #STRING# \\t         :- {Append (String, 11C); yyTab;}
    #STRING# \\n         :- {(* Error ("unclosed string"); *) yyEol (0);
                            yyStart (STD); string := PutString (String);
                            RETURN TokStringLiteral;}
.sp 0.5
NOT #STRING# "--" ANY * : {}
.sp 0.5
NOT #STRING# "=>"       : {yyStart (STD); RETURN TokArrow               ;}
NOT #STRING# ".."       : {yyStart (STD); RETURN TokDoubleDot           ;}
NOT #STRING# "**"       : {yyStart (STD); RETURN TokDoubleStar          ;}
NOT #STRING# ":="       : {yyStart (STD); RETURN TokBecomes             ;}
NOT #STRING# "/="       : {yyStart (STD); RETURN TokNotEqual            ;}
NOT #STRING# ">="       : {yyStart (STD); RETURN TokGreaterEqual        ;}
NOT #STRING# "<="       : {yyStart (STD); RETURN TokLessEqual           ;}
NOT #STRING# "<<"       : {yyStart (STD); RETURN TokLLabelBracket       ;}
NOT #STRING# ">>"       : {yyStart (STD); RETURN TokRLabelBracket       ;}
NOT #STRING# "<>"       : {yyStart (STD); RETURN TokBox                 ;}
.sp 0.5
NOT #STRING# "&"        : {yyStart (STD); RETURN TokAmpersand           ;}
    #QUOTE#  "'"        : {yyStart (STD); RETURN TokApostrophe          ;}
NOT #STRING# "("        : {yyStart (STD); RETURN TokLParenthesis        ;}
NOT #STRING# ")"        : {yyStart (QUOTE); RETURN TokRParenthesis      ;}
NOT #STRING# "*"        : {yyStart (STD); RETURN TokStar                ;}
NOT #STRING# "+"        : {yyStart (STD); RETURN TokPlus                ;}
NOT #STRING# ","        : {yyStart (STD); RETURN TokComma               ;}
NOT #STRING# "-"        : {yyStart (STD); RETURN TokMinus               ;}
NOT #STRING# "."        : {yyStart (STD); RETURN TokDot                 ;}
NOT #STRING# "/"        : {yyStart (STD); RETURN TokDivide              ;}
NOT #STRING# ":"        : {yyStart (STD); RETURN TokColon               ;}
NOT #STRING# ";"        : {yyStart (STD); RETURN TokSemicolon           ;}
NOT #STRING# "<"        : {yyStart (STD); RETURN TokLess                ;}
NOT #STRING# "="        : {yyStart (STD); RETURN TokEqual               ;}
NOT #STRING# ">"        : {yyStart (STD); RETURN TokGreater             ;}
NOT #STRING# "|"        : {yyStart (STD); RETURN TokBar                 ;}
.sp 0.5
NOT #STRING# A B O R T          : {yyStart (STD); RETURN TokABORT       ;}
NOT #STRING# A B S              : {yyStart (STD); RETURN TokABS         ;}
NOT #STRING# A C C E P T        : {yyStart (STD); RETURN TokACCEPT      ;}
NOT #STRING# A C C E S S        : {yyStart (STD); RETURN TokACCESS      ;}
NOT #STRING# A L L              : {yyStart (STD); RETURN TokALL         ;}
NOT #STRING# A N D              : {yyStart (STD); RETURN TokAND         ;}
NOT #STRING# A R R A Y          : {yyStart (STD); RETURN TokARRAY       ;}
NOT #STRING# A T                : {yyStart (STD); RETURN TokAT          ;}
NOT #STRING# B E G I N          : {yyStart (STD); RETURN TokBEGIN       ;}
NOT #STRING# B O D Y            : {yyStart (STD); RETURN TokBODY        ;}
NOT #STRING# C A S E            : {yyStart (STD); RETURN TokCASE        ;}
NOT #STRING# C O N S T A N T    : {yyStart (STD); RETURN TokCONSTANT    ;}
NOT #STRING# D E C L A R E      : {yyStart (STD); RETURN TokDECLARE     ;}
NOT #STRING# D E L A Y          : {yyStart (STD); RETURN TokDELAY       ;}
NOT #STRING# D E L T A          : {yyStart (STD); RETURN TokDELTA       ;}
NOT #STRING# D I G I T S        : {yyStart (STD); RETURN TokDIGITS      ;}
NOT #STRING# D O                : {yyStart (STD); RETURN TokDO          ;}
NOT #STRING# E L S E            : {yyStart (STD); RETURN TokELSE        ;}
NOT #STRING# E L S I F          : {yyStart (STD); RETURN TokELSIF       ;}
NOT #STRING# E N D              : {yyStart (STD); RETURN TokEND         ;}
NOT #STRING# E N T R Y          : {yyStart (STD); RETURN TokENTRY       ;}
NOT #STRING# E X C E P T I O N  : {yyStart (STD); RETURN TokEXCEPTION   ;}
NOT #STRING# E X I T            : {yyStart (STD); RETURN TokEXIT        ;}
NOT #STRING# F O R              : {yyStart (STD); RETURN TokFOR         ;}
NOT #STRING# F U N C T I O N    : {yyStart (STD); RETURN TokFUNCTION    ;}
NOT #STRING# G E N E R I C      : {yyStart (STD); RETURN TokGENERIC     ;}
NOT #STRING# G O T O            : {yyStart (STD); RETURN TokGOTO        ;}
NOT #STRING# I F                : {yyStart (STD); RETURN TokIF          ;}
NOT #STRING# I N                : {yyStart (STD); RETURN TokIN          ;}
NOT #STRING# I S                : {yyStart (STD); RETURN TokIS          ;}
NOT #STRING# L I M I T E D      : {yyStart (STD); RETURN TokLIMITED     ;}
NOT #STRING# L O O P            : {yyStart (STD); RETURN TokLOOP        ;}
NOT #STRING# M O D              : {yyStart (STD); RETURN TokMOD         ;}
NOT #STRING# N E W              : {yyStart (STD); RETURN TokNEW         ;}
NOT #STRING# N O T              : {yyStart (STD); RETURN TokNOT         ;}
NOT #STRING# N U L L            : {yyStart (STD); RETURN TokNULL        ;}
NOT #STRING# O F                : {yyStart (STD); RETURN TokOF          ;}
NOT #STRING# O R                : {yyStart (STD); RETURN TokOR          ;}
NOT #STRING# O T H E R S        : {yyStart (STD); RETURN TokOTHERS      ;}
NOT #STRING# O U T              : {yyStart (STD); RETURN TokOUT         ;}
NOT #STRING# P A C K A G E      : {yyStart (STD); RETURN TokPACKAGE     ;}
NOT #STRING# P R A G M A        : {yyStart (STD); RETURN TokPRAGMA      ;}
NOT #STRING# P R I V A T E      : {yyStart (STD); RETURN TokPRIVATE     ;}
NOT #STRING# P R O C E D U R E  : {yyStart (STD); RETURN TokPROCEDURE   ;}
NOT #STRING# R A I S E          : {yyStart (STD); RETURN TokRAISE       ;}
NOT #STRING# R A N G E          : {yyStart (STD); RETURN TokRANGE       ;}
NOT #STRING# R E C O R D        : {yyStart (STD); RETURN TokRECORD      ;}
NOT #STRING# R E M              : {yyStart (STD); RETURN TokREM         ;}
NOT #STRING# R E N A M E S      : {yyStart (STD); RETURN TokRENAMES     ;}
NOT #STRING# R E T U R N        : {yyStart (STD); RETURN TokRETURN      ;}
NOT #STRING# R E V E R S E      : {yyStart (STD); RETURN TokREVERSE     ;}
NOT #STRING# S E L E C T        : {yyStart (STD); RETURN TokSELECT      ;}
NOT #STRING# S E P A R A T E    : {yyStart (STD); RETURN TokSEPARATE    ;}
NOT #STRING# S U B T Y P E      : {yyStart (STD); RETURN TokSUBTYPE     ;}
NOT #STRING# T A S K            : {yyStart (STD); RETURN TokTASK        ;}
NOT #STRING# T E R M I N A T E  : {yyStart (STD); RETURN TokTERMINATE   ;}
NOT #STRING# T H E N            : {yyStart (STD); RETURN TokTHEN        ;}
NOT #STRING# T Y P E            : {yyStart (STD); RETURN TokTYPE        ;}
NOT #STRING# U S E              : {yyStart (STD); RETURN TokUSE         ;}
NOT #STRING# W H E N            : {yyStart (STD); RETURN TokWHEN        ;}
NOT #STRING# W H I L E          : {yyStart (STD); RETURN TokWHILE       ;}
NOT #STRING# W I T H            : {yyStart (STD); RETURN TokWITH        ;}
NOT #STRING# X O R              : {yyStart (STD); RETURN TokXOR         ;}
.sp 0.5
NOT #STRING# letter (_? (letter | digit)+ )*
                                : {yyStart (QUOTE); GetLower (Word);
                                   ident := MakeIdent (Word);
                                   RETURN TokIdentifier;}
.sp 0.5
NOT #STRING# illegal            : {IO.WriteS (IO.StdOutput, "illegal character: ");
                                   yyEcho; IO.WriteNl (IO.StdOutput);}
.fi
.sz 12
.[]
.[-
.ds [F Gro
.ds [A J\*(p] Grosch
.ds [T Rex - A Scanner Generator
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 5
.ds [N 5
.][
.bp 1
.lp
.b Contents
.sp
.xp
