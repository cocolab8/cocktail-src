.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.EQ
delim off
.EN
.de []
.uh Literatur
..
.de FR
.ft R
.sz +2
..
.T0


	Automatische Generierung
	effizienter Compiler

	J. Grosch


.T1
.T2 "" "Automatische Generierung effizienter Compiler" "Josef Grosch" "Jan. 12, 1989" 13 1994
.bp 1
.ce 99
.b "Automatische Generierung effizienter Compiler"
.ce 0
.sp
.uh Zusammenfassung
.lp
Das Projekt UWE (\*Ubersetzerbau-Werkzeuge) zielt auf die Erstellung von
Generatorprogrammen, die es erlauben Compiler weitgehend automatisch zu
erzeugen. F\*ur die Analysephase von Compilern werden drei Generatoren
vorgestellt:
.i Rex
ist ein Scanner-Generator auf der Basis regul\*arer Ausdr\*ucke. Der
Parser-Generator
.i Lalr
erzeugt aus LALR(1)-Grammatiken tabellengesteuerte Parser mit
S-Attributierung und automatischer Fehlerbehandlung.
Der Parser-Generator
.i Ell
erzeugt aus LL(1)-Grammatiken Parser nach dem Verfahren des rekursiven
Abstiegs mit einem Mechanismus zur L-Attributierung und ebenfalls
automatischer Fehlerbehandlung.
Alle Generatoren sind in Modula-2 programmiert und erzeugen Programme in C
oder Modula-2. Die herausragende Eigenschaft der erzeugten Programme ist
ihre Geschwindigkeit. Auf einem MC 68020 Prozessor erreichen die Scanner bis
zu 200.000 und die Parser um die 400.000 Zeilen pro Minute. Diese
Geschwindigkeiten \*ubertreffen die UNIX Generatoren
.i Lex
und
.i Yacc
um die Faktoren 4 bzw. 2 bis 3.
.uh Abstract
.lp
The project UWE (compiler construction tools) has the goal to implement a
complete set of tools for the largely automatic construction of compilers.
Three tools for the analysis phase of compilers are presented:
.i Rex
is a scanner generator based on regular expressions.
The parser generator
.i Lalr
generates table-driven parsers for LALR(1) grammars that include a mechanism
for S-attribution and automatic error reporting, recovery, and repair.
The parser generator
.i Ell
generates recursive descent parsers for LL(1) grammars with a mechanism
for L-attribution and an automatic error recovery similar to
.i Lalr.
All the tools are implemented in Modula-2 and generate programs in C or
Modula-2. The outstanding property of the generated programs is their speed.
On a MC 68020 processor the scanners reach up to 200,000 and the parsers
around 400,000 lines per minute. These speeds represent in comparison to the
UNIX tools
.i Lex
and
.i Yacc
a clear improvement by factors of 4 respectively 2 to 3.
.uh "Projekt-\*Uberblick"
.pp
Das Projekt UWE (f\*ur \*Ubersetzerbau-Werkzeuge) befa\*st sich mit der
Technik des \*Ubersetzerbaus (Compiler-Baus),
der Systematisierung der dabei verwendeten
Methoden und Verfahren sowie deren Umsetzung in Generatorprogramme. Dies
schlie\*st die Entwicklung von Spezifikationstechniken f\*ur die
verschiedenen Compiler-Teile ein. Das Ziel ist die Erstellung eines
vollst\*andigen Satzes von Werkzeugen oder
Generatorprogrammen zur weitgehend automatischen Konstruktion von Compilern.
Dabei wird gegen\*uber einer Compiler~-Ent~wick~lung von Hand angestrebt, den
Konstruktionsaufwand deutlich zu re~du~zie~ren, die Fehlerfreiheit und
Zuverl\*assigkeit zu steigern und eine vergleichbare Effizienz bzw.
\*Ubersetzungsgeschwindigkeit zu erreichen.
.pp
Die Besch\*aftigung mit \*Ubersetzerbau-Werkzeugen geht auf den Lehrstuhl
f\*ur \*Ubersetzerbau an der Universit\*at Karlsruhe zur\*uck, aus dem
heraus die GMD Forschungsstelle Karlsruhe entstanden ist. Dort wurden
bereits das Parser Generating System PGS (LALR(1)-Zerteiler-Generator), der
Generator f\*ur Attribut-Grammatiken GAG (semantische Analyse) und das Code
Generator Synthese System CGSS (erzeugt Code-Generatoren aus
Maschinenbeschreibungen) entwickelt. Diese Werkzeuge wurden an der GMD
For~schungs~stelle Karlsruhe weiterentwickelt und inzwischen weltweit an
\*uber 100 Institutionen weitergegeben. Diese quasi erste
Generation von Werkzeugen erf\*ullte bereits die Forderung nach Steigerung
der Zuverl\*assigkeit der erzeugten Compiler-Teile. Das kann man am
erfolgreichen Einsatz f\*ur realistische Anwendungen sehen, wie etwa dem
Karlsruher Ada Compiler oder der Norm f\*ur PEARL. Die im folgenden
vorgestellten Werkzeuge der zweiten Generation schlie\*sen die L\*ucke im
Bereich der lexikalischen Analyse und erzeugen f\*ur die Syntaxanalyse
komfortable und effiziente Zerteiler.
.uh "Der Scanner-Generator Rex"
.pp
Der Scanner-Generator
.i Rex
wurde mit dem Ziel entwickelt, die m\*achtige
Spezifikationsmethode der regul\*aren Ausdr\*ucke mit der Generierung
m\*oglichst effizienter Scanner zu kombinieren. Der Name
.i Rex
steht f\*ur
.i "regular expression tool"
und spiegelt die Spezifikationsmethode wider.
Eine Scanner-Spezifikation besteht im Prinzip aus einer Menge regul\*arer
Ausdr\*ucke wobei jedem eine semantische Aktion zugeordnet ist. Diese
Aktionen sind beliebige Anweisungen, die in einer der Zielsprachen C oder
Modula-2 programmiert sind. Immer wenn eine Zeichenkette, die durch einen
regul\*aren Ausdruck beschrieben wird, in der Eingabe das Scanners erkannt
wird, werden die Anweisungen der zugeh\*origen Aktion ausgef\*uhrt. Um
Zeichenketten auch in Abh\*angigkeit vom Kontext erkennen zu k\*onnen stehen
sogenannte Startzust\*ande zur Behandlung von linkem Kontext zur
Verf\*ugung, und der rechte Kontext kann durch einen zus\*atzlichen
regul\*aren Ausdruck spezifiziert werden. Sollten mehrere
regul\*are Ausdr\*ucke zu einer Eingabe passen, so wird derjenige bevorzugt,
der die l\*angste Zeichenfolge erkennt. Falls immer noch mehrere
M\*oglichkeiten bestehen, wird davon der erste regul\*are Ausdruck in der
Spezifikation gew\*ahlt.
.pp
Mit
.i Rex
erzeugte Scanner stellen automatisch f\*ur jede erkannte Zeichenkette die
Zeilen- und Spalten-Position zur Verf\*ugung. F\*ur Sprachen wie Pascal und
Ada, wo Gro\*s- und Kleinbuchstaben nicht unterschieden werden, gibt es eine
Normalisierung auf Gro\*s- oder Kleinbuchstaben. Vordefinierte Regeln
gestatten das \*Uberlesen unbedeutender Zeichen wie Leerzeichen, Tabulatoren
oder Zeilenwechsel.
.pp
Die erzeugten Scanner sind tabellengesteuerte deterministische endliche
Automaten. Da die Tabellen d\*unn besetzte Matrizen sind, werden sie mit der
sogenannten "Kammvektor-Technik" komprimiert. Diese kombiniert gro\*se
Speicherreduktion mit schnellem Tabellenzugriff. Der Generator
.i Rex
ist in Modula-2 programmiert und kann zur Zeit Scanner in den Sprachen C und
Modula-2 erzeugen.
.i Rex
l\*auft inzwischen auf den Rechnern SUN/UNIX, PCS Cadmus/UNIX und VAX/BSD
UNIX bzw. ULTRIX.
.pp
Die herausragende Eigenschaft von
.i Rex
ist die Geschwindigkeit. Die erzeugten Scanner verarbeiten bis zu 200.000
ohne und 150.000 Zeilen pro Minute mit Anwendung eines Hash-Verfahrens f\*ur
Bezeichner. Dies ist die vierfache Geschwindigkeit gegen\*uber Scannern, die
mit dem UNIX-Werkzeug
.i Lex
\*([[Les75\*(]]
erzeugt wurden. In typischen F\*allen haben die ge~ne~rier~ten Scanner nur ein
Viertel der Gr\*o\*se wie bei
.i Lex
(z. B. 11 KB f\*ur Modula-2). Gew\*ohnlich ben\*otigt
.i Rex
nur 1/10 der Zeit von
.i Lex
um einen Scanner zu erzeugen. Die genannten Zahlen wurden auf einem MC 68020
Prozessor gemessen.
.uh "Scanner-Spezifikation mit Rechts-Kontext"
.pp
Die folgenden kleinen Beispiele zeigen wie Spezifikationen f\*ur
.i Rex
\*([[Gro\*(]]
aussehen. Abbildung 1 spezifiziert den Aufbau ganzer und reeller Zahlen
f\*ur die Sprache Modula-2. Die erste Zeile besagt, da\*s eine ganze Zahl
aus Folgen von Zeichen aus der Menge 0 bis 9 besteht. In Modula-2 gibt es, wie
in manchen anderen Sprachen auch, eine Stelle, an der die Strategie der
l\*angsten Zeichenkette fehlschl\*agt. So sollte etwa die Eingabe
\fC1..\fP in die Zeichenketten
"\fC1\fP" und "\fP..\fP", nicht aber in "\fC1.\fP" und "\fP.\fP" zerlegt
werden, was alles legale Modula-2-Symbole w\*aren.
.(b I
.sp 0.5
.FT
{0-9} +             : { RETURN SymDecimal; }
{0-9} + / ".."      : { RETURN SymDecimal; }
{0-9} + "." {0-9} * (E {+\\-} ? {0-9} +) ?
                    : { RETURN SymReal   ; }
".."                : { RETURN SymRange  ; }
"."                 : { RETURN SymDot    ; }

.FR
Abbildung 1: Scanner-Spezifikation mit Rechts-Kontext
.)b
.pp
Das Problem kann mit einem zus\*atzlichen regul\*aren Ausdruck gel\*ost
werden. Dieser beschreibt den rechten Kontext eines Symbols welches zu einer
Ausnahme der Strategie der l\*angsten Zeichenkette f\*uhrt. In der zweiten
Zeile trennt das Zeichen '/' zwei regul\*are Ausdr\*ucke und spezifiziert so,
da\*s eine Ziffernfolge erkannt werden soll, wenn zwei Punkte folgen.
Die restlichen Zeilen in Abbildung 1 beschreiben die weiteren Symbole,
die an diesem Problem beteiligt sind.
.uh "Scanner-Spezifikation mit Startzust\*anden"
.(z I
.FT
GLOBAL  {VAR NestingLevel: CARDINAL;}
.sp 0.3
BEGIN   {NestingLevel := 0;}
.sp 0.3
EOF     {IF yyStartState = Comment THEN Error ("unclosed comment"); END;}
.sp 0.3
DEFINE  CmtCh   = - {*(\\t\\n}.
.sp 0.3
START   Comment
.sp 0.3
RULES
           "(*" : {INC (NestingLevel); yyStart (Comment);}
.sp 0.3
#Comment#  "*)" : {DEC (NestingLevel);
                   IF NestingLevel = 0 THEN yyStart (STD); END;}
.sp 0.3
#Comment#  "(" | "*" | CmtCh + : {}

.FR
Abbildung 2: Scanner Spezifikation f\*ur geschachtelte Kommentare
.)z
.pp
Manche Probleme lassen sich mit regul\*aren Ausdr\*ucken allein nicht
l\*osen. So erfordert etwa die Erkennung geschachtelter Kommentare in
Modula-2 einen zus\*atzlichen Z\*ahler und den Einsatz von Startzust\*anden
(Abbildung 2). Der Z\*ahler wird im Abschnitt GLOBAL de~kla~riert und im
Abschnitt BEGIN initialisiert. Der Abschnitt START vereinbart einen
Startzustand namens
.i Comment.
Regeln, vor denen ein Startzustand steht, sind nur wirksam, wenn sich der
Scanner in diesem Startzustand befindet. Die erste Regel erkennt \*offnende
Kommentarklammern, erh\*oht den Schachtelungsz\*ahler und schaltet in den
Startzustand Comment um. In letzterem sind alle 3 Regeln wirksam. Entweder
werden Kommentarzeichen \*uberlesen oder bei schlie\*senden
Kommentarklammern der Schachtelungsz\*ahler erniedrigt. Erreicht dieser den
Wert Null, so ist der Kommentar zu Ende, und es wird wieder in den
vordefinierten Startzustand STD zur\*uckgekehrt. Im Abschnitt EOF stehen
Aktionen, die beim Erreichen des Eingabeendes auszuf\*uhren sind. Hier wird
im Falle einer fehlenden Kommentarklammer ein entsprechender Fehler
gemeldet.
.uh "Vergleich von Scanner-Generatoren"
.pp
Die Tabelle 1 vergleicht
.i Rex
mit dem UNIX Scanner-Generator
.i Lex
und dem Lex-Nachbau
.i Flex
(f\*ur fast Lex). Die Tabelle vergleicht die Spezifikationstechniken, die
Werkzeuge und die generierten Scanner. Die spezifikations-abh\*angigen
Zahlen wie Ge~ne~rie~rungs~zeit und Scanner-Gr\*o\*se gelten f\*ur einen
Modula-2-Scanner. Die Zahlen wurden auf einem MC 68020 Prozessor gemessen.
.(z
.ce
Tabelle 1: Vergleich einiger Scanner-Generatoren
.sp
.TS
tab (;) box center;
l | l l l
l | l l l.
                  ;Lex    ;Flex   ;Rex
_
Spezifikationsmethode;regul\*are;regul\*are;regul\*are
                  ;  Ausdr\*ucke;  Ausdr\*ucke;  Ausdr\*ucke
semantische Aktionen;ja     ;ja     ;ja 
Rechts-Kontext    ;ja     ;ja     ;ja 
Links-Kontext (Startzust\*ande);ja     ;ja     ;ja 
_
Konfliktl\*osung  ;l\*angste Folge;l\*angste Folge;l\*angste Folge
                  ;erste Regel;erste Regel;erste Regel
_
Quellposition     ;Zeile   ;-      ;Zeile + Spalte
Normalisierung    ;-      ;ja     ;ja 
vordefinierte Regeln zum;-     ;-      ;ja 
   \*Uberlesen
mehrere L\*osungen (REJECT);ja     ;ja     ;-
Anpassung interner;von Hand;automatisch;automatisch
   Datenstrukturen
_
Scanneralgorithmus;tabellengesteuert;tabellengesteuert;tabellengesteuert
Tabellenkompression;Kammvektor;Kammvektor;Kammvektor
_
Implementierungssprache;C      ;C      ;Modula-2
Zielsprachen      ;C      ;C      ;C, Modula-2
_
Geschwindigkeit [Zeilen/Min.]
   ohne Hashing   ;36.400 ;139.000;182.700
   mit Hashing    ;34.700 ;118.000;141.400
_
Tabellengr\*o\*se [Bytes];39.200 ;57.300 ;4.400
Scanner-Gr\*o\*se [Bytes];43.800 ;64.100 ;11.200
_
Generierungszeit [Sek.];73,7;7,2   ;4,9
.TE
.)z
.uh "Der Parser-Generator Lalr"
.pp
Wie
.i Rex
wurde der Parser-Generator \fILalr\fP mit dem Ziel entwickelt eine m\*achtige
Spezifikationstechnik f\*ur kontextfreie Grammatiken mit der Erzeugung
effizienter Parser (Zerteiler) zu kombinieren. Der Name
.i Lalr
nimmt Bezug auf die Klasse der LALR(1)-Grammatiken, f\*ur die Zerteiler
erzeugt werden k\*onnen. Diese Grammatiken k\*onnen in erweiterter BNF
geschrieben sein. Jede Grammatikregel kann mit semantischen Aktionen
versehen werden, welche wiederum aus beliebigen Anweisungen der Zielsprache
bestehen. Wenn der erzeugte Zerteiler eine Grammatikregel erkannt hat,
werden die zugeordneten Aktionen ausgef\*uhrt. Es steht ein Mechanismus zur
S-Attributierung zur Verf\*ugung, d. h. abgeleitete Attribute k\*onnen
w\*ahrend der Zerteilung berechnet werden.
.pp
Geh\*ort eine Grammatik nicht zur LALR(1)-Klasse, so stellt der Generator
LR-Konflikte fest. Das Problem dabei besteht darin, f\*ur einen Konflikt
aussagekr\*aftige Information zu liefern, um das Problem in der Grammatik
finden zu k\*onnen und dann f\*ur Abhilfe zu sorgen. W\*ahrend andere
Generatoren meist nur den Konflikt in Begriffen von internen Zust\*anden und
Situationen melden gibt
.i Lalr
Ableitungsb\*aume aus, die die Konfliktbehebung wesentlich erleichtern.
Syntaxfehler werden von den generierten Zerteilern vollautomatisch
behandelt. Dies schlie\*st Fehlermeldung, Wiederaufsetzen der Analyse und
Fehlerreparatur ein. (Die genannten Eigenschaften werden unten n\*aher
ausgef\*uhrt.)
.pp
Die erzeugten Parser sind tabellengesteuert, wobei die Tabellen wie im Fall
von
.i Rex
mittels Kammvektor-Technik komprimiert werden. Der Generator
.i Lalr
ist in Modula-2 programmiert und kann zur Zeit Zerteiler in C und Modula-2
erzeugen. Wie
.i Rex
l\*auft
.i Lalr
inzwischen auf den Rechnern SUN/UNIX, PCS Cadmus/UNIX und VAX/BSD
UNIX bzw. ULTRIX.
.pp
Mit
.i Lalr
erzeugte Zerteiler sind 2 bis 3 Mal schneller als mit dem UNIX Werkzeug
.i Yacc
\*([[Joh75\*(]]
generierte. Sie erreichen eine Geschwindigkeit von bis zu 400.000 Zeilen pro
Minute auf einem MC 68020 Prozessor, wobei die Zeit f\*ur den Scanner nicht
ber\*ucksichtigt ist. Von der Gr\*o\*se her sind die Zerteiler im Vergleich
zu
.i Yacc
etwas gr\*o\*ser (z. B. 37 KB f\*ur Ada). Im folgenden werden einige
Eigenschaften von
.i Lalr
n\*aher vorgestellt.
.uh "S-Attributierung"
.pp
Die Spezifikation eines Zerteilers\*([<\*([[GrV\*(]]\*(>]
folgt dem Stil einer
.i Rex
Spezifikation. Abbildung 3 zeigt ein einfaches Beispiel f\*ur einen
Tischrechner, welcher arithmetische Ausdr\*ucke akzeptiert, die aus den
Operatoren + und * sowie Klammern und Zahlen aufgebaut sind.
Die in den geschweiften Klammern stehenden semantischen Aktionen sorgen
f\*ur die Berechnung der Ausdr\*ucke. Dazu wird dem Nichtterminal
.i expr
und dem Terminal
.i number
das Attribut
.i value
zugeordnet. Mit $i wird in den semantischen Aktionen auf die Attribute
zugegriffen. Dabei bedeuten $i das i-te Grammatiksymbol der rechten Seite
und $$ das Nichtterminal der linken Seite einer Regel.
.(b I
.sp 0.5
.FT
expr : expr '+' expr { $$.value := $1.value + $3.value; } .
expr : expr '*' expr { $$.value := $1.value * $3.value; } .
expr : '(' expr ')'  { $$.value := $2.value; } .
expr : number        { $$.value := $1.value; } .

.FR
Abbildung 3: Grammatikregeln mit S-Attributierung
.)b
.uh "Mehrdeutige Grammatiken"
.pp
Die Grammatik in Abbildung 3 und die Regeln in Abbildung 4 sind typische
Beispiele f\*ur mehrdeutige Grammatiken. Wie bei
.i Yacc
lassen sich daraus resultierende LR-Konflikte durch die Angabe von
Priorit\*at und Assoziativit\*at f\*ur Terminale (Operatoren) l\*osen.
Abbildung 5 zeigt ein Beispiel. Die Zeilen stellen zunehmende Priorit\*aten
dar. LEFT, RIGHT und NONE spezifizieren links-assoziative,
rechts-assoziative bzw. Operatoren ohne Assoziativit\*at.
.(b I
.sp 0.5
.FT
stmt : 'IF' expr 'THEN' stmt               PREC LOW
     | 'IF' expr 'THEN' stmt 'ELSE' stmt   PREC HIGH .

.FR
Abbildung 4: Mehrdeutige Grammatikregeln (Dangling Else Problem von Pascal)
.)b
.(b I
.FT
OPER  LEFT '+'
      LEFT '*'
      NONE LOW
      NONE HIGH

.FR
Abbildung 5: L\*osen von LR-Konflikten mit Priorit\*at und Assoziativit\*at
.)b
.uh "Beschreibung von LR-Konflikten"
.pp
Zur leichteren Lokalisierung des Grundes f\*ur LR-Konflikte wurde eine von
DeRemer und Pennello\*([<\*([[DeP82\*(]]\*(>]
vorgeschlagene Methode aufgegriffen. Neben der Art des
Konflikts und den beteiligten Situationen wie bei anderen LR-Generatoren
wird zus\*atzlich ein Ableitungsbaum ausgegeben.
Eine Situation (item) ist eine Grammatikregel mit einem zus\*atzlichen Punkt
in der rechten
Seite, welcher angibt, wie weit diese Regel bereits analysiert wurde.
Abbildung 6 zeigt ein Beispiel.
.(z I
.FT
State 266
.sp 0.3
read reduce conflict
.sp 0.3
\&program End-of-Tokens 
\&'PROGRAM' identifier params ';' block '.' 
\&................................:
\&:
\&labels consts types vars procs 'BEGIN' stmts 'END' 
\&.......................................:
\&:
\&stmt 
\&'IF' expr 'THEN' stmt 'ELSE' stmt 
.\"                  :
.\"                  'IF' expr 'THEN' stmt 
                 :
reduce   stmt -> 'IF' expr 'THEN' stmt.  {'ELSE'}  ?
read     stmt -> 'IF' expr 'THEN' stmt.'ELSE' stmt  ?

.FR
Abbildung 6: Ableitungsbaum f\*ur einen LR-Konflikt (Dangling Else Problem)
.)z
.pp
Der Baum zeigt wie die Situationen und die Vorschauzeichen in den
Konfliktzustand gelangen. Im allgemeinen wird f\*ur jede beteiligte
Situation ein eigener Baum ausgegeben. Sind die B\*aume jedoch gleich, wie
das in Abbildung 6 der Fall ist, so wird nur ein Baum ausgegeben.
Jeder Baum besteht aus drei
Teilen: Ein Anfangsteil beginnt mit dem Startsymbol. An einem bestimmten
Knoten (Regel) erkl\*aren zwei weitere Teilb\*aume die Entstehung der
Situation und der Vorschau.
.pp
Jede Zeile enth\*alt die rechte Seite einer Grammatikregel. Normalerweise
ist diese rechte Seite so einger\*uckt, da\*s sie unter dem Nichtterminal
der linken Seite beginnt. Um zu lange Zeilen zu vermeiden, verweisen
punktierte Linienz\*uge ebenfalls zum Nichtterminal der linken Seite und
erlauben so am linken Rand fortzufahren. In Abbildung 6 besteht der
Anfangsteil des Baumes aus 5 Zeilen, wobei die punktierten Zeilen nicht
gez\*ahlt wurden. Die Symbole 'stmt' und 'ELSE' sind die Wurzeln der beiden
weiteren Teilb\*aume. Diese Stelle ist mit einem "\*uberfl\*ussigen"
Doppelpunkt gekennzeichnet. Nach einem Ableitungsschritt werden im linken
Teilbaum die Konfliktsituationen erreicht. Der rechte Teilbaum besteht in
diesem Fall nur aus dem Wurzelknoten (dem Symbol 'ELSE') und beschreibt das
Vorschauzeichen. Im allgemeinen kann hier ein Baum von beliebiger Gr\*o\*se
stehen. Der LR-Konflikt kann in diesem Baumfragment leicht abgelesen werden.
Falls bedingte Anweisungen wie gezeigt geschachtelt werden liegt ein
Lies-Reduziere-Konflikt vor.
.uh Fehlerbehandlung
.pp
Die generierten Zerteiler enthalten Information und Algorithmen um
Syntaxfehler voll~auto~matisch zu behandeln. Es wird die vollst\*andige,
r\*ucksetzungsfreie Methode von R\*ohrich
\*([[R\*oh76\*(],R\*oh80\*(],R\*oh82\*(]]
verwendet. Diese schlie\*st Fehlermeldungen, Wiederaufsetzen und
Fehlerreparatur ein. Jede syntaktisch fehlerhafte Eingabe wird gedachterweise
in ein korrektes Programm transformiert. Dies bewirkt, da\*s nur korrekte
Folgen von semantischen Aktionen ausgef\*uhrt werden. Dadurch brauchen
sp\*atere Compiler-Phasen wie die semantische Analyse auf Syntaxfehler
keine R\*ucksicht nehmen.
.i Lalr
stellt einen Modul zur Sammlung oder Meldung von Fehlern zur Verf\*ugung,
der leicht an Benutzerw\*unsche anpa\*sbar ist. Ohne Modifikation werden
Fehlermeldungen wie in Abbildung 7 ausgegeben. Die Fehlerbehandlung l\*auft
in folgenden Schritten ab:
.(z I
Quellprogramm:
.sp 0.5
.FT
program test (output);
begin
   if (a = b] write (a);
end.
.sp 0.5
.FR
Fehlermeldungen:
.sp 0.5
.FT
3, 13: Error       syntax error     
3, 13: Information expected symbols: ')' '*' '+' '-' '/' '<' '<='
                   '=' '<>' '>' '>=' 'AND' 'DIV' 'IN' 'MOD' 'OR'
3, 15: Information restart point    
3, 15: Repair      symbol inserted : ')'
3, 15: Repair      symbol inserted : 'THEN'

.FR
Abbildung 7: Beispiel einer automatischen Fehlerbehandlung
.)z
.ip - 0.5c
Die Position des Syntaxfehlers wird gemeldet.
.ip - 0.5c
Alle Terminale, die eine korrekte Fortsetzung des Programms w\*aren, werden
berechnet und gemeldet.
.ip - 0.5c
Alle Terminale, die zum Wiederaufsetzen der Zerteilung geeignet sind, werden
berechnet. Eine minimale Folge von Terminalen wird \*uberlesen, bis eines
dieser Symbole gefunden wird.
.ip - 0.5c
Die Position des Wiederaufsetzens wird gemeldet.
.ip - 0.5c
Die Zerteilung wird im sogenannten Reparaturmodus fortgesetzt. In diesem
Modus verh\*alt sich der Zerteiler wie gewohnt ohne jedoch Terminale von der
Eingabe zu lesen. Stattdessen wird eine minimale Folge von Terminalen
generiert, die gedachterweise die \*uberlesenen Terminale ersetzt. Diese
generierten Terminale werden gemeldet. Der Zerteiler bleibt in diesem Modus,
bis das Terminal am Aufsetzpunkt akzeptiert werden kann. Danach wird der
Reparaturmodus verlassen und die Zerteilung normal fortgesetzt.
.uh "Der Parser-Generator Ell"
.pp
Der Parser-Generator
.i Ell 
erzeugt aus LL(1)-Grammatiken Zerteiler nach dem Verfahren des rekursiven
Abstiegs. Die Grammatiken k\*onnen in erweiterter BNF geschrieben sein und
semantische Aktionen enthalten. Innerhalb der Aktionen ist es m\*oglich eine
L-Attribut-Berechnung zu spezifizieren, die w\*ahrend der Zerteilung
ausgewertet wird. Es k\*onnen sowohl erworbene als auch abgeleitete
Attribute benutzt werden, solange die Auswertung in einem
Links-Rechts-Durchlauf des Ableitungsbaums m\*oglich ist. Syntaxfehler
werden wie bei
.i Lalr
vollautomatisch behandelt mit Fehlermeldungen, Wiederaufsetzen und
Fehlerreparatur. Das Werkzeug ist ebenfalls in Modula-2 programmiert und
kann Zerteiler in C und Modula-2 erzeugen. Die Geschwindigkeit der erzeugten
Zerteiler liegt im Augenblick bei 450.000 Zeilen pro Minute.
Zur Zeit wird an einigen Verbesserungen gearbeitet, wodurch
dieser Wert noch steigen wird.
Der Speicherbedarf liegt in der Gr\*o\*senordnung von
tabellengesteuerten Zerteilern (z. B. 14 KB f\*ur Modula-2).
.(z I
.FT
.\" EXPORT      {
.\" FROM Scanner        IMPORT tScanAttribute;
.\" TYPE tParsAttribute = RECORD val: tScanAttribute; END;
.\" }
.\" 
.\" GLOBAL      {
.\" FROM StdIO  IMPORT WriteI, WriteNl;
.\" FROM Scanner        IMPORT BeginScanner;
.\" }
.\" 
.\" BEGIN       { BeginScanner; }
.\" 
.\" TOKEN
.\" 
.\"    Integer  = 1
.\"    '('              = 2
.\"    ')'              = 3
.\"    '+'              = 4
.\"    '-'              = 5
.\"    '*'              = 6
.\"    '/'              = 7
.\"    'NL'             = 8
.\" 
.\" RULE
.\" 
ExpList : ( Expr ';'    { Write (Expr1.value, 10);                      }
          ) *
        .
Expr    : ( ['+'] Term  { Expr0.value := Term1.value;                   }
          | '-' Term    { Expr0.value := - Term2.value;                 }
          )
          ( '+' Term    { INC (Expr0.value, Term3.value);               }
          | '-' Term    { DEC (Expr0.value, Term4.value);               }
          ) *
        .
Term    : Factor        { Term0.value := Factor1.value;                 }
          ( '*' Factor  { Term0.value := Term0.value * Factor2.value;   }
          | '/' Factor  { Term0.value := Term0.value DIV Factor3.value; }
          ) *
        .
Factor  : Number        { Factor0.value := Number1;                     }
        | '(' Expr ')'  { Factor0.value := Expr1.value;                 }
        .

.FR
Abbildung 8: LL(1)-Grammatik f\*ur einfachen Tischrechner
.)z
.pp
Abbildung 8 zeigt die Spezifikation eines einfachen Tischrechners mit 4
Grundrechenarten f\*ur
.i Ell.
Die Spezifikation erfolgt durch eine LL(1)-Grammatik in erweiterter BNF. Die
in geschweifte Klammern eingeschlossenen semantischen Aktionen berechnen
wiederum den Wert eines eingegebenen Ausdrucks und geben ihn aus. Der
Zugriff auf Attribute erfolgt hier \*uber die Namen der Grammatiksymbole. Da
mehrere gleichnamige Symbole in einer Regel vorkommen k\*onnen werden zur
Unterscheidung an die Namen Zahlen angeh\*angt. Die Zahl 0 bezeichnet das
Nichtterminal der linken Seite. Mit Zahlen gr\*o\*ser 0 werden gleichnamige
Symbole der rechten Seite von links nach rechts durchgez\*ahlt.
.uh "Vergleich von Parser-Generatoren"
.pp
Abschlie\*send vergleicht die Tabelle 2 die Parser-Generatoren
.i Lalr
und
.i Ell
mit dem UNIX Werkzeug
.i Yacc,
mit dem Yacc-Nachbau
.i Bison
und mit PGS (siehe oben). Die Tabelle fa\*st die angesprochenen
Eigenschaften zusammen und sollte selbsterkl\*arend sein. Die
sprachabh\*angigen Zahlen sind ohne Laufzeit und Speicherbedarf f\*ur
Scanner und beziehen sich auf Experimente mit einem Parser f\*ur Modula-2.
.(z
.ce
Tabelle 2: Vergleich einiger Parser-Generatoren
.sp
.TS
tab (;) box center;
l1 |1 l1 l1 l1 l1 l
l1 |1 l1 l1 l1 l1 l.
                 ;Bison  ;Yacc   ;PGS    ;Lalr   ;Ell
_
Spezifikationsmethode;BNF    ;BNF    ;EBNF   ;EBNF   ;EBNF
Grammatikklasse  ;LALR(1);LALR(1);LALR(1);LALR(1);LL(1)
                 ;       ;       ;LR(1)  ;       ;
                 ;       ;       ;SLR(1) ;       ;
semantische Aktionen;ja     ;ja     ;ja     ;ja     ;ja 
S-Attributierung ;numerisch;numerisch;symbolisch;numerisch;-
L-Attributierung ;-      ;-      ;-      ;-      ;symbolisch
_
Konfliktmeldung  ;Zustand,;Zustand,;Zustand,;Ableitungs-;-
                 ;Situation;Situation;Situation;baum   ;
Konfliktl\*osung ;Priorit\*at;Priorit\*at;Modifikation;Priorit\*at;
                 ;Assoziativit\*at;Assoziativit\*at; ;Assoziativit\*at;
Kettenregelelimination;-      ;-      ;ja     ;-      ;-
Fehlerbehandlung ;von Hand;von Hand;automatisch;automatisch;automatisch
Fehlerreparatur  ;-      ;-      ;ja     ;ja     ;ja
_
Zerteilungsverfahren;tabellen-;tabellen-;tabellen-;tabellen-;rekursiver
                 ;gesteuert;gesteuert;gesteuert;gesteuert;Abstieg
Tabellenkompression;Kammvektor;Kammvektor;Kammvektor;Kammvektor;-
_
Implementgs.-Sprache;C      ;C      ;Pascal ;Modula-2; Modula-2
Zielsprachen     ;C      ;C      ;C      ;C      ;C
                 ;       ;       ;Modula-2;Modula-2;Modula-2
                 ;       ;       ;Pascal
                 ;       ;       ;Ada
_
Geschwindigkeit  ;105.000;184.000;200.000;385.000;437.000
   [Zeilen/Min.]
.\" speed [lines/min.];  ;111,000;219,000;366,000;447,000
.\" speed: exp. 1;       ;215,000;405,000
.\" speed: exp. 2;       ;225,000;250,000;400,000;900,000
_
Tabellengr\*o\*se [Bytes];8.004;10.364 ;11.268 ;11.795 ;-
Zerteilergr\*o\*se [Bytes];11.136;12.548 ;17.616 ;17.416 ;14.344
_
Generierungszeit [Sek.];5,0    ;19,6   ;69,5   ;29,6   ;6,4
.TE
.)z
.uh Zusammenfassung
.pp
Die \*Ubersetzerbau-Werkzeuge
.i "Rex, Lalr"
und
.i Ell
wurden mit dem Ziel entworfen, m\*achtige Spezifikationstechniken mit der
automatischen Erzeugung effizienter Compiler-Teile zu kombinieren.
Es k\*onnen Scanner und Parser in C und Modula-2 erzeugt werden, die sich
vor allem durch ihre Geschwindigkeit auszeichnen. Die Scanner verarbeiten bis
zu 200.000 und die Parser etwa 400.000 Zeile pro Minute auf einem MC 68020
Prozessor. Zusammen erreichen Scanner und Parser mehr als 100.000 Zeilen pro
Minute oder fast 2000 Zeilen pro Sekunde.
.pp
Da erfahrungsgem\*a\*s der
Scanner einen Gro\*steil der gesamten \*Ubersetzungszeit verbraucht,
hoffen wir vollst\*andige Compiler mit einer Geschwindigkeit von 1000 Zeilen
pro Sekunde automatisch erzeugen zu k\*onnen.
Im Augenblick wird an der Vervollst\*andigung des Werkzeugsatzes gearbeitet.
Dies betrifft Werkzeuge f\*ur die semantische Analyse auf der Basis
attributierter Grammatiken, Werkzeuge f\*ur die Transformation wie etwa die
Erzeugung einer Zwischensprache und Werkzeuge f\*ur die Codeerzeugung auf
der Basis von Musterabgleich (pattern matching).
.pp
.sz -2
Der Generator
.i Lalr
wurde von Bertram Vielsack programmiert, der auch die
experimentellen Ergebnisse f\*ur den Vergleich der Parser-Generatoren
beitrug. Der Generator
.i Ell
wurde von Doris Kuske programmiert.
.fi
.sp
.[]
.[-
.ds [F DeP82
.ds [A F\*(p] DeRemer
.as [A \*(n]T\*(p]\*(a]J\*(p] Pennello
.ds [T Efficient Computation of LALR(1) Look-Ahead Sets
.ds [J ACM Trans. Prog. Lang. and Systems
.ds [V 4
.nr [P 1
.ds [P 615-649
.ds [N 4
.ds [D Oct. 1982
.][
.[-
.ds [F Gro
.ds [A J\*(p] Grosch
.ds [T Rex - A Scanner Generator
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 5
.ds [N 5
.][
.[-
.ds [F GrV
.ds [A J\*(p] Grosch
.as [A \*(n]B\*(p] Vielsack
.ds [T The Parser Generators Lalr and Ell
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 8
.ds [N 8
.][
.[-
.ds [F Joh75
.ds [A S\*(p]\*(a]C\*(p] Johnson
.ds [T Yacc \(em  Yet Another Compiler-Compiler
.ds [R Computer Science Technical Report 32
.ds [I Bell Telephone Laboratories
.ds [C Murray Hill, NJ
.ds [D July 1975
.][
.[-
.ds [F Les75
.ds [A M\*(p]\*(a]E\*(p] Lesk
.ds [T LEX \(em A Lexical Analyzer Generator
.ds [R Computing Science Technical Report 39
.ds [I Bell Telephone Laboratories
.ds [C Murray Hill, NJ
.ds [D 1975
.][
.[-
.ds [F R\*oh76
.ds [A J\*(p] R\\*ohrich
.ds [T Syntax-Error Recovery in LR-Parsers
.ds [E H\*(p] Schneider
.ds [E H.-J\*(p] Schneider
.as [E \*(n]M\*(p] Nagl
.nr [E 2
.ds [S Programmiersprachen, 4. Fachtagung der GI, Erlangen
.ds [B Informatik-Fachberichte
.ds [V 1
.nr [P 1
.ds [P 175-184
.ds [C Berlin
.ds [I Springer Verlag
.ds [D 1976
.][
.[-
.ds [F R\*oh80
.ds [A J\*(p] R\\*ohrich
.ds [T Methods for the Automatic Construction of Error Correcting Parsers
.ds [J Acta Inf.
.ds [V 13
.ds [N 2
.nr [P 1
.ds [P 115-139
.ds [D 1980
.][
.[-
.ds [F R\*oh82
.ds [A J\*(p] R\\*ohrich
.ds [T Behandlung syntaktischer Fehler
.ds [J Informatik Spektrum
.ds [V 5
.ds [N 3
.nr [P 1
.ds [P 171-184
.ds [D 1982
.][
.he ''''
.bp 1
.lp
.b Inhalt
.sp
.xp
.ex



.bp
.b T\*atigkeitsbeschreibung:
.lp
Josef Grosch, Dr. Ing., Dipl. Inf., wissenschaftlicher Mitarbeiter der GMD
Forschungsstelle f\*ur Programmstrukturen an der Universit\*at Karlsruhe,
Leiter des Projekts UWE (\*Ubersetzerbau-Werkzeuge).
.bp
.(b I
.sp 0.5
.FT
{0-9} +             : { RETURN SymDecimal; }
{0-9} + / ".."      : { RETURN SymDecimal; }
{0-9} + "." {0-9} * (E {+\\-} ? {0-9} +) ?
                    : { RETURN SymReal   ; }
".."                : { RETURN SymRange  ; }
"."                 : { RETURN SymDot    ; }

.FR
Abbildung 1: Scanner-Spezifikation mit Rechts-Kontext
.)b
.bp
.(b I
.FT
GLOBAL  {VAR NestingLevel: CARDINAL;}
.sp 0.3
BEGIN   {NestingLevel := 0;}
.sp 0.3
EOF     {IF yyStartState = Comment THEN Error ("unclosed comment"); END;}
.sp 0.3
DEFINE  CmtCh   = - {*(\\t\\n}.
.sp 0.3
START   Comment
.sp 0.3
RULES
           "(*" : {INC (NestingLevel); yyStart (Comment);}
.sp 0.3
#Comment#  "*)" : {DEC (NestingLevel);
                   IF NestingLevel = 0 THEN yyStart (STD); END;}
.sp 0.3
#Comment#  "(" | "*" | CmtCh + : {}

.FR
Abbildung 2: Scanner Spezifikation f\*ur geschachtelte Kommentare
.)b
.bp
.(b
.ce
Tabelle 1: Vergleich einiger Scanner-Generatoren
.sp
.TS
tab (;) box center;
l | l l l
l | l l l.
                  ;Lex    ;Flex   ;Rex
_
Spezifikationsmethode;regul\*are;regul\*are;regul\*are
                  ;  Ausdr\*ucke;  Ausdr\*ucke;  Ausdr\*ucke
semantische Aktionen;ja     ;ja     ;ja 
Rechts-Kontext    ;ja     ;ja     ;ja 
Links-Kontext (Startzust\*ande);ja     ;ja     ;ja 
_
Konfliktl\*osung  ;l\*angste Folge;l\*angste Folge;l\*angste Folge
                  ;erste Regel;erste Regel;erste Regel
_
Quellposition     ;Zeile   ;-      ;Zeile + Spalte
Normalisierung    ;-      ;ja     ;ja 
vordefinierte Regeln zum;-     ;-      ;ja 
   \*Uberlesen
mehrere L\*osungen (REJECT);ja     ;ja     ;-
Anpassung interner;von Hand;automatisch;automatisch
   Datenstrukturen
_
Scanneralgorithmus;tabellengesteuert;tabellengesteuert;tabellengesteuert
Tabellenkompression;Kammvektor;Kammvektor;Kammvektor
_
Implementierungssprache;C      ;C      ;Modula-2
Zielsprachen      ;C      ;C      ;C, Modula-2
_
Geschwindigkeit [Zeilen/Min.]
   ohne Hashing   ;36.400 ;139.000;182.700
   mit Hashing    ;34.700 ;118.000;141.400
_
Tabellengr\*o\*se [Bytes];39.200 ;57.300 ;4.400
Scanner-Gr\*o\*se [Bytes];43.800 ;64.100 ;11.200
_
Generierungszeit [Sek.];73,7;7,2   ;4,9
.TE
.)b
.bp
.(b I
.sp 0.5
.FT
expr : expr '+' expr { $$.value := $1.value + $3.value; } .
expr : expr '*' expr { $$.value := $1.value * $3.value; } .
expr : '(' expr ')'  { $$.value := $2.value; } .
expr : number        { $$.value := $1.value; } .

.FR
Abbildung 3: Grammatikregeln mit S-Attributierung
.)b
.bp
.(b I
.sp 0.5
.FT
stmt : 'IF' expr 'THEN' stmt               PREC LOW
     | 'IF' expr 'THEN' stmt 'ELSE' stmt   PREC HIGH .

.FR
Abbildung 4: Mehrdeutige Grammatikregeln (Dangling Else Problem von Pascal)
.)b
.bp
.(b I
.FT
OPER  LEFT '+'
      LEFT '*'
      NONE LOW
      NONE HIGH

.FR
Abbildung 5: L\*osen von LR-Konflikten mit Priorit\*at und Assoziativit\*at
.)b
.bp
.(b I
.FT
State 266
.sp 0.3
read reduce conflict
.sp 0.3
\&program End-of-Tokens 
\&'PROGRAM' identifier params ';' block '.' 
\&................................:
\&:
\&labels consts types vars procs 'BEGIN' stmts 'END' 
\&.......................................:
\&:
\&stmt 
\&'IF' expr 'THEN' stmt 'ELSE' stmt 
.\"                  :
.\"                  'IF' expr 'THEN' stmt 
                 :
reduce   stmt -> 'IF' expr 'THEN' stmt.  {'ELSE'}  ?
read     stmt -> 'IF' expr 'THEN' stmt.'ELSE' stmt  ?

.FR
Abbildung 6: Ableitungsbaum f\*ur einen LR-Konflikt (Dangling Else Problem)
.)b
.bp
.(b I
Quellprogramm:
.sp 0.5
.FT
program test (output);
begin
   if (a = b] write (a);
end.
.sp 0.5
.FR
Fehlermeldungen:
.sp 0.5
.FT
3, 13: Error       syntax error     
3, 13: Information expected symbols: ')' '*' '+' '-' '/' '<' '<='
                   '=' '<>' '>' '>=' 'AND' 'DIV' 'IN' 'MOD' 'OR'
3, 15: Information restart point    
3, 15: Repair      symbol inserted : ')'
3, 15: Repair      symbol inserted : 'THEN'

.FR
Abbildung 7: Beispiel einer automatischen Fehlerbehandlung
.)b
.bp
.(b I
.FT
.\" EXPORT      {
.\" FROM Scanner        IMPORT tScanAttribute;
.\" TYPE tParsAttribute = RECORD val: tScanAttribute; END;
.\" }
.\" 
.\" GLOBAL      {
.\" FROM StdIO  IMPORT WriteI, WriteNl;
.\" FROM Scanner        IMPORT BeginScanner;
.\" }
.\" 
.\" BEGIN       { BeginScanner; }
.\" 
.\" TOKEN
.\" 
.\"    Integer  = 1
.\"    '('              = 2
.\"    ')'              = 3
.\"    '+'              = 4
.\"    '-'              = 5
.\"    '*'              = 6
.\"    '/'              = 7
.\"    'NL'             = 8
.\" 
.\" RULE
.\" 
ExpList : ( Expr ';'    { Write (Expr1.value, 10);                      }
          ) *
        .
Expr    : ( ['+'] Term  { Expr0.value := Term1.value;                   }
          | '-' Term    { Expr0.value := - Term2.value;                 }
          )
          ( '+' Term    { INC (Expr0.value, Term3.value);               }
          | '-' Term    { DEC (Expr0.value, Term4.value);               }
          ) *
        .
Term    : Factor        { Term0.value := Factor1.value;                 }
          ( '*' Factor  { Term0.value := Term0.value * Factor2.value;   }
          | '/' Factor  { Term0.value := Term0.value DIV Factor3.value; }
          ) *
        .
Factor  : Number        { Factor0.value := Number1;                     }
        | '(' Expr ')'  { Factor0.value := Expr1.value;                 }
        .

.FR
Abbildung 8: LL(1)-Grammatik f\*ur einfachen Tischrechner
.)b
.bp
.(b
.ce
Tabelle 2: Vergleich einiger Parser-Generatoren
.sp
.TS
tab (;) box center;
l1 |1 l1 l1 l1 l1 l
l1 |1 l1 l1 l1 l1 l.
                 ;Bison  ;Yacc   ;PGS    ;Lalr   ;Ell
_
Spezifikationsmethode;BNF    ;BNF    ;EBNF   ;EBNF   ;EBNF
Grammatikklasse  ;LALR(1);LALR(1);LALR(1);LALR(1);LL(1)
                 ;       ;       ;LR(1)  ;       ;
                 ;       ;       ;SLR(1) ;       ;
semantische Aktionen;ja     ;ja     ;ja     ;ja     ;ja 
S-Attributierung ;numerisch;numerisch;symbolisch;numerisch;-
L-Attributierung ;-      ;-      ;-      ;-      ;symbolisch
_
Konfliktmeldung  ;Zustand,;Zustand,;Zustand,;Ableitungs-;-
                 ;Situation;Situation;Situation;baum   ;
Konfliktl\*osung ;Priorit\*at;Priorit\*at;Modifikation;Priorit\*at;
                 ;Assoziativit\*at;Assoziativit\*at; ;Assoziativit\*at;
Kettenregelelimination;-      ;-      ;ja     ;-      ;-
Fehlerbehandlung ;von Hand;von Hand;automatisch;automatisch;automatisch
Fehlerreparatur  ;-      ;-      ;ja     ;ja     ;ja
_
Zerteilungsverfahren;tabellen-;tabellen-;tabellen-;tabellen-;rekursiver
                 ;gesteuert;gesteuert;gesteuert;gesteuert;Abstieg
Tabellenkompression;Kammvektor;Kammvektor;Kammvektor;Kammvektor;-
_
Implementgs.-Sprache;C      ;C      ;Pascal ;Modula-2; Modula-2
Zielsprachen     ;C      ;C      ;C      ;C      ;C
                 ;       ;       ;Modula-2;Modula-2;Modula-2
                 ;       ;       ;Pascal
                 ;       ;       ;Ada
_
Geschwindigkeit  ;105.000;184.000;200.000;385.000;437.000
   [Zeilen/Min.]
.\" speed [lines/min.];  ;111,000;219,000;366,000;447,000
.\" speed: exp. 1;       ;215,000;405,000
.\" speed: exp. 2;       ;225,000;250,000;400,000;900,000
_
Tabellengr\*o\*se [Bytes];8.004;10.364 ;11.268 ;11.795 ;-
Zerteilergr\*o\*se [Bytes];11.136;12.548 ;17.616 ;17.416 ;14.344
_
Generierungszeit [Sek.];5,0    ;19,6   ;69,5   ;29,6   ;6,4
.TE
.)b
