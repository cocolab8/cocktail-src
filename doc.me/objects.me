.lf 1 /tmp/.doc
.\" use: groff -pte -me | lpr
.\" or : pic | tbl | eqn | ditroff -me
.\"
.\"	"@(#)bibmac.me	2.2	9/9/83";
.de IP
.ip \\$1 \\$2
..
.de LP
.lp
..
.\"	@(#)bmac.std	2.2	9/9/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [? " \&
.ds ?] ?
.ds [: " \&
.ds :] :
.ds [; " \&
.ds ;] ;
.ds [! " \&
.ds !] !
.ds [" " \&
.ds "] \&"
.ds [' " \&
.ds '] '
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds a] " \&
.ds b] , \&
.ds c] , \&
.ds n] "\& and \&
.ds m] "\& and \&
.ds p] .
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A\\c
.if !"\\*([T"" , \\*([T\\c
.if !"\\*([V"" , Vol. \\*([V\\c
.if !"\\*([O"" , \\*([O\\c
.if !"\\*([D"" , \\*([D\\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T""  \\*([T,
\\fI\\*([J \\*([V\\fP\c
.if !"\\*([N"" ,\\*([N
.if !"\\*([D"" (\\*([D)\c
.if !"\\*([P"" , \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP\c
.if !"\\*([V"" , vol. \\*([V
.if !~\\*([E~~ \{\
.       ie , \\n([E-1  \\*([E (editors)\c
.       el , \\*([E (editor)\c\}
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
.if !~\\*([E~~ \{\
.       ie \\n([E-1 \\*([E, editors.
.       el \\*([E, editor.\}
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.\"	@(#)bmac.std	2.2	8/24/83;
.\" standard format troff commands
.\" citation formatting strings
.ds [[ [
.ds ]] ]
.ds ], ,\|
.ds ]- -
.ds [. " \&
.ds .] .
.ds [, " \&
.ds ,] ,
.ds [< " \&
.ds >]
.\" reference formmating strings
.ds c] , \&
.ds n] "" and \&
.ds m] "" and \&
.ds a] " \&
.\" reference formmating macros
.de s[   \" start reference
.nh
.IP [\\*([F] 5m
..
.de e[   \" end reference
.[-
..
.de []   \" start to display collected references
.SH
References
.LP
..
.de ][   \" choose format
.ie !"\\*([J"" \{\
.    ie !"\\*([V"" .nr t[ 1    \" journal
.    el            .nr t[ 5    \" conference paper
.\}
.el .ie !"\\*([B"" .nr t[ 3    \" article in book
.el .ie !"\\*([R"" .nr t[ 4    \" technical report
.el .ie !"\\*([I"" .nr t[ 2    \" book
.el                .nr t[ 0    \" other
.\\n(t[[
..
.de 0[   \" other
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
.if !"\\*([O"" \\*([O\c
.if !"\\*([D"" , \\*([D\c
\&.
.e[
..
.de 1[ \" journal article
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J \\*([V\\fP,
.if !"\\*([N"" \\*([N
.if !"\\*([D"" (\\*([D),
.if !"\\*([P"" \\*([P\c
.if !"\\*([I"" , \\*([I\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 2[ \" book
.s[
.ie !"\\*([A"" \\*([A,
.el .if !"\\*([E"" \{\
.       ie \\n([E-1 \\*([E, eds.,
.       el \\*([E, ed.,\}
.if !"\\*([T"" \\fI\\*([T\\fP,
.rm a[
.if !"\\*([I"" .ds a[ \\*([I
.if !"\\*([C"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([C\}
.if !"\\*([D"" \{\
.       if !"\\*(a["" .as a[ , \\&
.       as a[ \\*([D\}
\\*(a[.
.if !"\\*([G"" Gov. ordering no. \\*([G.
.if !"\\*([O"" \\*([O.
.e[
..
.de 3[ \" article in book
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
in \\fI\\*([B\\fP,
.if !"\\*([V"" vol. \\*([V,
.if !"\\*([E"" \\*([E (ed.),
.if !"\\*([I"" \\*([I,
.if !"\\*([C"" \\*([C,
.if !"\\*([D"" \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" \\*([O.
.e[
..
.de 4[ \" report
.s[
.if !"\\*([A"" \\*([A,
\\*([T,
\\*([R\c
.if !"\\*([G"" \& (\\*([G)\c
.if !"\\*([I"" , \\*([I\c
.if !"\\*([C"" , \\*([C\c
.if !"\\*([D"" , \\*([D\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de 5[ \" conference paper
.s[
.if !"\\*([A"" \\*([A,
.if !"\\*([T"" \\*([T,
\\fI\\*([J\\fP,
.if !"\\*([C"" \\*([C\c
.if !"\\*([D"" , \\*([D\c
.if !"\\*([P"" , \\*([P\c
\\&.
.if !"\\*([O"" , \\*([O.
.e[
..
.de [-   \" clean up after yourself
.rm [A [B [C [D
.rm [E [F [G
.rm [I [J [K
.rm [N [O [P
.rm [R [T
.rm [V [W
..
.lf 1 ./head
.if t \{ \
.ie rletter .pl 11i	\" page length letter
.el .pl 29.7c	\" page length DIN A4
.po 2.5c	\" page offset (left margin)
.ll 17.0c	\" line length
.lt 17.0c	\" title length
.nr LL 17.0c
.nr )l 29.7c
.nr pp 12
.nr sp 12
.nr tp 12	\" title point size
.nr fp 10	\" foot note point size
.nr bi 4n	\" block indentation
.hc ~		\" hyphenation character
.
.		\" Umlauts and sharp s
.ie "\n(.g"1" \
\{\
.nr $r \n(.v*100+\n(.sp-1u/\n(.sp
.nr $r 112	\" factor for vertical spacing, orig. value = 120
.ds A \(:A
.ds O \(:O
.ds U \(:U
.ds a \(:a
.ds o \(:o
.ds u \(:u
.ds s \(ss
.\}
.el \
\{\
.nr $r 9	\" factor for vertical spacing
.ds A \(A:
.ds O \(O:
.ds U \(U:
.ds a \(a:
.ds o \(o:
.ds u \(u:
.ds s \(ss
.\}
.nr $R \n($r
.sz 12		\" font size
.		\"  UMLAUT  \*:u, etc.
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.\}
.
.if n \{ \
.po 0		\" page offset (left margin)
.ll 78		\" line length
.lt 78		\" title length
.nr $r 4	\" factor for vertical spacing
.nr $R \n($r
.hc ~		\" hyphenation character
.		\" Umlaute und scharfes s
.
.\" .pl 1050
.ds A Ä
.ds O Ö
.ds U Ü
.ds a ä
.ds o ö
.ds u ü
.ds s ß
.
.ds A Ae
.ds O Oe
.ds U Ue
.ds a ae
.ds o oe
.ds u ue
.ds s ss
.
.\}
.
.de _
\&\\$1\l'|0\(ul' \\$2
..
.ds d \h'0.12c'	\" space with width of a dot
.
.de FT		\" font for programs
.ft C
.sz -2
..
.
.de FR
.ft R
.sz +2
..
.de tt
.@E
.ft C
.\" .sz -2
.if \\n(.$ \&\\$1\f\\*(_F\\$2
..
.
.de []		\" start to display collected references
.uh References
.lp
..
.
.de $0		\" collect table of contents
.(x
.ta 2c
.ie '\\$2''	\\$1
.el \\$2.	\\$1
.)x
..
.
.de np
.nr $p +1
.ip \\n($p.
..
.nr y4 1900+\n(yr
.
.de SH
.sp 0.5
.in -3
.b \\$1
.sp 0.5
.in +3
..
.
.de PP
.sp 0.5
..
.
.de IP
.ip \\$1 \\$2
..
.
.de I
.i \\$1
..
.
.de TH
..
.
.de UL
\&\\$1\l'|0\(ul'\\$2
..
.
.de PS
.sp 0.5
..
.
.de PE
.sp 0.5
..
.
.de T0
.b " "
.sp 1c
.ta 9c
.ft R
.sz 12
\l'17.0c'
.nf
..
.
.de T1
\l'17.0c'
.ie rletter .sp 11.0c
.el .sp 12.5c
\l'17.0c'
.ft H
.nf
 
	DR. JOSEF GROSCH
 
	COCOLAB - DATENVERARBEITUNG
 
	GERMANY
 
.r
\l'17.0c'
..
.
.de T2
.bp
.oh ''\\$1'%'
.eh ''\\$1'%'
.ce 99
.b " "
.sz 20
.ie rletter .sp 0
.el .sp 2
.b "Cocktail"
.sp 2
Toolbox for Compiler Construction
.sp 2
.sz 12
\l'15c'
.sp 2
.sz 16
.b "\\$2"
.sp 2
\\$3
.sp 2
.sz 14
\\$4
.sp 2
.sz 12
\l'15c'
.sp 2
Document No. \\$5
.sp 2
Copyright \(co \\$6 Dr. Josef Grosch
.sp 2
Dr. Josef Grosch
CoCoLab - Datenverarbeitung
Breslauer Str. 64c
76139 Karlsruhe
Germany
.sp 0.5
.hc
Phone: +49-721-91537544
Fax: +49-721-91537543
Email: grosch@cocolab.com
.ce 0
.fi
..
.lf 294 /tmp/.doc
.EQ
gsize 12
delim off
.EN
.T0

	Object-Orientation in
	the Cocktail Toolbox


	J. Grosch


.T1
.T2 "" "Object-Orientation in the Cocktail Toolbox" "Josef Grosch" "Sept. 11, 1994" 34 1994
.bp 1
.ce 99
.b "Object-Orientation in the Cocktail Toolbox"
.sp 1.5
Josef Grosch
CoCoLab
Hagsfelder Allee 16
D-76131 Karlsruhe
Germany
.sp 0.5
Tel: +49-721-697061
Fax: +49-721-661966
EMail: grosch@cocolab.de
.ce 0
.sp 1
.uh Abstract
The Cocktail Toolbox for Compiler Construction supports the automatic generation of
nearly all parts of a compiler. This article describes the aspects of
object-orientation of some tools which appear primarily at the specification
level. The areas discussed in the following are:
Concrete grammars as input for parser generators,
abstract syntax and symbol tables used as internal data structures,
attribute grammars as specification for semantic analysis, and
pattern-matching for the transformation or mapping of attributed trees into
intermediate representations or target code.
.sh 1 Introduction
.lp
In the Cocktail Toolbox for Compiler Construction\*([<\*([[GrE90\*(]]\*(>]
object-orientation appears in two areas:
First, it is possible to generate scanner and parser classes in the languages C++
and Eiffel and thus several scanner and parser objects can be instantiated during
run time. This area is not very inspiring and therefore it is not discussed in this
paper.
Second, there is a central specification language for the description of
concrete syntax, abstract syntax, and attribute grammars. This language is based on
context-free grammars and it offers many extensions with respect to attribute
grammars and object-orientation. The following sections discuss the areas where
object-orientation plays a role in this specification language by giving typical
examples.
.sh 1 "Concrete Syntax"
.lp
The concrete syntax of a language is specified by a grammar which is used as input
of a parser generator. The first example shows a few grammar rules.
.(z I
Example: concrete syntax
.sp 0.5
.FT
Stat            = <
   Assign       = Addr ':=' Expr .
   Calls        = Ident <
      Call0     = .
      Call      = '(' Actuals ')' .
   > .
   If           = IF Expr THEN Then: Stat <
      If2       = ELSE Else: Stat .
   > .
> .
Expr            = <
   Plus         = Lop: Expr '+' Rop: Expr .
   Times        = Lop: Expr '*' Rop: Expr .
   '()'         = '(' Expr ')' .
   Addr         = <
      Name      = Ident .
      Index     = Addr '[' Expr ']' .
   > .
> .
.)z
The names to the left of the character = are rule names.
Rule names that are referenced on some right-hand side are treated as nonterminal
symbols. This can be seen by the transformation of the rules to BNF as given in the
second example.
On the right-hand side the symbols can be augmented with selector names such as
Then:, Else:, Lop:, or Rop: in order to allow unambiguous access to their attributes.
Most notably is the nested structure of the grammar rules which is established by
the brackets < and >. The grammar rules are
also regarded as classes and the nesting structure describes the class hierarchy.
For example the rules Assign, Calls, and If are subclasses of Stat and Call0 and
Call are in turn subclasses of Calls. The subclass relation is interpreted in two
ways: First, a subclass inherits the right-hand side of its superclass.
Second, a superclass acts as nonterminal and all its subclasses describe associated
right-hand sides. This interpretation can be seen best by looking at the result
of the transformation of the rules to BNF.
.(z I
Example: transformation to BNF
.sp 0.5
.FT
Stat = Addr ':=' Expr .
Stat = Ident .
Stat = Ident '(' Actuals ')' .
Stat = IF Expr THEN Stat .
Stat = IF Expr THEN Stat ELSE Stat .
.sp 0.5
Expr = Expr '+' Expr .
Expr = Expr '*' Expr .
Expr = '(' Expr ')' .
Expr = Ident .
Expr = Addr '[' Expr ']' .
.sp 0.5
Addr = Ident .
Addr = Addr '[' Expr ']' .
.)z
.pp
The relationship to object-orientation is as follows:
Classes correspond to nonterminals, terminals, and grammar rules,
objects correspond to language constructs such as statements,
and features correspond to right-hand side symbols such as terminals and nonterminals
as well as to attributes and attribute computations (see sections 3 and 4).
The benefit of object-orientation in the area of concrete syntax is not very high.
First, the order of the right-hand
side symbols is significant and therefore only common beginnings of right-hand sides
can be factored out. Second, attribute computations during parsing mainly describe
the construction of a syntax tree. These computations are in general different for
every grammar rule and therefore there is hardly a chance to factor out common
computations.
.sh 1 "Abstract Syntax and Symbol Table"
.lp
Data structures in compilers such as a syntax tree or a symbol table are supported
by a Cocktail tool for abstract syntax trees\*([<\*([[Gro91\*(]]\*(>].
Usually trees are built out of nodes that are linked together.
Symbol tables describe the entities declared in programs. One possible implementation
uses linked lists for the representation of sets of entities. The elements of those
lists can be treated like tree nodes.
.pp
An abstract syntax is specified by a context-free grammar. Every rule of this
grammar defines a so-called node type. The right-hand side of a rule lists the
children and the attributes. The set of possible children is described by an
associated node type. Attributes are enclosed in brackets [ ] and typed with types
of the implementation language.
The subclass relation and the inheritance mechanism work similarly as in the case of
the concrete syntax. For example every node type describing an expression (Expr,
Binary, Addr, Ident, Index) has among others two attributes called Pos and Type.
.(b
Example: abstract syntax
.sp 0.5
.FT
Stat            = <
   Assign       = Addr Expr .
   Call         = [Ident: tIdent] [Pos: tPosition] Actuals .
   If           = Expr Then: Stat Else: Stat .
> .
Expr            = [Pos: tPosition] [Type: tType] <
   Binary       = Lop: Expr Rop: Expr [Operator] .
   Addr         = <
      Ident     = [Ident: tIdent] .
      Index     = Addr Expr .
   > .
> .
.)b
.pp
From such a specification a tool generates an abstract data type that handles
attributed trees and graphs. This generated program module offers
numerous tree/graph operations such as
node constructors using a procedure notation to store attribute values and to take
care of storage management, list processing (loop construct, reverse order),
ASCII and binary graph reader and writer routines, as well as
interactive graph browsers.
.pp
The next example uses the specification method to describe a symbol table.
The node type Entity represents an abstract entity which is described by a name,
a source position, and a pointer to the next entity. The node types Var, Const, and
Proc specialize the abstract entity. They inherit the attributes and children from
Entity and add further node specific features. Nodes of the specified node types
can be chained into lists where the elements may be of different types as long as
their types are subtypes of Entity.
.(b
Example: symbol table
.sp 0.5
.FT
Entity          = [Ident: tIdent] [Pos: tPosition] Next: Entity <
   Var          = [Type: tType] .
   Const        = Expr [Value: tValue] .
   Proc         = Formals <
      Func      = [Type: tType] .
   > .
> .
.)b
Again, we can identify the following relationship to object-orientation:
Classes correspond to node types,
objects correspond to tree nodes or list elements,
and features correspond to children, attributes and attribute computations.
.sh 1 "Attribute Grammars"
.lp
Attribute grammars are one possibility for the specification of semantic analysis.
They are processed by a tool that generates attribute evaluators\*([<\*([[Groa\*(]]\*(>].
Attribute grammars extend grammars by attributes and attribute computations.
Attribute computations are formulated in the implementation language and
enclosed in curly brackets. They may contain so-called attribute designators of the
form child_name:attribute_name for the access of attributes of right-hand side
symbols. Additionally, the CHECK statement can be used to test context conditions.
The Cocktail tools handle attribute grammars with single and multiple inheritance
\*([[Gro90\*(],Grob\*(]].
.pp
While the previous section implemented the symbol table as a separate data structure,
the following attribute grammar integrates abstract syntax and symbol table.
The tree nodes for declarations are treated as symbol table entries.
The node type Decl describes an abstract entity in the same way as Entity in the
previous section. The attribute grammar computes additional links between the symbol
table entries using the threaded attribute Objects[In/Out]. The node type Env
represents scopes. It refers to a set of local entities (Objects) and a surrounding
scope (Env).
.(b
Example: attribute grammar
.sp 0.5
.FT
Prog            = Proc .                               /* abstract syntax */
Decls           = <
   NoDecl       = .
   Decl         = [Ident: tIdent] [Pos: tPosition] Next: Decls <
      Var       = .
      Const     = .
      Proc      = Decls Stats <
         Func   = Type .
      > .
   > .
> .
Stats           = <
   NoStat       = .
   Stat         = Next: Stats <
      Use       = [Ident: tIdent] [Pos: tPosition] .
      Call      = [Ident: tIdent] [Pos: tPosition] .
   > .
> .
.sp 0.5
MODULE DefTab                 /* attribute computations for name analysis */
.sp 0.5
Decls           = [Objects: tTree THREAD] .     /* attribute declarations */
Decls Stats     = [Env: tTree] .
Use Call        = [Object: tTree] .
Env             = [Objects: tTree IN] Env IN .  /* node type for scopes   */
.sp 0.5
Prog    = { Proc:ObjectsIn      := mNoDecl ();
            Proc:Env            := mEnv (Proc:ObjectsOut, NoTree);    } .
Proc    = { Decls:ObjectsIn     := mNoDecl ();
            Stats:Env           := mEnv (Decls:ObjectsOut, Env);
            Decls:Env           := Stats:Env;                         } .
Decl    = { Next:ObjectsIn      := DEP (SELF, ObjectsIn);
            ObjectsOut          := Next:ObjectsOut;
            CHECK IdentifyObjects (Ident, ObjectsIn)->Kind == kNoDecl
            => Error (Pos, "identifier multiply declared", Ident);    } .
Use     = { Object := IdentifyWhole (Ident, Env);
            CHECK Object->Kind != kNoDecl
            => Error (Pos, "identifier not declared", Ident) AND_THEN
            CHECK Object->Kind == kVar || Object->Kind == kConst
            => Error (Pos, "variable or constant required", Ident);   } .
Call    = { Object := IdentifyWhole (Ident, Env);
            CHECK Object->Kind != kNoDecl
            => Error (Pos, "identifier not declared", Ident) AND_THEN
            CHECK Object->Kind == kProc
            => Error (Pos, "procedure required", Ident);              } .
.sp 0.5
END DefTab
.)b
.pp
The attribute grammar uses library routines such as IdentifyObjects and
IdentifyWhole for lookup in the symbol table. Given an identifier both routines
return a symbol table entry (Object). A special entry denotes undefined objects.
While IdentifyObjects just searches in the current scope IdentifyWhole searches in
all surrounding scopes as well.
.pp
In the example one rule for declarations (Decl) suffices to establish the links in
the symbol table and to check for multiple declarations. Both computations are
inherited by all node types describing declarations (Var, Const, Proc, Func).
At the locations where identifiers are used (Use and Call) specific checks are
necessary to insure that objects of the proper kind are used.
.pp
The following relationship to object-orientation can be identified:
Classes correspond to node types, objects correspond to tree nodes,
and features correspond to children, attributes, attribute computations, and
checks of context conditions. Especially the inheritance of attribute computations
is quite useful because it allows to
factors out common computations and thus leads to short attribute grammars.
.sh 1 "Pattern-Matching"
.lp
The Cocktail Toolbox contains a tool for the transformation or the mapping of
attributed trees to arbitrary output such as intermediate representations or target
code\*([<\*([[Gro92\*(]]\*(>].
The tool is based on pattern-matching and pattern-matching has been
extended to deal with the subtype relation of the node types in the input trees.
From a very simplified point of view a pattern is either a variable or a node type
followed by a list of patterns enclosed in parentheses. A pattern variable matches
every node. A pattern of node type t matches if the type of the current node is a
subtype of t and if the subpatterns match their corresponding subtrees.
.(b
Example: transformation routine
.sp 0.5
.FT
PROCEDURE Code (Decls)
.sp 0.5
Func (Ident, Pos, Next, Decls, Stats, Type) :-
   ...                  /* generate code for Func */
   Code (Next);
   .
Proc (Ident, Pos, Next, Decls, Stats) :-
   ...                  /* generate code for Proc */
   Code (Next);
   .
Decl (_, _, Next) :-    /* do not generate code for Var and Const */
   Code (Next);
   .
.)b
.pp
The patterns of the rules are checked in the given order. When a pattern matches
then the associated statements are executed and afterwards the activation of the
transformation procedure terminates. The patterns in the example have to be arranged
exactly in the given order. A node of type Func would match all three
patterns and a node of type Proc would match the last two patterns.
.pp
Taking advantage of the subclass relation among node types in pattern-matching
allows to factor out common computations and thus leads to short problem solutions.
.sh 1 Summary
.lp
We surveyed the areas where object-orientation appears at the specification level
in the Cocktail Toolbox for Compiler Construction: Concrete syntax, abstract syntax,
symbol table, attribute grammars, and pattern-matching. The correspondence between
the notions of the fields of object-oriented programming and compiler construction
was described. The most benefit comes from the inheritance of attribute computations
in attribute grammars and from the extension of pattern-matching to the subtype
relation among node types, because this allows to factor out a significant amount of
common computations.
.fi
.sz 12
.[]
.[-
.ds [F GrE90
.ds [A J\*(p] Grosch
.as [A \*(n]H\*(p] Emmelmann
.ds [T A Tool Box for Compiler Construction
.ds [V 477
.ds [J LNCS
.ds [C Berlin
.ds [I Springer Verlag
.nr [P 1
.ds [P 106-116
.ds [D Oct. 1990
.][
.[-
.ds [F Gro90
.ds [A J\*(p] Grosch
.ds [T Object-Oriented Attribute Grammars
.ds [E A\*(p]\*(a]E\*(p] Harmanci
.as [E \*(n]E\*(p] Gelenbe
.nr [E 2
.ds [B Proceedings of the Fifth International Symposium on Computer and Information Sciences (ISCIS V)
.ds [C Cappadocia, Nevsehir, Turkey
.nr [P 1
.ds [P 807-816
.ds [D Oct. 1990
.][
.[-
.ds [F Gro91
.ds [A J\*(p] Grosch
.ds [T Tool Support for Data Structures
.ds [J Structured Programming
.ds [V 12
.nr [P 1
.ds [P 31-38
.ds [D 1991
.][
.[-
.ds [F Gro92
.ds [A J\*(p] Grosch
.ds [T Transformation of Attributed Trees Using Pattern Matching
.ds [V 641
.ds [J LNCS
.ds [C Berlin
.ds [I Springer Verlag
.nr [P 1
.ds [P 1-15
.ds [D Oct. 1992
.][
.[-
.ds [F Groa
.ds [A J\*(p] Grosch
.ds [T Ag - An Attribute Evaluator Generator
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 16
.ds [N 16
.][
.[-
.ds [F Grob
.ds [A J\*(p] Grosch
.ds [T Multiple Inheritance in Object-Oriented Attribute Grammars
.ds [I CoCoLab Germany
.ds [R Cocktail Document No. 28
.ds [N 28
.][
.bp 1
.lp
.b Contents
.sp
.xp
