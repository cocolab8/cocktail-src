








                         Entwurf und Implementierung


                              eines Uebersetzers


                             von Modula-2 nach C










                                 Diplomarbeit
                                     von
                               Matthias Martin









                            Universitaet Karlsruhe
                          Fakultaet fuer Informatik
                                 Februar 1990









                                  Betreuer:
                           Prof. Dr. S. Jaehnichen
                                Dr. J. Grosch

                                  Uebersicht
  Diese Diplomarbeit beschreibt den Entwurf und die Implementierung des Ueber-
setzers  Mtc,  der  in  Modula-2  geschriebene  Programme  in  lesbaren C-Code
umsetzt. Die Definition einer vollstaendigen Abbildung von  Modula-2  nach  C,
die  auch  anhand  von  zahlreichen  Beispielen  illustriert  wird, bildet den
Hauptteil dieser Arbeit. Die Implementierung des Uebersetzers  erfolgte  unter
weitgehendem   Einsatz  von  Uebersetzerbauwerkzeugen.  Die  Beschreibung  der













Implementierung konzentriert sich daher besonders auf die Darstellung des Ein-
satzes  dieser  Werkzeuge.  Ein abschlieszendes Kapitel ueber erste praktische
Einsaetze von Mtc demonstriert die Leistungsfaehigkeit  und  Laufzeiteffizienz
des Uebersetzers sowie die Qualitaet des erzeugten C-Codes.






































































1.
    Einleitung

  Diese Arbeit beschreibt den Entwurf und die Implementierung des Uebersetzers
Mtc, der in Modula-2 geschriebene Programme in lesbaren C-Code umsetzt.


1.1
     Motivation und Zielsetzung

  Modula-2 [Wirth85] ist eine Weiterentwicklung der Programmiersprache Pascal,
die   im  wesentlichen  um  ein  Modulkonzept  erweitert  wurde.  An  der  GMD
Forschungsstelle Karlsruhe wurde der  Modula-Uebersetzer  MOCKA  [Engelmann87]
entwickelt, der auch vollstaendig in Modula-2 implementiert ist.  Modula-2 und
MOCKA werden zur Zeit an der GMD  Forschungsstelle  Karlsruhe  als  bevorzugte
Werkzeuge  zur  Programmentwicklung  eingesetzt. Insbesondere sind alle in den
letzten  drei  Jahren  am  Institut  entwickelten  Uebersetzerbauwerkzeuge  in
Modula-2 implementiert.
  Die Sprache C [Kernighan78] wurde urspruenglich entworfen und  implementiert
fuer  die Entwicklung des UNIX-Betriebssystems [UNIX79], welches abgesehen von
wenigen Teilen, bei denen extrem hohe  Effizienzanforderungen  oder  spezielle
Maschineneigenschaften  den Einsatz von Assembler notwendig machen, vollstaen-
dig in C implementiert ist. Da UNIX nicht nur ein Betriebssystem ist, sondern,
weniger  eng  betrachtet,  unter dem Begriff UNIX eine Programmierumgebung mit
einer Vielzahl von nuetzlichen Werkzeugen fuer  die  Programmentwicklung  ver-
standen  wird, hat UNIX in den letzten Jahren, besonders im wissenschaftlichen
Bereich,  eine  sehr   weite   Verbreitung   gefunden.   Auch   an   der   GMD
Forschungsstelle Karlsruhe wird UNIX eingesetzt.
  Aus den einleitenden Vorbemerkungen laeszt sich  nun  direkt  die  hauptsae-
chliche Zielsetzung und das geplante Einsatzgebiet von Mtc ableiten:
-
    Der Modula-Uebersetzer MOCKA und die am Institut entwickelten Uebersetzer-
    bauwerkzeuge  koennen  mit  Mtc  schnell  und  relativ  einfach  auf  neue
    Maschinen uebertragen werden, auf denen das  UNIX-System  und  ein  Ueber-
    setzer fuer die Sprache C vorhanden sind.
-
    Die Uebersetzerbauwerkzeuge werden auch fuer  alle  Interessenten  zugaen-
    glich,  die einen Uebersetzer fuer die im Vergleich mit Modula-2 weit ver-
    breitete Sprache C besitzen.
-
    Die Weiterentwicklung  der  Uebersetzerbauwerkzeuge  kann  in  der  besser
    strukturierten, moderneren und relativ sicheren Sprache Modula-2 erfolgen,
    die Werkzeuge sind aber auch jederzeit, ohne den  riesigen  Aufwand  einer
    Uebersetzung von Hand, in C und unter UNIX verfuegbar.
  Da Mtc fuer die Uebertragung von fertigen Modula-Programmen nach  C  gedacht
ist  und  nicht  fuer die Programmentwicklung eingesetzt werden soll, kann bei
der Implementierung davon ausgegangen werden, dasz nur korrekte Programme  als
Eingabe  vorkommen.  Insbesondere  soll die semantische Korrektheit der Einga-
beprogramme nicht ueberprueft werden.  Weil die uebersetzten  Programme  unter
Umstaenden  noch  von  Hand  weiterbearbeitet werden sollen, ist eine wichtige
Forderung an die erzeugten Programme, dasz sie gut lesbar sind.
  Ein weiteres Ziel dieser  Arbeit  ist  der  praktische  Einsatz  der  bisher
entwickelten  Uebersetzerbauwerkzeuge  bei  der  Implementierung  von  Mtc, um
dabei:

                                1











-
    Die praktische Einsetzbarkeit der Werkzeuge  fuer  die  Entwicklung  eines
    groeszeren Uebersetzers zu zeigen.
-
    Die Leistungsfaehigkeit der  Werkzeuge  und  des  (teilweise)  generierten
    Uebersetzers zu demonstrieren.
-
    Erfahrungen zu sammeln, die zu einer Verbesserung der Werkzeuge fuehren.


1.2
     Randbedingungen

  Die Implementierung des Uebersetzers erfolgt auf UNIX-Workstations der  Fir-
men  PCS  und SUN.  Implementierungssprache ist Modula-2. Die folgenden an der
GMD Forschungsstelle Karlsruhe  entwickelten  Uebersetzerbauwerkzeuge  standen
fuer die Entwicklung von Mtc zur Verfuegung:
-
    Der Generator fuer Symbolentschluessler Rex [Grosch87b].
-
    Die Zerteilergeneratoren Lalr und Ell [Vielsack88].
-
    Ast [Grosch89a], ein Werkzeug zur Spezifikation  und  Implementierung  von
    abstrakten Syntaxbaeumen.
-
    Ag [Grosch89b], ein Generator fuer Attributauswerter.
-
    Das Werkzeug Estra [Vielsack89] zur Spezifikation und Implementierung  der
    Transformation attributierter Strukturbaeume.
  Neben  diesen  Werkzeugen  wurden  Modula-Moduln   aus   der   umfangreichen
Bibliothek Reuse [Grosch87a] mit wiederverwendbarer Software verwendet.



2.
    Vergleichbare Arbeiten

  In diesem Kapitel sollen kurz  zwei  mit  Mtc  vergleichbare  Arbeiten  vor-
gestellt  werden,  die  sich  mit  der  Uebersetzung  von Programmen von einer
hoeheren  Programmiersprache  in  eine   andere   hoehere   Programmiersprache
beschaeftigen.


2.1
     PTC

  Der Uebersetzer PTC [PTC87] war fuer die vorliegende Arbeit  von  besonderem
Interesse, da die Zielsprache ebenfalls C und die Quellsprache Pascal der Vor-
gaenger von Modula-2 ist.  Er wurde von P. Bergsten  bei  der  Firma  Holistic
Technology AB, Gothenburg, Schweden entwickelt.
  PTC verarbeitet ein korrektes Pascal-Programm und erzeugt ein  aequivalentes
C-Programm.   Der Uebersetzer, der (fast) vollstaendiges Pascal implementiert,
wurde entworfen, um fertig entwickelte Pascal-Programme auf Systeme zu  ueber-
tragen, die keinen Pascal-Uebersetzer besitzen. Er ist nicht fuer die Program-
mentwicklung gedacht. Daher wird die  Korrektheit  der  Eingabeprogramme  auch
nicht ueberprueft und beim ersten entdeckten Fehler bricht der Uebersetzer mit
einer entsprechenden Meldung ab. PTC besitzt daher keinerlei  Fehlerbehandlung
und  fehlerhafte  Programme  koennen im schlimmsten Fall sogar zum Absturz des
Uebersetzers fuehren.
  Auf die von PTC implementierte Abbildung von Pascal nach C soll  hier  nicht
im  Detail  eingegangen  werden. Da Modula-2 ein Nachfolger von Pascal ist und
daher ein nicht unerheblicher Teil der beiden Sprachen, abgesehen von  kleinen
syntaktischen Unterschieden, nahezu identisch ist und darueberhinaus an vielen
Stellen die Abbildung nach C auf der Hand liegt, stimmt die von PTC  implemen-
tierte  Abbildung  fuer  die gemeinsamen Konstrukte von Modula-2 und Pascal im

                                2











Prinzip mit der in Kapitel 4  beschriebenen  Abbildung  von  Modula-2  nach  C
ueberein.  Dort  wird  an  den  entsprechenden  Stellen  darauf  verwiesen, wo
besonders elegante Loesungen von PTC uebernommen wurden.
  Hier soll nur kurz dargestellt werden, welche  Probleme  bei  der  Abbildung
fuer Modula-2 im Vergleich zu Pascal entfallen und welche neu hinzukommen.
  Da in Modula-2 die Ein-/Ausgabe, die  Dateiverwaltung  sowie  die  Speicher-
verwaltung  nicht  Teil  der  Sprachdefinition sind, entfaellt die fuer Pascal
notwendige und teilweise sehr aufwendige Abbildung dieser Konstrukte, die  von
PTC   mit  Hilfe  der  C-Standardbibliothek  implementiert  werden.  Spruenge,
insbesondere Spruenge, die eine  Prozedur  verlassen  und  die  kein  direktes
Gegenstueck  in  C  haben,  sind  in  Modula-2  ebenfalls  nicht moeglich. Ein
weiteres, von PTC allerdings nicht  geloestes  Problem,  welches  in  Modula-2
entfaellt,   ist   die  in  Pascal  gegebene  Moeglichkeit  lokal  deklarierte
Prozeduren als Prozedurparameter zu uebergeben.
  Verglichen mit Pascal kommen in Modula-2 insbesondere das  Modulkonzept  und
die  getrennte Uebersetzung neu hinzu.  Auszerdem ist die Reihenfolge der Dek-
larationen und Anweisungen in Modula-2 nicht so stark  eingeschraenkt  wie  in
Pascal  und  es  sind  allgemeine  Ausdruecke  in Deklarationen zulaessig. Das
Konzept der Uebergabe von Funktionen bzw. Prozeduren als  Parameter  wurde  in
Modula-2   zu   dem  allgemeinen  Konzept  der  Prozedurtypen  und  -variablen
erweitert.  Zusaetzlich neu ist die Moeglichkeit, Felder beliebiger Groesze an
Prozeduren  zu uebergeben sowie eine Reihe von Moeglichkeiten zur ,,maschinen-
nahen'' Programmierung.
  PTC ist in Pascal implementiert. Das Programm ist im  wesentlichen  aus  den
drei Prozeduren parse, transform und emit aufgebaut.
  Die Prozedur parse liest und  zerteilt  das  Quellprogramm  und  baut  einen
abstrakten  Strukturbaum  auf.  Die Zerteilung arbeitet nach dem Verfahren des
rekursiven Abstiegs. Parallel zur Zerteilung wird eine Definitionstabelle auf-
gebaut und die Bezeichneridentifikation durchgefuehrt.
  Die Prozedur transform fuehrt eine Reihe von  Baum-zu-Baum  Transformationen
durch,  die  notwendig sind, um das Pascal-Programm nach C zu uebersetzen. Die
wichtigste dieser Transformationen ist die Delokalisierung von in Pascal lokal
deklarierten  Prozeduren,  da in C keine geschachtelten Funktionsdeklarationen
zulaessig sind. Zusaetzlich zur Transformation des  Strukturbaums  werden  bei
Bedarf auch Bezeichner zur Vermeidung von Namenskonflikten umbenannt.
  Die Prozedur emit schlieszlich traversiert den transformierten Baum und gibt
die entsprechenden C-Konstrukte aus.


2.2
     PascAda

  Das an der University of California entworfenen  PascAda-System  [PascAda80]
besteht  aus  zwei  Uebersetzern;  der  eine transformiert Pascal-Programme in
Ada-Programme, der zweite fuehrt die  entgegengesetzte  Transformation  durch.
Beide  Uebersetzer sind in Pascal implementiert.  Die wichtigsten Ziele dieses
Projekts waren1:
-
    Da die beiden Uebersetzer in Pascal implementiert sind, fuer das Implemen-
    tierungen  existieren,  stellt  der  Uebersetzer von Ada nach Pascal einen
____________________
1 Wobei man beruecksichtigen musz,  dasz  das  Projekt  zu  einem
  Zeitpunkt durchgefuehrt wurde, als gerade eine erste Definition
  der Sprache Ada aber noch kein Ada-Uebersetzer vorlag.


                                3











    Uebersetzer fuer (eine Teilmenge von) Ada dar.
-
    Moeglichkeit der vorlaeufigen Entwicklung von Software in Ada.
-
    Umsetzen existierender, in Pascal implementierter Software nach Ada.
-
    Unterstuetzung der Uebertragung von in Ada und/oder Pascal implementierter
    Software auf neue Systeme.
-
    Moeglichkeit zu Experimenten mit Ada.
-
    Bootstrap eines Ada-Uebersetzers.
  Die PascAda-Gruppe  ist  bei  diesem  Projekt  folgendermaszen  vorgegangen.
Zunaechst  wurden  zwei  Teilmengen  AdaP  und  PascalA  von  Ada  und  Pascal
definiert, fuer die eine direkte 1:1 Uebersetzung in die jeweils andere  Teil-
menge existiert. Im naechsten Schritt wurden dann zwei erweiterte Teilsprachen
AdaPE und PascalAE definiert, fuer welche Transformationsregeln gefunden  wer-
den  konnten, wie Konstrukte dieser erweiterten Teilsprachen durch Transforma-
tion der Quellprogramme auf Konstrukte von AdaP bzw. PascalA abgebildet werden
koennen.  Da  die  Semantik von Ada eine weitgehende Obermenge von Pascal ist,
ist PascalAE nahezu vollstaendiges Pascal. Eine Ausnahme sind z.B.  Prozeduren
und  Funktionen  als Parameter oder nicht lokale Spruenge. Da fuer viele Spra-
chkonzepte von Ada,  wie  z.B.  Parallelverarbeitung  und  Ausnahmebehandlung,
keine  entsprechenden  Konzepte in Pascal existieren und eine Simulation, wenn
ueberhaupt, nur mit groszem Aufwand moeglich waere, sind die  Einschraenkungen
bei AdaPE natuerlich groeszer.
  Bei  der  Implementierung  der  beiden  Uebersetzer  wurde  als   gemeinsame
Zwischensprache  die  Baumstruktur  aus  einer  formalen  Definition  von  Ada
[Donzeau79]  benutzt,  die  um  einige  spezielle  Konstrukte  fuer   PascalAE
erweitert  wurde.  Der  Uebersetzer  von Pascal nach Ada besteht logisch aus 4
Komponenten:
PascalToTree:
                  Setzt das Quellprogramm in einen  Baum  der  Zwischensprache
                  um.
PascalAEtoA:
                  Setzt  PascalAE-Konstrukte  durch  Baum-zu-Baum  Transforma-
                  tionen in entsprechende PascalA-Konstrukte um.
PascalACheck:
                  Prueft, ob der Baum einem Programm der  Teilsprache  PascalA
                  entspricht.
TreeToAda:
                  Setzt den Baum in ein entsprechendes Ada-Programm um.
Der Uebersetzer von Ada nach Pascal besteht aus 4 analogen Komponenten.
  Beide Uebersetzer fuehren keine komplette semantische Analyse durch, sondern
pruefen  nur ob ein Programm in der jeweiligen Teilsprache PascalAE bzw. AdaPE
enthalten ist.



3.
    Die Sprachen

3.1
     Die Quellsprache Modula-2

  Die Programmiersprache Modula-2 [Wirth85] wurde Ende der siebziger Jahre  an
der  ETH Zuerich unter der Leitung von Professor N. Wirth entwickelt. Modula-2
ist ein direkter Nachfolger der Programmiersprache Pascal. Das wichtigste neue
Sprachkonzept  im  Vergleich  zu  Pascal  ist  ein Modulkonzept.  Die folgende
Aufzaehlung gibt einen kurzen Ueberblick ueber Modula-2:
-
    Ein Modula-Programm besteht aus einer  Reihe  von  Uebersetzungseinheiten,
    die  getrennt  uebersetzt werden koennen. Eine solche Uebersetzungseinheit
    ist entweder ein Programmodul, ein  Definitionsmodul  oder  ein  Implemen-
    tierungsmodul.    Ein   Programmodul   stellt   ein   Hauptprogramm   dar.
    Definitions- und Implementierungsmoduln treten  immer  paarweise  auf.  Es

                                4











    handelt sich dabei jeweils um einen logisch zusammengehoerenden Modul. Der
    Definitionsmodul stellt die Schnittstelle des Moduls dar und  spezifiziert
    die  vom  Modul  exportierten,  d.h.   die  nach auszen sichtbaren Objekte
    (Daten und Operationen). Der Implementierungsmodul enthaelt die  Implemen-
    tierung  der  nach  auszen  sichtbaren  Operationen  und eventuell weitere
    lokale  Objekte.  Der  Realisierung  des  Geheimnisprinzips   dienen   die
    sogenannten  opaquen Typen, deren Struktur den sie benutzenden Moduln ver-
    borgen bleibt.
-
    Alle im Modula-Programm benutzten Objekte muessen durch  eine  Deklaration
    bekannt gemacht werden, es sei denn, es handelt sich um ein vordefiniertes
    Objekt.  Die Objekte von  Modula-2  sind:  Konstanten,  Typen,  Variablen,
    Prozeduren und Moduln.
-
    Modula-2 ist eine blockstrukturierte Sprache. Zusaetzlich zur  Blockstruk-
    tur  erlaubt  das  Modulkonzept  eine  explizite  Kontrolle  des  Gueltig-
    keitsbereichs bzw.  der  Sichtbarkeit  von  Objekten.  Alle  Objekte,  die
    innerhalb  von  Deklarationen verwendet werden, muessen textuell vor ihrer
    Benutzung  deklariert  werden;  ein  Objekt  kann  aber  innerhalb   einer
    Anweisung  benutzt  werden,  die  der  Deklaration  des  Objekts  textuell
    vorangeht.
-
    Modula-2 ist eine streng typisierte Sprache. Die Grundtypen  von  Modula-2
    sind:  Zeichen, Wahrheitswerte sowie ganze und reelle Zahlen verschiedener
    Groesze. Neben den Grundtypen besitzt Modula-2  einen  umfangreichen  Satz
    von Typkonstruktoren. Die moeglichen Typen sind: Grundtypen, Aufzaehlungs-
    typen,  Unterbereichstypen,  Felder,  Verbunde,  Verbunde  mit  Varianten,
    Mengen, Zeiger und Prozedurtypen.
-
    Prozedurdeklarationen bestehen aus einem Prozedurkopf, der angibt,  welche
    formalen Parameter und welchen Resultattyp1 die Prozedur besitzt und einem
    Rumpf,  der lokale Deklarationen und Anweisungen enthaelt.  Modula-2 kennt
    drei Arten von formalen Parametern: neben den  von  Pascal  her  bekannten
    Wert- und Referenzparametern gibt es noch sogenannte offene Felder. Offene
    Felder sind eindimensionale Felder, deren Feldgrenzen bei  der  Parameter-
    deklaration   nicht  festgelegt  werden.  Dadurch  koennen  Felder  unter-
    schiedlicher Groesze von einer Prozedur  bearbeitet  werden.  In  Modula-2
    koennen  beliebige  Objekte lokal zu einer Prozedur deklariert werden. Das
    bedeutet insbesondere, dasz auch Prozedurdeklarationen geschachtelt werden
    koennen. Prozeduren koennen auch rekursiv aufgerufen werden.
-
    Ein (lokaler) Modul besteht im wesentlichen aus einer Reihe  von  Deklara-
    tionen  und  einer Anweisungsfolge. Die Anweisungsfolge dient der Initial-
    isierung von lokalen Objekten. Grundsaetzlich sind  innerhalb  des  Moduls
    deklarierte  Objekte  auszerhalb  unsichtbar und umgekehrt sind auszerhalb
    deklarierte Objekte innerhalb des Moduls unsichtbar.  Durch  Import-  bzw.
    Exportanweisungen  kann  der  Programmierer  die Sichtbarkeit von Objekten
    explizit kontrollieren und Objekte innerhalb/auszerhalb des Moduls  sicht-
    bar  werden  lassen.  Moduln ermoeglichen es also, zusammengehoerige Daten
    und Operationen zusammenzufassen  und  gegenueber  anderen  Programmteilen
    abzugrenzen.   Die   Import-   bzw   Exportanweisungen  bilden  dabei  die
    Schnittstellen des Moduls nach auszen.  Ein Definitionsmodul ist im  Prin-
    zip  nichts  anderes,  als  die  (erweiterte) Exportliste des zugehoerigen
    Implementierungsmoduls.
-
    Neben den ueblichen arithmetischen, logischen und relationalen  Operatoren
    sowie  Operatoren zum Zugriff auf strukturierte Variablen besitzt Modula-2
    auch Operatoren zur Manipulation von Mengen.
-
    Die Anweisungen von Modula-2 sind: Zuweisung, bedingte Anweisung,  Fallun-
    terscheidung,               verschiedene              Schleifenkonstrukte,
____________________
1 Der Resultattyp wird nur bei Funktionsprozeduren angegeben.


                                5











    Schleifenausgangsanweisung,  Rueckkehranweisung  und  Prozeduraufruf.   In
    Modula-2  koennen auch beliebig strukturiete Objekte als Ganzes zugewiesen
    werden. Eine Sprunganweisung existiert in Modula-2 nicht.  Eine  Speziali-
    taet von Modula-2 (und Pascal) ist die WITH-Anweisung, die es ermoeglicht,
    auf Komponenten von Verbunden ohne Qualifikation durch den Namen des  Ver-
    bundes zuzugreifen.
-
    Modula-2 bietet eine Reihe von Moeglichkeiten, die fuer eine  ,,maschinen-
    nahe''  Programmierung notwendig sind. Insbesondere koennen die Regeln der
    strengen Typisierung umgangen und die Adressen  von  beliebigen  Variablen
    bestimmt  werden.  Die  meisten  dieser Moeglichkeiten sind Datentypen und
    Prozeduren, die im vordefinierten Pseudomodul SYSTEM enthalten sind.
-
    Modula-2 erlaubt die Spezifikation von quasiparallelen Prozessen mit Hilfe
    von Koroutinen.
-
    Die Definition der Ein- und Ausgabe sowie der Datei-  und  Speicherverwal-
    tung sind nicht Teil der Sprachdefinition von Modula-2.


3.2
     Die Zielsprache C

  Die Sprache C [Kernighan78] wurde zu  Beginn  der  siebziger  Jahre  von  D.
Ritchie  fuer die Entwicklung des UNIX-Betriebssystems entworfen und implemen-
tiert. C ist eine relativ maschinennahe Sprache, die sich besonders  fuer  die
Entwicklung  von  Betriebssystemen und anderen hardwarenahen Systemteilen eig-
net. Es wurden  aber  auch  zahlreiche  Uebersetzer  und  umfangreiche  Anwen-
dungssoftware  wie z.B.  Datenbankanwendungen in C implementiert. Die folgende
Aufzaehlung soll einen kurzen Ueberblick ueber die Sprache C geben, sofern sie
fuer diese Arbeit relevant ist:
-
    Ein C-Programm besteht aus einer Reihe von Quelldateien (Moduln), die eine
    Folge  von  Typ-,  Daten-  und Funktionsdeklarationen enthalten und vom C-
    Uebersetzer getrennt uebersetzt werden koennen. Im Gegensatz  zu  Modula-2
    werden  vom  C-Uebersetzer aber keinerlei Pruefungen ueber die Grenzen der
    einzelnen Quelldateien hinweg vorgenommen.
-
    Der C-Praeprozessor, welcher ein Teil der Sprachdefinition von C ist,  ist
    ein  Makroprozessor,  der Textersatz vornehmen, Dateien in eine Quelldatei
    einfuegen und Teile eines Programms  von  der  Uebersetzung  ausschlieszen
    kann.
-
    In C muessen alle  Objekte  vor  ihrer  Anwendung  deklariert  werden.  Es
    besteht   jedoch  die  Moeglichkeit  von  Vorwaertsdeklarationen  und  von
    sogenannten extern-Deklarationen, mit deren Hilfe in anderen  Quelldateien
    deklarierte Objekte bekannt gemacht werden koennen.
-
    C kennt eine einfache Art von Blockstruktur: Variablen  koennen  innerhalb
    von Funktionen in Bloecken deklariert werden und verdecken globale Objekte
    bzw.  Variablen in umfassenden Bloecken mit dem gleichen Namen. Funktionen
    koennen  jedoch  nicht  lokal in einer anderen Funktion deklariert werden,
    duerfen also nicht statisch geschachtelt sein.
-
    Lebensdauer bzw. Sichtbarkeit von Objekten werden in  C  u.a.  durch  ihre
    Speicherklasse  festgelegt.  Lokale Variablen von Funktionen koennen dabei
    folgende Speicherklassen haben:
    static:
                Lebensdauer entspricht der Programmdauer. Dies entspricht  den
                own-Variablen von Algol.
    auto:
                Variablen liegen auf dem Keller. Lebensdauer von Blockein- bis
                Blockaustritt.
    register:
                Lebensdauer wie auto-Objekte, diese sollen aber  nach  Moegli-
                chkeit vom Uebersetzer in einem Register abgelegt werden.
    Die Lebensdauer von globalen Variablen ist die gesamte Programmdauer.  Die
    Angabe  der  Speicherklasse  static verhindert bei globalen Objekten, dasz

                                6











    sie auszerhalb der sie enthaltenden Quelldatei sichtbar sind.
-
    C ist keine streng typisierte Sprache. Fuer arithmetische Typen  ist  eine
    grosze  Zahl  von  impliziten  Typumwandlungen definiert. Neben impliziten
    Typumwandlungen sind auch explizite Konvertierungen moeglich.  Zuweisungen
    zwischen  Zeigern  verschiedenen  Typs sind ebenfalls moeglich. Die Grund-
    typen von C sind: Zeichen,  ganze  und  reelle  Zahlen  mit  verschiedenem
    Speicherbedarf.  Die zusammengesetzten Datentypen von C sind: Zeiger, Vek-
    toren (Felder), Strukturen (Verbunde)1, Varianten und Aufzaehlungen.  Eine
    Variante  ist  eine Struktur, bei der sich die Komponenten ueberlagern. Es
    handelt sich also um eine eingeschraenkte Art von variantem Verbund.
-
    Eine Funktionsdeklaration besteht aus dem Ergebnistyp  der  Funktion,  der
    Deklaration der Parameter und aus lokalen Deklarationen und Anweisungen in
    Form eines Blocks. Wie  bereits  erwaehnt  koennen  Funktionsdeklarationen
    nicht  geschachtelt  werden. Als Hauptprogramm fungiert die Funktion main.
    Die Parameteruebergabe erfolgt durch Wertuebergabe (call  by  value).  Bei
    Vektoren  wird  ein  Zeiger auf den Anfang des Vektors uebergeben (call by
    reference). Funktionen koennen auch rekursiv aufgerufen werden.
-
    C besitzt eine grosze Zahl von Operatoren. Die wichtigsten  dieser  Opera-
    toren sind: Arithmetische, logische und relationale Operatoren, Operatoren
    zur Selektion von Komponenten strukturierter Variablen und Operatoren  zur
    Bitmanipulation.   Darueberhinaus  gibt  es noch eine Reihe von speziellen
    Operatoren wie bedingte Ausdruecke  oder  Inkrement-  und  Dekrementopera-
    toren.
-
    Die  Anweisungen  von  C  sind:   Zuweisung,   Sprunganweisung,   bedingte
    Anweisung,     Fallunterscheidung,    verschiedene    Schleifenkonstrukte,
    Schleifenausgangsanweisung, Rueckkehranweisung  und  Prozeduraufruf.   Die
    Zuweisung ist allerdings eingeschraenkt: Vektoren koennen nicht als Ganzes
    zugewiesen werden und Strukturen nur bei neueren Implementierungen.
-
    C besitzt einen Adreszoperator, mit dem die Adressen  saemtlicher  Objekte
    bestimmt werden koennen. Insbesondere kann man auch die Adressen von Funk-
    tionen bestimmen und diese dann spaeter ueber diese Adressen aufrufen.


3.3
     Vergleich

  Beim Vergleich von Modula-2 und C zeigt sich, dasz  C,  trotz  der  auch  in
Modula-2 vorhandenen Moeglichkeiten zur ,,maschinennahen'' Programmierung, die
maschinennaehere Sprache ist. Modula-2 besitzt ein deutlich hoeheres  Abstrak-
tionsniveau  und  an  vielen  Punkten maechtigere Ausdrucksmittel.  Allerdings
besteht, wenn man von den Koroutinen einmal absieht,  die  Moeglichkeit  in  C
nicht  direkt  vorhandene  Modula-Konstrukte durch eine Kombination von primi-
tiveren C-Konstrukten zu realisieren. So koennen z.B. die Mengen von  Modula-2
in C mit Hilfe der Operatoren zur Bitmanipulation realisiert werden.
  Die folgenden Punkte erfordern bei der Abbildung besonderen Aufwand:
-
    C kennt kein Modulkonzept, welches dem von  Modula-2  vergleichbar  waere.
    Insbesondere  existieren  keine  den  opaquen Typen und den lokalen Moduln
    entsprechenden Konzepte.
-
    Die Regeln  hinsichtlich  Gueltigkeit  und  Sichtbarkeit  von  Bezeichnern
    weisen  eine  Reihe von Unterschieden auf, z.B. verlangt C im Gegensatz zu
    Modula-2, dasz alle Objekte immer vor ihrer Anwendung deklariert werden.
____________________
1 In der deutschsprachigen Fachliteratur haben sich die  Begriffe
  Vektor  und  Struktur fuer die entsprechenden C-Datenstrukturen
  eingebuergert.


                                7











-
    Die zusammengesetzten Typen von C sind weniger  maechtig  als  die  zusam-
    mengesetzten  Typen von Modula-2. Besondere Schwierigkeiten bereitet, dasz
    sich die Behandlung von Vektoren  von  der  Behandlung  anderer  Variablen
    unterscheidet.  Auch die eingeschraenkte Form von varianten Verbunden in C
    erfordert eine besondere Behandlung.
-
    Da C im Gegensatz zu Modula-2 keine geschachtelten  Funktionsdeklarationen
    kennt,  musz  die  in Modula-2 vom Uebersetzer vorgenommene Verwaltung der
    Prozedurschachteln zum Zugriff auf  die  lokalen  Variablen  von  statisch
    umfassenden  Prozeduren (Verweis auf den statischen Vorgaenger) auf geeig-
    nete Art und Weise mit Hilfe von C-Code vorgenommen werden.
-
    C kennt kein den offenen Feldern entsprechendes Konzept  der  Parameterue-
    bergabe.
  Abgesehen von den oben genannten Punkten kann ein groszer Teil der  Deklara-
tionen  sowie  die  meisten  Anweisungen  und  Ausdruecke ohne grosze Probleme
direkt nach C uebersetzt werden. Allerdings zeigt es sich bei der im folgenden
Kapitel  beschriebenen  Abbildung, dasz manchmal auch schon kleine semantische
Unterschiede, bei sich direkt entsprechenden Sprachkonstrukten, die  Abbildung
deutlich verkomplizieren koennen.



4.
    Abbildung von Modula-2 nach C

4.1
     Grundlagen der Abbildung

  Bevor man eine Abbildung von Modula-2  nach  C  definieren  kann,  musz  man
zunaechst  klaeren, welche Definition der beiden Sprachen als Basis fuer diese
Abbildung verwendet werden soll.  Die wichtigsten Gruende dafuer sind:
-
    Seit ihrer Entstehung unterlagen beide Sprachen einer gewissen  Evolution:
    manche Sprachelemente wurden veraendert, andere sind neu hinzugekommen.
-
    Verschiedene Implementierungen unterscheiden sich fast  immer  in  einigen
    Details.
-
    Die vorhandenen Sprachdefinitionen sind nicht  in  allen  Punkten  voellig
    eindeutig.
  Zur Zeit wird zwar fuer beide Sprachen an einer standardisierten  Sprachver-
sion  gearbeitet,  aber  zum  einen  liegen  diese Standards bisher noch nicht
endgueltig vor, zum anderen duerfte nach  dem  Vorliegen  der  Standards  noch
einige Zeit vergehen, bis Uebersetzer verfuegbar sind, die sie implementieren.
Das Vorgehen in dieser Abbildung orientiert sich daher  am  geplanten  Einsatz
des Uebersetzers: Uebertragung von mit dem Karlsruher Modula-Uebersetzer MOCKA
unter dem UNIX-Betriebssystem entwickelten Programmen nach C.
  MOCKA implementiert die Sprache Modula-2 im wesentlichen so, wie sie von  N.
Wirth  [Wirth85]  definiert  wurde.  Diese Definition bildet, neben dem MOCKA-
Benutzerhandbuch [Engelmann87], die Ausgangsbasis der  Abbildung,  die  darue-
berhinaus   auch  die  meisten  von  MOCKA  vorgenommenen  Spracherweiterungen
beruecksichtigt. Insbesondere die  Abbildung  der  Grundtypen,  die  zugrunde-
gelegten  Regeln hinsichtlich Typkompatibilitaet und die Behandlung von Mengen
orientiert sich an der Implementierung von MOCKA.
  Fuer die Sprache C wurde die deutsche Uebersetzung der  bereits  etwas  ael-
teren  Sprachbeschreibung von B.W. Kernighan und D. Ritchie [Kernighan78, Ker-
nighan83] als Ausgangsbasis gewaehlt.  Es  werden  jedoch  auch  einige  Spra-
chelemente  wie  z.B.  Zuweisung  von Strukturen als Ganzes verwendet, die zum
damaligen Zeitpunkt noch nicht in allen  Implementierungen  verfuegbar  waren.
Die  gestellte  Mindestanforderung  an die erzeugten C-Programme ist, dasz sie

                                8











von den an der GMD Forschungsstelle Karlsruhe verfuegbaren C-Uebersetzern  der
Firmen SUN und PCS akzeptiert werden.
  In der folgenden Beschreibung der Abbildung wird an den entsprechenden Stel-
len   auf   moeglicherweise   implementierungsabhaengige   Annahmen  besonders
hingewiesen.


4.2
     Programmrepraesentation

  Die erzeugten C-Programme werden zur Erhoehung der Lesbarkeit  durch  geeig-
nete Einrueckungen und Verwendung von Zwischenraeumen formatiert.


4.2.1
       Bezeichner

  Die moeglichen Modula-Bezeichner bilden eine  Teilmenge  der  moeglichen  C-
Bezeichner,  insbesondere werden in beiden Sprachen Grosz- und Kleinbuchstaben
unterschieden. Die Bezeichner koennen  daher  in  der  Regel  direkt  aus  dem
Modula-Programm  in  das C-Programm uebernommen werden.  Um Namenskonflikte im
erzeugten C-Programm zu vermeiden, ist es  jedoch  in  den  folgenden  Faellen
notwendig, den Bezeichner durch das Hinzufuegen eines Praefix umzubenennen:
-
    Der Bezeichner ist ein Schluesselwort der Sprache C.
-
    Der Bezeichner wird bereits fuer ein vom Uebersetzer vordefiniertes Objekt
    verwendet.
-
    Aufgrund  der   unterschiedlichen   Regeln   hinsichtlich   des   Gueltig-
    keitsbereichs  von  Bezeichnern  oder durch eine fuer die Abbildung nach C
    notwendige Transformation des Modula-Programms wuerde  ein  Namenskonflikt
    entstehen.
  Der Praefix hat die Form C_nnn_,  wobei  nnn  fuer  eine  eindeutige  Nummer
steht.  Die  Abkuerzungen nnn und xxx werden im folgenden fuer die Bezeichnung
von vom Uebersetzer vergebenen Nummern benutzt.
  Es sei an dieser Stelle darauf verwiesen, dasz bei  aelteren  C-Uebersetzern
zur  Unterscheidung  von Bezeichnern haeufig nur wenige Zeichen verwendet wer-
den. Da aber bei neueren C-Uebersetzern hier meistens keine Restriktionen mehr
bestehen, wird dies bei der Abbildung nicht beruecksichtigt.


4.2.2
       Numerische Konstanten

  Die ganzzahligen  Konstanten  von  Modula-2  werden  gemaesz  der  folgenden
Tabelle mit regulaeren Ausdruecken nach C uebersetzt:

           _______________________________________________________
                    Modula-2                        C
           _______________________________________________________
            [0-9]+                      [0-9]+
            [0-7]+ B                    0 [0-7]+
            [0-7]+ C                    (unsigned char) '\[0-7]+'
            [0-9] [0-9A-F]* H           0X [0-9] [0-9A-F]*
           _______________________________________________________
          




                                     




                                                                 





              Tabelle 4.1: Abbildung von ganzzahligen Konstanten

Bei den dezimalen Konstanten muessen fuehrende Nullen entfernt werden, da  sie
sonst in C als oktale Konstanten interpretiert werden.

                                9











  Ganzzahlige Konstanten haben in C den Typ int oder long,  d.h.   sie  werden
als  ganze  Zahl  mit  Vorzeichen interpretiert. Modula-2 definiert, dasz eine
ganzzahlige      Konstante      n,      deren      Wert       im       Bereich
MAX(INTEGER) < n _ MAX(CARDINAL)  liegt, den Typ CARDINAL hat, d.h. n wird als
ganze Zahl ohne Vorzeichen interpretiert.   Bei  einer  direkten  Uebersetzung
einer  solchen  Konstanten  entsprechend der obigen Tabelle nach C, wuerde das
dazugehoerige Bitmuster vom C-Uebersetzer  als  negative  Zahl  interpretiert.
Daher  wird  einer solchen Konstanten in C eine explizite Typumwandlung in den
Typ unsigned long vorangestellt, um eine  korrekte  Interpretation  als  ganze
Zahl ohne Vorzeichen durch den C-Uebersetzer zu erzwingen.
  Fuer Zeichenkonstanten der Form [0-7]+ C existiert ein  aehnliches  Problem.
MOCKA erlaubt Zeichenkonstanten c im Bereich 0 _ c _ 255.  In C haben Zeichen-
konstanten den Typ char. Werden C-Zeichenkonstanten oder  -variablen  z.B.  in
relationalen  Ausdruecken  verwendet,  so werden sie zunaechst implizit in den
Typ int umgewandelt. Diese Umwandlung ist maschinenabhaengig. Eine Zeichenkon-
stante,  deren  Wert  als  oktales Bitmuster definiert ist, kann dabei negativ
erscheinen. Der Modula-Ausdruck  0C < 377C  ist  immer  wahr,  der  C-Ausdruck
'\0' < '\377'  ist  dagegen,  abhaengig von der jeweiligen Maschine, wahr oder
falsch.  Um diese  Fehlinterpretation  zu  vermeiden,  wird,  wie  der  obigen
Tabelle  zu  entnehmen  ist,  solchen  Zeichenkonstanten  in  C eine explizite
Typumwandlung in den Typ unsigned char vorangestellt, was zur Folge hat,  dasz
bei  einer  impliziten  Typumwandlung  in den Typ int kein negativer Wert mehr
entstehen kann.
  Im Modula-Programm enthaltene Gleitpunktkonstanten koennen textuell  in  das
erzeugte  C-Programm  eingesetzt werden, da die in Modula-2 zulaessigen Gleit-
punktkonstanten eine Teilmenge der in C zulaessigen Gleitpunktkonstanten  dar-
stellen.


4.2.3
       Zeichenketten

  Die Abbildung von Zeichenketten haengt davon ab, wie sie im  Modula-Programm
verwendet werden. Dabei musz insbesondere folgendes beachtet werden:
-
    Eine   Zeichenkette   der   Laenge   n   ist   in   Modula-2    vom    Typ
    ARRAY [0..n-1] OF CHAR.
-
    Eine Zeichenkette der Laenge 1 ist in  Modula-2  kompatibel  mit  dem  Typ
    CHAR.
-
    In C wird eine Zeichenkette als initialisierter Vektor von Zeichen  betra-
    chtet, der am Ende ein zusaetzliches NUL-Zeichen enthaelt.
-
    C unterscheidet zwischen Zeichenkonstanten und Zeichenketten der Laenge 1.
  Bei der Abbildung wird daher folgendermaszen vorgegangen:
-
    Eine Zeichenkette der Sprache Modula-2 mit  Laenge  n > 1  wird  auf  eine
    Zeichenkette der Sprache C abgebildet.
-
    Falls eine Zeichenkette der Laenge 1 in einem Kontext benutzt wird, in dem
    ein  Ausdruck  vom  Typ  CHAR  erwartet  wird,  dann  wird sie auf eine C-
    Zeichenkonstante abgebildet. Wird diese Zeichenkette jedoch in einem  Kon-
    text  benutzt,  in  dem ein Ausdruck vom Typ ARRAY [0..0] OF CHAR erwartet
    wird, dann wird sie zu einer C-Zeichenkette.
  Die folgenden Zeichen muessen in C innerhalb von Zeichenketten und -konstan-
ten durch das Fluchtsymbol \ maskiert werden:  \  '  ".




                               10











4.2.4
       Kommentare

  Die Kommentare im Modula-Programm koennten auf C-Kommentare abgebildet  wer-
den, wobei beruecksichtigt werden mueszte, dasz C keine geschachtelten Kommen-
tare kennt. Da aber in Modula-2 Kommentare an jeder beliebigen Stelle des Pro-
gramms stehen koennen und es keine allgemeinen Regeln bezueglich der Zuordnung
von Kommentaren zu Programmstellen gibt, wuerde im erzeugten C-Programm -  bei
jeder  fuer diese Zuordnung gewaehlten Loesung - ein erheblicher Teil der Kom-
mentare an die falschen Programmstellen plaziert. Daher ist es sinnvoller  auf
die Kommentare im C-Programm voellig zu verzichten.


4.3
     Gueltigkeit und Sichtbarkeit

  Die Regeln  bezueglich  Gueltigkeit  und  Sichtbarkeit  von  Bezeichnern  in
Modula-2  und C weisen eine Reihe von Unterschieden auf, die bei der Abbildung
beruecksichtigt werden muessen.
  Modula-2 ermoeglicht es durch das Modulkonzept den Gueltigkeitsbereich  bzw.
die Sichtbarkeit von in globalen oder lokalen Moduln1 vereinbarten Bezeichnern
mit  Import-  bzw. Exportanweisungen explizit zu kontrollieren. Auszerdem kann
man, insbesondere zur Vermeidung von Namenskonflikten, importierte  Bezeichner
durch  den Namen des sie exportierenden Moduls qualifizieren.  C hat kein ver-
gleichbares Modulkonzept. Die einzige in C vorhandene Moeglichkeit zur expliz-
iten  Kontrolle des Gueltigkeitsbereichs von Bezeichnern ist, die Sichtbarkeit
von globalen Objekten durch Angabe  der  Speicherklasse  static  auf  die  sie
enthaltende  Quelldatei  zu  beschraenken. Daher wird bei der Abbildung nach C
wie folgt vorgegangen:
-
    Alle  von  globalen  Moduln  exportierten  Bezeichner  werden  in  den  C-
    Programmen in der qualifizierten Form Modulname_Bezeichner geschrieben, um
    Namenskonflikte zu vermeiden. Eine Qualifikation nur bei  Namenskonflikten
    ist  nicht  mit  einer  getrennten Uebersetzung von globalen Moduln nach C
    vereinbar.
-
    In lokalen Moduln deklarierte Bezeichner werden in  unqualifizierter  Form
    geschrieben.  Sie  muessen durch einen Praefix umbenannt werden, falls bei
    der Abbildung der lokalen Moduln nach C Namenskonflikte entstehen.
-
    Alle globalen Funktionen und Variablen, die nicht exportiert werden,  wer-
    den in C in der Speicherklasse static vereinbart, um ihre Sichtbarkeit auf
    die sie enthaltende Quelldatei zu beschraenken.
  Modula-2 erlaubt, dasz ein Bezeichner in einer Anweisung verwendet wird, die
textuell der Deklaration des Bezeichners  vorausgeht;  dies  ist  in  C  nicht
zulaessig2.  Dieses Problem wird folgendermaszen geloest:
-
    Alle Prozedurdeklarationen werden an das Ende des  sie  enthaltenden  Dek-
    larationsteils  verschoben.  Abgesehen  von dieser Verschiebung bleibt die
    urspruengliche Reihenfolge der Deklarationen erhalten. Damit erfolgen alle
    Konstanten-,  Variablen-  und Typdeklarationen vor ihrer ersten Verwendung
    in einer Anweisung.
-
    Alle Prozeduren, die vor ihrer Vereinbarung verwendet werden,  muessen  im
    C-Programm vor ihrer ersten Benutzung durch eine Deklaration der Form

____________________
1 Ein globaler Modul ist ein Programmodul  oder  er  besteht  aus
  einem Definitions- und einem Implementierungsmodul.
2 Einzige  Ausnahme:  Funktionen  die  ein  Resultat  vom Typ int
  liefern.

                               11











        Speicherklasse  Ergebnistyp  Prozedurname  ();

    bekannt gemacht werden. Eine  solche  Deklaration  -  die  einer  forward-
    Deklaration  in  Pascal  entspricht- ist insbesondere dann notwendig, wenn
    sich Prozeduren gegenseitig rekursiv  aufrufen.   Die  Speicherklasse  ist
    static,  falls  die  Prozedur nicht exportiert wird, und extern, falls sie
    exportiert wird.
Der folgende Ausschnitt eines Modula-Programms

    PROCEDURE Expr;
    BEGIN
      Term;
      WHILE Token = "+" DO
        Token := GetToken ();
        Term;
      END;
    END Expr;
    PROCEDURE Term;
    BEGIN
      Factor;
      ...
    PROCEDURE Factor;
    BEGIN
      CASE Token OF
      | "(" : Token := GetToken (); Expr;
      ...
    VAR  Token : CHAR;

wird in C zu

    CHAR Token;
    extern void Term   ();
    extern void Factor ();
    void Expr()
    {
        Term();
        while (Token == '+') {
            Token = GetToken();
            Term();
        }
    }
    void Term()
    {
        Factor();
      ...
    void Factor()
    {
        switch (Token) {
        case '(' :
            Token = GetToken(); Expr();
      ...



                               12











  Modula-2 verlangt, dasz in Deklarationen  verwendete  Bezeichner  vor  ihrer
ersten  Anwendung  vereinbart  werden.  Um  jedoch die Definition von ,,rekur-
siven'' Typen zu ermoeglichen, kann bei der Deklaration  von  Zeigertypen  der
Name  des  Bezugstyps  vor  seiner Deklaration verwendet werden.  Das folgende
Beispiel zeigt eine solche ,,rekursive'' Definition:

    TYPE
      tTree = POINTER TO tNode;
      tNode = RECORD
                 Key   : INTEGER;
                 Left  ,
                 Right : tTree;
              END;

  Da C die Verwendung von  Strukturnamen  erlaubt,  bevor  eine  vollstaendige
Definition  der Struktur vorliegt, kann die obige Definition durch Einfuehrung
eines Strukturnamens nach C uebersetzt werden:

    typedef struct S_1 *tTree;
    typedef struct S_1 {
        INTEGER Key;
        tTree   Left, Right;
    } tNode;

  Ist der Bezugstyp kein Verbund, so ist eine Abbildung nach C nur  mit  erhe-
blichem  Aufwand  moeglich.  Eine  allgemeine  Loesung koennte folgendermaszen
aussehen:
-
    Handelt es sich nicht um eine ,,rekursive''  Typdeklaration,  dann  werden
    die   Deklarationen   derart  umgeordnet,  dasz  alle  Vereinbarungen  der
    beteiligten Typen vor ihrer ersten Anwendung erfolgen1.
-
    Handelt es sich um eine ,,rekursive'' Typdeklaration, dann muessen  einige
    oder  alle  der  beteiligten  Typen in C zu einer Struktur gemacht werden.
    Die folgende Deklaration

        TYPE
          tPointer1 = POINTER TO tPointer2;
          tPointer2 = POINTER TO tPointer1;

    wuerde dann in C zu

        typedef struct S_2 *tPointer1;
        typedef struct S_2 {
            tPointer1 *X;
        } tPointer2;

  Diese Loesung ist jedoch mit einem erheblichen Uebersetzungsaufwand  verbun-
den.  Darueberhinaus  musz  man beruecksichtigen, dasz Zeigerdeklarationen, in
denen der Bezugstyp erst nach dem Zeigertyp  definiert  wird,  in  der  Praxis
hauptsaechlich   zur   Definition   von   Listen,   Baeumen   oder  aehnlichen
____________________
1 Dies entspricht einer topologischen Sortierung des  gerichteten
  Graphen,  der  durch die Relation ,,wird verwendet zur Deklara-
  tion von'' definiert wird.

                               13











Datenstrukturen verwendet werden. In diesen Faellen  ist  der  Bezugstyp  aber
fast  immer  ein  Verbund.   Aus  diesen  Gruenden  ist es sinnvoller, Modula-
Programme, die solche Typdeklarationen enthalten, nur dann nach  C  zu  ueber-
setzen, wenn der Bezugstyp ein Verbund ist.
  Symbolische Konstanten werden in C mit Hilfe der  #define-Anweisung  des  C-
Praeprozessors  vereinbart.   Bei  der  Abbildung musz beruecksichtigt werden,
dasz der Gueltigkeitsbereich eines mit #define vereinbarten Makros der gesamte
Rest der Quelldatei ist.
  Fuer mit typedef vereinbarte Typnamen  gilt  laut  C-Sprachbeschreibung  die
uebliche Blockstruktur von C. Das heiszt eine Deklaration der Art

    typedef char tType;
      ...
    {
        typedef int tType;

ist eigentlich zulaessig. Viele C-Uebersetzer sind jedoch nicht in  der  Lage,
eine derartige Deklaration zu verarbeiten.
  Die oben  genannten  Einschraenkungen  fuer  die  mehrfache  Verwendung  von
Konstanten- und Typnamen werden bei der Uebersetzung dadurch geloest, dasz die
Namen  von  Konstanten  und  Typen  durch  eine  Umbenennung  innerhalb  einer
Quelldatei eindeutig gemacht werden.


4.4
     Deklarationen

4.4.1
       Konstantendeklarationen

  Die Abbildung von Konstantendeklarationen ist abhaengig von der Art der Kon-
stante.
  Eine Konstante, deren Wert eine Zeichenkette mit Laenge n > 1 ist, wird  auf
einen Vektor von Zeichen abgebildet, der mit der angegebenen Zeichenkette ini-
tialisiert wird. Ist der Wert der Konstante eine Zeichenkette  der  Laenge  1,
dann  wird  diese  Konstante  im  C-Programm  mit  einer #define-Anweisung als
Zeichenkonstante definiert. Wird  diese  Konstante  jedoch  in  einem  Kontext
benutzt,  in dem ein Ausdruck mit Typ ARRAY [0..0] OF CHAR erwartet wird, dann
musz der Wert der Konstante als Zeichenkette direkt fuer  den  Konstantennamen
eingesetzt werden.
  Alle uebrigen im Modula-Programm vereinbarten Konstanten werden im erzeugten
C-Programm mit einer #define-Anweisung vereinbart. Konstante Ausdruecke werden
dabei auf die entsprechenden C-Ausdruecke abgebildet, wenn der  Ausdruck  auch
in  C  einen  konstanten  Ausdruck bildet.  Konstante Ausdruecke, die logische
Operatoren, einen in C als Funktion definierten Operator oder eine  in  C  als
Funktion definierte Standardfunktion enthalten, sind in C nicht mehr konstant.
Solche Ausdruecke werden bei der Uebersetzung ausgewertet  und  der  Wert  des
Ausdrucks  wird fuer den Ausdruck eingesetzt. Diese Unterscheidung ist notwen-
dig, damit benannte Konstanten in C fuer Fallmarken von switch-Anweisungen und
zur  Dimensionierung  von  Vektoren verwendet werden koennen. Die Alternative,
konstante Ausdruecke immer schon bei der Uebersetzung auszuwerten,  vermindert
die  Lesbarkeit der erzeugten Programme und wurde daher verworfen.  Somit wer-
den die folgenden Deklarationen




                               14












    CONST
      Message       = "hello world";
      BitsPerBitset = SIZE (BITSET) * 8;
      EmptySet      = {};
      MaxToken      = 63;

in C zu

    CHAR Message[] = "hello world";
    #define BitsPerBitset   (sizeof(BITSET) * 8)
    #define EmptySet        0XL
    #define MaxToken        63

  Eine Auswertung von konstanten Ausdruecken bei der Uebersetzung nach  C  ist
in den meisten Faellen problemlos moeglich. Die von MOCKA gemachte Einschraen-
kung, dasz konstante Ausdruecke keine  Standardfunktionen  enthalten  duerfen,
wird  dabei  fallengelassen.  Schwierigkeiten bereitet aber die Auswertung der
Funktionen SIZE, TSIZE, MAX und MIN, da diese sowohl  von  der  Abbildung  der
Typen  nach  C  als  auch  von der Typabbildung des verwendeten C-Uebersetzers
abhaengen. Dieses Problem wird folgendermaszen geloest:
-
    Der Uebersetzer enthaelt eine Tabelle, in der vermerkt ist, welche Groesze
    die  Grund-, Standard-, Aufzaehlungs-, Mengen- und Zeigertypen in C haben.
    Die obigen Standardfunktionen koennen  fuer  diese  Typen  mit  Hilfe  der
    Tabelle ausgewertet werden.
-
    Feld- oder Verbundtypen als Argumente sind nicht zulaessig,  da  dazu  die
    genaue  Typabbildung  des C-Uebersetzers, insbesondere die moeglicherweise
    notwendige Ausrichtung von Strukturkomponenten, bekannt sein mueszte.
  Da der C-Praeprozessor Textersatz vornimmt, wird der Wert aller mit  #define
vereinbarten  Konstanten  im  C-Programm  textuell  fuer  den  Konstantennamen
eingesetzt. Deshalb ist  es  nicht  sinnvoll,  Zeichenketten  mit  #define  zu
vereinbaren,  denn  in  einem  C-Programm sind alle Zeichenketten verschieden,
selbst wenn sie aus der gleichen Zeichenfolge bestehen. Das bedeutet, dasz das
erzeugte  Objektprogramm bei mehrfacher Anwendung eines mit #define vereinbar-
ten Konstantennamens die zugehoerige Zeichenkette ebenfalls mehrfach enthalten
wuerde. Die Deklaration als initialisierter Vektor vermeidet dies.
  Wird der Wert der Modula-Konstante durch einen  konstanten  Ausdruck  spezi-
fiziert, musz bei der Abbildung nach C noch folgendes beachtet werden:
-
    Der Ausdruck musz, wegen des  vom  C-Praeprozessor  vorgenommenen  Texter-
    satzes,  geklammert  werden,  um  eine  korrekte Auswertungsreihenfolge zu
    garantieren.
-
    Falls der Ersatztext Namen enthaelt, die nicht selbst als  Makros  verein-
    bart  sind,  musz  darauf  geachtet werden, dasz nicht auf subtile Art und
    Weise im C-Programm Namenskonflikte entstehen.
-
    Konstante Ausdruecke werden vom C-Uebersetzer bereits bei der Uebersetzung
    des C-Programms ausgewertet.


4.4.2
       Typdeklarationen

  Die im Modula-Programm vereinbarten Typen  werden  im  erzeugten  C-Programm
mittels einer typedef-Anweisung vereinbart.


                               15











4.4.2.1
         Typkompatibilitaet

  Die von MOCKA implementierten Regeln hinsichtlich Typ- und  Zuweisungskompa-
tibilitaet,  die  weniger  streng  sind, als die in der Sprachbeschreibung von
Modula-2 enthaltenen, bilden die  Grundlage  fuer  diese  Abbildung.  Es  musz
besonders  darauf  geachtet  werden,  dasz  Typen,  die  in Modula-2 typ- bzw.
zuweisungskompatibel sind, dies auch im erzeugten C-Programm sind. Dabei koen-
nen folgende Eigenschaften von C vorteilhaft ausgenutzt werden:
-
    C definiert fuer arithmetische Typen1  eine  grosze  Zahl  von  impliziten
    Typumwandlungen  in  Ausdruecken bei der Zuweisung und der Parameterueber-
    gabe. Arithmetische Typen koennen daher in C fast in  beliebiger  Kombina-
    tion verwendet werden.
-
    Von den meisten  C-Uebersetzern  werden  Zeichen  und  ganzzahlige  Werte,
    unabhaengig  von ihrem tatsaechlichen Speicherbedarf, bei der Parameterue-
    bergabe mit 4 Byte uebergeben.
-
    Der C-Uebersetzer erlaubt Zuweisungen zwischen Zeigern verschiedenen Typs.
    Bei  der  Uebergabe  von  Zeigern  an  eine Funktion darf sich der Typ des
    aktuellen Parameters vom Typ des formalen Parameters unterscheiden.  Diese
    Zuweisungen  bzw. Parameteruebergaben erfolgen als reine Kopien, ohne jede
    Umwandlung. Ohne eine explizite Typumwandlung wird das Pruefprogramm lint,
    mit  dem  C-Programme auf semantische Fehler untersucht werden koennen, an
    diesen Stellen Typfehler melden, was aber nicht unbedingt  bedeuten  musz,
    dasz die Programme wirklich fehlerhaft sind.
-
    Der C-Uebersetzer nimmt praktisch keine Typpruefungen vor.
  Bei der Abbildung der nicht zusammengesetzten Typen  wird  darauf  geachtet,
dasz  die Groesze der Typen im C-Programm wenn moeglich der von MOCKA fuer die
entsprechenden  Modula-Typen  vorgesehenen  Groesze  entspricht.  Mit   dieser
Voraussetzung  und aufgrund der oben geschilderten Eigenschaften von C sind im
erzeugten C-Programm nur an einigen wenigen Stellen explizite  Typumwandlungen
notwendig,  damit  die  C-Programme  korrekt  funktionieren.  Durch die Angabe
einer Option bei der Uebersetzung von Modula-2 nach C kann man Mtc  allerdings
dazu  veranlassen, weitere explizite Typumwandlungen zu erzeugen, die fuer das
korrekte Funktionieren der erzeugten  C-Programme  nicht  unbedingt  notwendig
sind  und  daher  normalerweise  wegen der damit verbundenen schlechteren Les-
barkeit der C-Programme weggelassen werden, die aber dazu fuehren,  dasz  lint
keine Typfehler mehr meldet.


4.4.2.2
         Grundtypen

  Die Menge der vordefinierten Grundtypen von  Modula-2,  die  aus  den  Typen
INTEGER,  CARDINAL,  BOOLEAN,  CHAR,  REAL,  LONGREAL und LONGINT besteht, ist
entsprechend der von MOCKA implementierten Spracherweiterung um die Grundtypen
SHORTINT,  SHORTCARD  und LONGCARD erweitert. Die Definition dieser Grundtypen
ist in der Definitionsdatei SYSTEM_.h enthalten,  die  mit  Hilfe  einer  #in-
clude-Anweisung  vom  C-Praeprozessor  in jedes erzeugte C-Programm eingefuegt
wird.  Die folgende Aufzaehlung zeigt die Definition der Grundtypen2:
____________________
1 Zu den arithmetischen Typen gehoeren in C die Typen: char, int,
  float  und  double.  Der  Typ int kann mit einer Groeszenangabe
  short oder long versehen sein. Auszerdem  kann  man  char-  und
  int-Objekte  auch  als  unsigned,  d.h.  als  ganze  Zahl  ohne
  Vorzeichen, vereinbaren.
2 Da MOCKA die Typen  INTEGER  und  LONGINT  sowie  CARDINAL  und
  LONGCARD als synonym vereinbart, werden sie auch bei der Abbil-
  dung nach C als synonym vereinbart.

                               16












    typedef short           SHORTINT;
    typedef long            LONGINT;
    typedef LONGINT         INTEGER;
    typedef unsigned short  SHORTCARD;
    typedef unsigned long   LONGCARD;
    typedef LONGCARD        CARDINAL;
    typedef unsigned char   BOOLEAN;
    #define FALSE           (BOOLEAN)0
    #define TRUE            (BOOLEAN)1
    typedef unsigned char   CHAR;
    typedef float           REAL;
    typedef double          LONGREAL;

  Der Typ CHAR musz, wegen der Probleme  bei  der  impliziten  Umwandlung  von
Zeichenwerten in ganzzahlige Werte (s. Kap. 4.2.2), in C als unsigned char und
nicht als char definiert werden.


4.4.2.3
         Aufzaehlungstypen

  Die auf den ersten Blick naheliegende Abbildung von  Aufzaehlungstypen  ist,
die  Aufzaehlungstypen  von  Modula-2  direkt  auf die Aufzaehlungstypen von C
abzubilden. Die Deklaration

    TYPE  Color = (red, green, blue);

wuerde damit in C zu

    typedef enum {red, green, blue} Color;

  Die C-Sprachbeschreibung legt fest, dasz die in  der  Aufzaehlung  genannten
Namen  als Konstanten vereinbart sind und ueberall dort verwendet werden koen-
nen, wo in C Konstanten zulaessig sind.  Die Konstanten erhalten  aufeinander-
folgende ganzzahlige Werte, wobei die erste Konstante der Aufzaehlung den Wert
0 hat. Viele C-Uebersetzer verbieten jedoch,  Aufzaehlungskonstanten  z.B.  in
Vergleichen  oder zur Indizierung von Vektoren zu verwenden. Diese Einschraen-
kung kann allerdings umgangen werden, indem  Aufzaehlungskonstante  in  diesen
Faellen  mittels  einer expliziten Typumwandlung in einen int-Wert umgewandelt
werden:

    a[(int)red] = 1;

  Eine weitere Schwierigkeit ist, dasz eine Reihe von C-Uebersetzern es  nicht
vertraegt,  wenn eine Aufzaehlungskonstante innerhalb einer Funktion lokal neu
deklariert wird. Solche Aufzaehlungskonstanten mueszten daher  umbenannt  wer-
den.
  Um die oben  genannten  Probleme  zu  vermeiden,  wurde  folgende  Abbildung
gewaehlt:    der    Aufzaehlungstyp   wird   entsprechend   der   Anzahl   von
Aufzaehlungskonstanten in einen unsigned-Typ geeigneter Groesze umgesetzt; die
Aufzaehlungskonstanten werden mit #define-Anweisungen als symbolische Konstan-
ten vereinbart.  Fuer die Namen der Aufzaehlungskonstanten gilt wie fuer  alle
mit  #define  vereinbarten  Konstantennamen,  dasz  sie  bei Bedarf durch eine

                               17











Umbenennung innerhalb der sie enthaltenden Quelldatei eindeutig gemacht werden
muessen (s. Kap. 4.3).  Die obige Deklaration wird dann zu:

    #define red     0
    #define green   1
    #define blue    2
    typedef unsigned char Color;

  Der Vorteil dieser Loesung ist, dasz keine  Typumwandlungen  mehr  notwendig
sind; der Nachteil eine schlechtere Lesbarkeit der Typdeklaration.


4.4.2.4
         Unterbereichstypen

  Unterbereichstypen werden nach C abgebildet, indem mit Hilfe einer  typedef-
Anweisung  der  Name des Unterbereichstyps als synonym zum Namen des Basistyps
vereinbart wird. Ist der Basistyp in  der  Deklaration  des  Unterbereichstyps
nicht  explizit  angegeben, so musz er aus dem Typ der unteren und/oder oberen
Grenze des Unterbereichstyps abgeleitet werden. Sind die  untere/obere  Grenze
ganzzahlige  Konstanten,  dann  legt die Sprachbeschreibung von Modula-2 fest,
dasz der Basistyp INTEGER ist, falls die untere Grenze eine negative Zahl ist,
und ansonsten CARDINAL.  Somit werden die folgenden Deklarationen

    TYPE
      TrafficLight  = [red..green];
      tToken        = [0..MaxToken];

in C zu

    typedef Color     TrafficLight;
    typedef CARDINAL  tToken;



4.4.2.5
         Felder

  Eine direkte Abbildung der Felder der Sprache Modula-2 auf die Vektoren  der
Sprache  C  ist,  wegen  der  ungewoehnlichen  Semantik  der  Vektoren,  nicht
sinnvoll. Vektoren koennen nicht als Ganzes zugewiesen werden oder  als  Wert-
parameter uebergeben werden. Bei der Zuweisung und der Parameteruebergabe wird
ein Vektorname immer als Zeiger auf das erste Element  des  Vektors  interpre-
tiert.  Aus  diesem  Grund  musz in C die Zuweisung eines Vektors elementweise
erfolgen.  Will man den Vektor als Wertparameter uebergeben, musz der ueberge-
bene  Vektor am Anfang der Funktion in einen lokal vereinbarten Vektor kopiert
werden.  Da neuere C-Uebersetzer  in  der  Lage  sind  Strukturen  als  Ganzes
zuzuweisen  oder sie als Wertparameter an Funktionen zu uebergeben, wird diese
Schwierigkeit umgangen, indem ein Feld auf eine Struktur mit  einem  Vektor  A
als  einziger Komponente abgebildet wird [PTC87].  Die Anzahl der Elemente von
Vektoren wird in C durch einen konstanten Ausdruck angegeben, daher  musz  bei
der Uebersetzung fuer den Indextyp ein konstanter Ausdruck erzeugt werden, der
angibt wieviele verschiedene Werte der Indexbereich  umfaszt.   Die  folgenden
Typdeklarationen





                               18












    TYPE
      tString       = ARRAY [0..255] OF CHAR;
      tTokenSet     = ARRAY [0..1] OF BITSET;

werden in C also zu

    typedef struct S_3 {
        CHAR A[255 + 1];
    } tString;
    typedef struct S_4 {
        BITSET A[1 + 1];
    } tTokenSet;

  Diese Loesung hat mehrere Vorteile: Zunaechst wird damit die  Zuweisung  von
Feldern bzw. ihre Uebergabe als Wertparameter erheblich effizienter, weil kein
C-Code zum Kopieren mehr notwendig ist, sondern direkt der  Zuweisungsoperator
bzw.  der  Parameteruebergabemechanismus  von C verwendet werden kann. Der vom
C-Uebersetzer dafuer erzeugte Code ist in der Regel effizienter, da  spezielle
Assembler-Befehle  verwendet  werden  koennen.  Der  zweite  Vorteil  ist eine
Vereinfachung des Uebersetzers, weil  Felder  jetzt  bei  der  Zuweisung,  der
Parameteruebergabe und der Adreszbestimmung wie alle anderen Datentypen behan-
delt werden koennen.


4.4.2.6
         Verbunde

  Modula-2 verlangt die Eindeutigkeit  der  Komponentennamen  eines  Verbundes
lediglich  innerhalb  der Definition des Verbundtyps. Insbesondere kann man in
einem Deklarationsteil den gleichen Komponentennamen  in  der  Definition  von
zwei  verschiedenen Verbunden benutzen. Die C-Sprachbeschreibung fordert, dasz
die Namen aller Komponenten von zwei im gleichen  Gueltigkeitsbereich  verein-
barten Strukturen untereinander verschieden sind1.   Die  meisten  neueren  C-
Uebersetzer sind hier allerdings groszzuegiger und verlangen die Eindeutigkeit
nur innerhalb der Definition einer Struktur. Diese Regel wird  voraussichtlich
auch  im  neuen C-Sprachstandard enthalten sein. Daher werden Verbunde direkt,
ohne Beruecksichtigung von moeglichen  Namenskonflikten  aufgrund  identischer
Komponentennamen,  auf die Strukturen der Sprache C abgebildet. Somit wird die
Typdeklaration

    TYPE  date = RECORD
                   day   : [1..31];
                   month : [1..12];
                   year  : CARDINAL;
                 END;

in C zu





____________________
1 Ausnahme: Zwei Strukturen beginnen mit der gleichen  Folge  von
  Komponenten.


                               19












    typedef struct S_5 {
        CARDINAL day;
        CARDINAL month;
        CARDINAL year;
    } date;

  Die Strukturen, auf die die Felder und Verbunde der Sprache  Modula-2  abge-
bildet  werden, erhalten immer einen Strukturnamen. Diese Strukturnamen werden
in den erzeugten C-Programmen an verschiedenen Stellen benoetigt, z.B. bei der
Uebersetzung  von  Vorwaertsreferenzen  in  Zeigerdeklarationen (s. Kap. 4.3).
Wegen der getrennten Uebersetzung  und  zur  Vermeidung  von  Namenskonflikten
haben die Strukturnamen der in einem Definitionsmodul definierten Verbunde und
Felder in C die lange Form Modulname_nnn1; alle uebrigen  Strukturnamen  haben
die kuerzere Form S_nnn.


4.4.2.7
         Verbunde mit Varianten

  Die Datenstruktur Variante der Sprache C  entspricht  einem  varianten  Teil
eines Verbundes in Modula-2. Eine Variante in C kann allerdings - im Gegensatz
zu einer Variante in Modula-2 - nur eine einzige Komponente zur gleichen  Zeit
enthalten2.
  Die Typdeklaration

    TYPE  tRecord =    RECORD
                         x ,
                         y : CHAR;
            CASE      tag0 : Color OF
            | red   : a, b : CHAR;
            | green : c, d : CHAR;
            | blue  : e, f : CHAR;
            END;
                         z : CHAR;
            CASE      tag1 : BOOLEAN OF
            | TRUE  : u, v : INTEGER;
            | FALSE : r, s : INTEGER;
            END;
          END;

wird in C zu

    typedef struct S_6 {
        CHAR    x, y;
        Color   tag0;
____________________
1 Besteht der Modulname nur aus einem  Buchstaben,  so  wird  das
  Zeichen  _ verdoppelt, um theoretisch moegliche Namenskonflikte
  mit anderen vom Uebersetzer erzeugten  Bezeichnern  zu  verhin-
  dern.
2 Die fuer die jeweiligen  Datenstrukturen  der  beiden  Sprachen
  gebraeuchlichen  deutschen  Begriffe  sind  hier  leider  etwas
  verwirrend.   Eine  Komponente  der  C-Datenstruktur   Variante
  (Englisch:  Union)  entspricht  einer  Variante eines varianten
  Teils eines Modula-Verbundes.


                               20











        union {
            struct {CHAR a, b;} V_1;
            struct {CHAR c, d;} V_2;
            struct {CHAR e, f;} V_3;
        } U_1;
        CHAR    z;
        BOOLEAN tag1;
        union {
            struct {INTEGER u, v;} V_1;
            struct {INTEGER r, s;} V_2;
        } U_2;
    } tRecord;

  Jeder variante Teil des Modula-Verbundes wird in C zu einer Variante.  In  C
musz  die Variante allerdings, da sie eine Komponente der umfassenden Struktur
ist, einen zusaetzlichen Komponentennamen U_nnn bekommen, wobei nnn angibt, um
den  wievielten  varianten  Teil  des  Modula-Verbundes  es  sich handelt. Zur
Umgehung der Einschraenkung, dasz Varianten in C nur genau eine Komponente zur
gleichen  Zeit enthalten koennen, musz jede Variante des Modula-Verbundes in C
zusaetzlich in eine Struktur geklammert werden. Diese Strukturen erhalten  den
Komponentennamen  V_nnn, wobei nnn angibt, um die wievielte Variante innerhalb
eines varianten Teils es  sich  jeweils  handelt.  Bei  der  Uebersetzung  des
Zugriffs  auf  Varianten  muessen  diese  zusaetzlichen  Komponentennamen dann
entsprechend beruecksichtigt werden.


4.4.2.8
         Mengen

  Mengen werden in C einheitlich auf den Typ unsigned long  abgebildet.  Damit
kann eine Menge maximal 16 oder 32 Elemente enthalten1  je  nach  Groesze  des
Typs  auf  der  Zielmaschine.   Diese Abbildung vereinfacht die Behandlung von
Mengen und steigert  zusaetzlich  die  Effizienz  der  Mengenverarbeitung,  da
jetzt:
-
    Konstante Mengen in C als Hexadezimalkonstante  oder  als  konstante  Aus-
    druecke dargestellt werden koennen.
-
    Die Mengenoperationen in C weitgehend ohne  zusaetzliche  Funktionsaufrufe
    mit den Operatoren zur Bitmanipulation implementiert werden koennen.
-
    Mengen als Wertparameter uebergeben und  als  Funktionsergebnis  geliefert
    werden koennen.
  Der Standardtyp BITSET ist definiert als:

    typedef unsigned long BITSET;



4.4.2.9
         Zeiger

  Zeigertypen werden direkt auf die  Zeigertypen  der  Sprache  C  abgebildet.
Damit wird

    TYPE  PtrToCardinal = POINTER TO CARDINAL;
____________________
1 MOCKA macht die gleiche Einschraenkung, daher duerfte  dies  in
  unserem Fall keine wirkliche Einschraenkung bedeuten.


                               21












in C zu

    typedef CARDINAL *PtrToCardinal;

  Wie oben bereits erlaeutert, werden die Zeigerdeklarationen,  in  denen  der
Bezugstyp  erst nach dem Zeigertyp vereinbart wird, auf Faelle beschraenkt, in
denen der Bezugstyp ein Verbund oder ein Feld ist.
  Die Konstante NIL ist in SYSTEM_.h als

    #define NIL     0L

definiert.


4.4.2.10
          Prozedurtypen

  Ein Prozedurtyp wird in C zu einem Zeiger auf eine Funktion mit entsprechen-
dem Ergebnistyp.  Somit wird die Typdeklaration

    TYPE  Function = PROCEDURE (CARDINAL): CARDINAL;

in folgende C-Deklaration umgesetzt:

    typedef CARDINAL (*Function)();

  Der Standardtyp PROC ist definiert als:

    typedef void (*PROC)();



4.4.3
       Variablendeklarationen

  Variablendeklarationen  werden  auf  entsprechende  C-Variablendeklarationen
abgebildet,  die  aus  einem  Typnamen  und einer Liste von Deklaratoren [Ker-
nighan78] bestehen.  Die folgenden Variablendeklarationen (s.  Beispiele  Kap.
4.3 und 4.4.2)

    VAR
      x, y  : POINTER TO INTEGER;
      i, j  : CARDINAL;
      p, q  : BOOLEAN;
      s     : BITSET;
      F     : Function;
      S     : tString;
      t     : tTree;
      w, v  : ARRAY [0..7] OF
                RECORD
                  ch    : CHAR;
                  count : CARDINAL;
                END;

werden somit in C zu


                               22











    INTEGER     *x, *y;
    CARDINAL    i, j;
    BOOLEAN     p, q;
    BITSET      s;
    Function    F;
    tString     S;
    tTree       t;
    struct S_7 {
        struct S_8 {
            CHAR     ch;
            CARDINAL count;
        } A[7 + 1];
    } w, v;



4.4.4
       Prozedurdeklarationen

  Die Deklaration einer Prozedur oder  Funktion  wird  in  C  auf  eine  Funk-
tionsdeklaration abgebildet.  Eine Prozedur hat als C-Funktion den Ergebnistyp
void, womit in C angedeutet wird, dasz die  Funktion  kein  Ergebnis  liefert.
Sowohl  Modula-2  als  auch  C  erlauben rekursive Aufrufe von Prozeduren bzw.
Funktionen. Prozedurdeklarationen koennen in  Modula-2  beliebig  geschachtelt
werden;  C  erlaubt  keine  geschachtelten  Funktionsdeklarationen. Aus diesem
Grund musz ein Modula-Programm,  das  solche  geschachtelten  Prozedurdeklara-
tionen enthaelt, bei der Uebersetzung nach C derart transformiert werden, dasz
keine geschachtelten Prozedurdeklarationen mehr vorhanden  sind.   Bei  dieser
Transformation muessen besonders die beiden folgenden Punkte beachtet werden:
-
    Bei der Deklaration einer lokalen Prozedur in Modula-2 koennen  Konstanten
    und/oder  Typen  verwendet  werden,  die  in  einer  statisch  umfassenden
    Prozedur vereinbart sind.
-
    Eine  lokale  Prozedur  kann  auf  eine  lokale  Variable  einer  statisch
    umfassenden  Prozedur zugreifen.  Um diesen Zugriff zur Laufzeit zu ermoe-
    glichen, enthaelt in Modula-2 jede Prozedurschachtel einen Verweis auf die
    Schachtel ihres statischen Vorgaengers.
  Geschachtelte Prozedurdeklarationen werden daher folgendermaszen behandelt:
-
    Ist eine Prozedur Q lokal in einer Prozedur P deklariert, dann  steht  die
    Funktion Q in C vor der Funktion P.
-
    Alle lokalen Konstanten- und Typdeklarationen der Prozedur P werden  in  C
    zu  globalen  Deklarationen, die vor die Funktion Q plaziert werden, damit
    sie auch fuer Q sichtbar sind.  Im Prinzip wuerde es genuegen, nur  solche
    lokalen  Konstanten-  und  Typen  von  P  global  zu vereinbaren, die in Q
    benutzt werden1.  Zur Vereinfachung der Transformation  werden  aber  alle
    lokalen  Konstanten-  und Typdeklarationen aus dem Modula-Programm in C zu
    globalen Deklarationen.
-
    Um in C der Funktion Q den Zugriff auf lokal in P vereinbarte Variablen zu
    ermoeglichen,  gibt  es verschiedene Moeglichkeiten. Eine Alternative ist,
    dasz die Funktion P die Adressen der lokalen  Variablen  als  zusaetzliche
    Parameter  an  Q  uebergibt,  eine  zweite  Alternative  verwendet globale
    Zeigervariablen [PTC87], um  den  Zugriff  zu  realisieren.  Diese  beiden
____________________
1  Dies gilt dann natuerlich  auch  rekursiv  fuer  alle  lokalen
  Objekte,  die  in  der Deklaration dieser Konstanten- und Typen
  verwendet werden.

                               23











    Varianten werden unten naeher beschrieben und miteinander verglichen.
-
    Bei dieser Transformation  koennen  eventuell  Namenskonflikte  entstehen.
    Diese werden in C durch Umbenennungen geloest.
  Zur Erlaeuterung der obigen Transformation und der beiden Alternativen,  den
Zugriff  auf  lokale  Variablen zu ermoeglichen, dient der folgende Ausschnitt
eines Modula-Programms:

    PROCEDURE p;
    TYPE
      tCard = CARDINAL;
    VAR
      i, j  : tCard;
      PROCEDURE q;
      BEGIN
        i := 1;
      END q;
      PROCEDURE r;
      BEGIN
        j := 1;
        q;
      END r;
    BEGIN
      r;
    END p;

  Die erste Alternative einer Funktion Q, den Zugriff auf lokal in einer Funk-
tion  P  vereinbarte Variablen zu ermoeglichen, geht von folgender Ueberlegung
aus: Da die Prozedur Q im Modula-Programm lokal zur Prozedur P vereinbart ist,
ruft  die  Prozedur  P  irgendwann,  moeglicherweise indirekt ueber den Aufruf
weiterer lokaler Prozeduren, die Prozedur Q auf.  Ist  dies  nicht  der  Fall,
dann  ist die Prozedur Q ,,nutzlos'' und kann aus dem Programm gestrichen wer-
den. Um in C der Funktion Q den Zugriff auf ihre lokalen Variablen  zu  ermoe-
glichen, uebergibt P deren Adressen als zusaetzliche Parameter an Q. Wegen des
moeglicherweise indirekten Aufrufs von Q musz zur Bestimmung der zusaetzlichen
Parameter der Aufrufgraph der lokalen Prozeduren betrachtet werden. Einige der
zusaetzlichen Parameter haben eventuell nur die Funktion, die Adressen der Va-
riablen  entlang  des Aufrufgraphen weiterzureichen. Prozedurvariablen muessen
dabei nicht beruecksichtigt werden, da in Modula-2  nur  global  auf  Ebene  0
vereinbarte Prozeduren als Wert von Prozedurvariablen zulaessig sind.
  Der folgende Datenfluszalgorithmus berechnet die Mengen Param(p), die  ange-
ben,  um  welche  Parameter die Parameterlisten der lokalen Prozeduren bei der
Abbildung nach C erweitert werden muessen:

    BEGIN
      LocalProc := { p | p ist eine auf Ebene k _ 1 vereinbarte Prozedur }
      GlobalVar := { v | v ist eine auf Ebene 0 vereinbarte Variable }






                               24











      FORALL p  LocalProc DO
        Local(p) := { v | v ist eine lokale Variable von p }
        Call(p)  := { q | q  LocalProc  p ruft q auf }
        Use(p)   := { v | v wird in p benutzt  v / Local(p)  v / GlobalVar }
        Param(p) := Use(p)
      END
      REPEAT
        Changed := FALSE
        FORALL p  LocalProc DO
          Old := Param(p)
          Param(p) U:= U Param(q) \ Local(p)
                     q  Call(p)
          Changed := Changed OR (Param(p) / Old)
        END
      UNTIL NOT Changed
    END

  Die REPEAT-Schleife im obigen Algorithmus ist notwendig,  weil  der  Aufruf-
graph  der  lokalen  Prozeduren  moeglicherweise aufgrund von Rekursion Zyklen
enthaelt. Die Effizienz des Algorithmus ist stark abhaengig  von  der  Reihen-
folge,  in der die Prozeduren der Menge LocalProc bearbeitet werden. Nach Moe-
glichkeit sollte jede Prozedur erst bearbeitet werden, wenn  alle  ihre  Nach-
folger  im  Aufrufgraph  bereits  bearbeitet  wurden. Enthaelt der Aufrufgraph
keine Zyklen, dann sind bei  dieser  Bearbeitungsreihenfolge  hoechstens  zwei
Iterationen  notwendig.   Mit  diesem Algorithmus wird das obige Beispiel in C
zu:

    typedef CARDINAL tCard;
    static void q(i)
    tCard *i;
    {
        *i = 1;
    }
    static void r(i, j)
    tCard *i, *j;
    {
        *j = 1;
        q(i);
    }
    void p()
    {
        tCard i, j;
        r(&i, &j);
    }

  Die zweite Alternative einer Funktion Q, den Zugriff auf lokal in P  verein-
barte  Variablen  zu ermoeglichen ist, fuer jede dieser Variablen eine globale
Zeigervariable zu vereinbaren. Am Anfang der Funktion P  werden  die  Adressen
dieser  lokalen  Variablen  an  die globalen Zeigervariablen zugewiesen. Damit
dies auch funktioniert, wenn die Funktion P rekursiv aufgerufen  wird,  werden

                               25











die  urspruenglichen  Werte  der  globalen  Zeigervariablen am Anfang von P in
lokalen Zeigervariablen gesichert und am Ende von P wieder zurueckgeschrieben.
Die  Funktion  Q kann jetzt ueber die globalen Zeigervariablen auf die lokalen
Variablen von P zugreifen. Damit wird das obige Beispiel in C zu:

    typedef CARDINAL tCard;
    static tCard *G_1_i;
    static tCard *G_2_j;
    static void q()
    {
        *G_1_i = 1;
    }
    static void r()
    {
        *G_2_j = 1;
        q();
    }
    void p()
    {
        tCard i, j;
        tCard *L_1, *L_2;
        L_1 = G_1_i; G_1_i = &i;
        L_2 = G_2_j; G_2_j = &j;
        r();
        G_1_i = L_1;
        G_2_j = L_2;
    }

  Eine moegliche Optimierung waere, zu bestimmen, ob die Funktion  P  rekursiv
aufgerufen  wird  und nur in diesem Fall den Wert der globalen Zeigervariablen
lokal in P zu sichern.
  Beide oben vorgestellten Varianten funktionieren in Modula-2 auch im  Zusam-
menhang  mit  Prozedurvariablen, da in Modula-2 als Wert von Prozedurvariablen
nur global auf Ebene 0 vereinbarte Prozeduren zulaessig sind. Damit  entfaellt
die  z.B.  in  Pascal  vorhandene  Schwierigkeit,  beim  Aufruf  einer lokalen
Prozedur die bei der Zuweisung an die Prozedurvariable  gueltige  Umgebung  zu
bestimmen.
  Ein Vergleich der beiden oben vorgestellten Alternativen ergibt folgendes:
-
    Bei der Uebersetzung nach C ist der Aufwand fuer  die  erste  Alternative,
    wegen  der  Notwendigkeit die Aufrufabhaengigkeiten der lokalen Prozeduren
    zu analysieren, erheblich hoeher als der Aufwand fuer die zweite  Alterna-
    tive.
-
    Wird innerhalb einer Prozedur P  eine  lokale  Prozedur  Q  mehrfach  auf-
    gerufen, muessen die Adressen der lokalen Variablen von P bei jedem Aufruf
    von Q als Parameter uebergeben werden. Auszerdem haben die Parameter  man-
    chmal  nur  die Funktion die Adressen der Variablen entlang des Aufrufgra-
    phen weiterzureichen. Im Gegensatz dazu werden die  Adressen  der  lokalen
    Variablen  nur  einmal  an die globalen Zeigervariablen zugewiesen, jedoch
    verursacht die lokale Sicherung der  Werte  der  globalen  Zeigervariablen
    zusaetzlichen Aufwand.


                               26











-
    Der Speicheraufwand fuer beide Alternativen ist in der Regel sehr gering.
  Da der Berechnungsaufwand fuer die erste Alternative  bei  der  Uebersetzung
verhaeltnismaeszig  hoch  ist  und  der  Aufwand  zur Laufzeit bei der zweiten
Alternative in den meisten Faellen geringer ist, wurde die zweite  Alternative
fuer den Uebersetzer ausgewaehlt.
  Ein besonderes Problem entsteht, wenn in der Deklaration einer lokalen Vari-
ablen  ein  anonymer  strukturierter  Typ verwendet wird. Uebersetzt man diese
Variablendeklaration wie in Kapitel 4.4.3 beschrieben nach  C,  dann  ist  der
fuer den strukturierten Typ erzeugte Strukturnamen nur lokal in der betreffen-
den Funktion sichtbar und kann daher nicht in der Deklaration  einer  globalen
Zeigervariablen  verwendet werden.  Aus diesem Grund wird bei der Uebersetzung
nach C fuer solche anonymen strukturierten Typen zunaechst eine globale Struk-
turdeklaration erzeugt, die den Typ beschreibt. Der zu dieser Strukturdeklara-
tion dazugehoerige Strukturnamen kann dann in  der  Deklaration  der  globalen
Zeigervariablen  benutzt werden. Damit wird folgender Ausschnitt eines Modula-
Programms

    PROCEDURE p;
      VAR a : ARRAY [0..127] OF CHAR;
      PROCEDURE q;
      BEGIN
        (* Zugriff auf a *)
      END q;
      ...

in C zu

    struct S_9 {
        CHAR A [127 + 1];
    };
      ...
    struct S_9 *G_3_a;
      ...
    void p()
    {
        struct S_9 a;
        struct S_9 *L_3;
      ...



4.4.4.1
         Formale Parameter

  Bei der Abbildung der formalen Parameter muessen drei  Faelle  unterschieden
werden:  offene  Felder,  Wertparameter  und  Referenzparameter.   Die offenen
Felder muessen bei der Abbildung getrennt behandelt werden,  da  C  kein  ver-
gleichbares  Konzept  kennt  und  daher, insbesondere wenn das offene Feld als
Wertparameter uebergeben wird, in C eine Simulation des  gewuenschten  Effekts
notwendig wird. Die Abbildung von ,,normalen'' Parametern macht hingegen wenig
Muehe.





                               27











4.4.4.1.1
           Wert- und Referenzparameter

  In C werden alle Parameter - mit Ausnahme der Vektoren -  als  Wertparameter
uebergeben.  Daher  kann  die  Deklaration  eines Wertparameters, mit der oben
beschriebenen Abbildung der Felder, direkt auf die entsprechende Parameterdek-
laration  in C abgebildet werden.  Hierbei wird allerdings vorausgesetzt, dasz
der C-Uebersetzer in der Lage ist auch beliebige Strukturen als  Wertparameter
zu uebergeben.
  Die semantische Bedeutung eines Referenzparameters in Modula-2 ist, dasz dem
Unterprogramm  die  Adresse  des aktuellen Parameters, der in diesem Fall eine
Variable sein musz, uebergeben wird  und  das  Unterprogramm  dann  ueber  die
Adresse  direkt  auf diese Variable zugreift. Da in C die Adresse jeder Varia-
blen mit dem Operator & bestimmt werden kann, erreicht man  in  C  den  Effekt
eines  Referenzparameters, indem man den formalen Parameter als Zeiger verein-
bart und bei der Parameteruebergabe die Adresse der Variablen an das Unterpro-
gramm  uebergibt.  Innerhalb  des  Unterprogramms  wird  dann  -  genau wie in
Modula-2 - ueber die Adresse  auf  diese  Variable  zugegriffen.  Der  einzige
Unterschied  ist,  dasz in C die Operatoren zur Adreszbestimmung und zur Dere-
ferenzierung explizit aufgeschrieben werden muessen. Semantisch besteht jedoch
kein Unterschied.
  Der folgende Ausschnitt eines Modula-Programms, der die Verwendung von Wert-
und Referenzparametern zeigt,

    VAR  GlobalRestartSet, LocalRestartSet : tTokenSet;
      ...
    PROCEDURE Union (VAR t1: tTokenSet; t2: tTokenSet);
    BEGIN
      t1[0] := t1[0] + t2[0];
      t1[1] := t1[1] + t2[1];
    END Union;
       ...
    Union (GlobalRestartSet, LocalRestartSet);

wird in C zu

    tTokenSet GlobalRestartSet, LocalRestartSet;
      ...
    void Union(t1, t2)
    tTokenSet *t1;
    tTokenSet t2;
    {
        t1->A[0] = t1->A[0] | t2.A[0];
        t1->A[1] = t1->A[1] | t2.A[1];
    }
      ...
    Union(&GlobalRestartSet, LocalRestartSet);



4.4.4.1.2
           Offene Felder

  Offene Felder erfordern in C eine spezielle  Behandlung,  die  aber  dadurch
vereinfacht  wird, dasz in Modula-2 fuer sie nur elementweiser Zugriff und die
Uebergabe als aktueller Parameter an ein Unterprogramm definiert  ist,  dessen
formaler Parameter ebenfalls ein offenes Feld ist.

                               28











  Die Uebergabe der offenen Felder wird in  C  dadurch  realisiert,  dasz  als
aktueller  Parameter  ein Zeiger auf den Feldanfang uebergeben wird.  Da diese
Art der Uebergabe in C allgemein fuer die Uebergabe von Vektoren benutzt wird,
wird  die  Deklaration  eines  offenen Feldes in eine Parameterdeklaration der
Sprache C umgesetzt, die angibt, dasz der Parameter ein  Vektor  ist1.   Dabei
spielt  es  bei  der  Uebergabe  zunaechst  keine Rolle, ob das offene Feld im
Modula-Programm als  Wert-  oder  Referenzparameter  vereinbart  wurde  (siehe
unten).
  Ein zusaetzlicher Parameter enthaelt die aktuelle Anzahl von  Feldelementen.
Dieser  Parameter wird benoetigt, um innerhalb des Unterprogramms fuer ein als
Wertparameter vereinbartes offenes Feld einen  lokalen  Vektor  entsprechender
Groesze  anlegen  zu koennen. Auszerdem ist der Parameter zur Uebersetzung der
Standardfunktionen HIGH und SIZE notwendig, mit denen die  obere  Grenze  bzw.
die Groesze des offenen Feldes bestimmt werden kann.
  Erfolgt aus einer Prozedur Q, die lokal zu einer Prozedur P deklariert  ist,
ein  Zugriff  auf  ein  offenes  Feld a von P, dann musz auch der zusaetzliche
Parameter mit der aktuellen Anzahl von Elementen des Feldes a, genau  wie  die
Adresse  von a (s. Kap. 4.4.4), an eine globale Variable zugewiesen werden, da
auch in Q ein Aufruf HIGH(a) bzw.  SIZE(a)  moeglich  ist  und  Q  somit  auch
Zugriff auf den aktuellen Wert des zusaetzlichen Parameters von P haben musz.
  Beim Zugriff auf ein Element des offenen Feldes, bei der  Bestimmung  seiner
Adresse  und  seiner  Uebergabe  als aktueller Parameter an eine Prozedur musz
entsprechend beruecksichtigt werden, dasz die  Abbildung  der  offenen  Felder
sich von der Abbildung der ,,normalen'' Felder unterscheidet.
  Die Deklaration

    PROCEDURE Sort (VAR a : ARRAY OF CARDINAL);

wird in C abgebildet auf

    void Sort(a, O_1)
    CARDINAL a[]; LONGCARD O_1;

Der erste Parameter a enthaelt den  Zeiger  auf  den  Feldanfang,  der  zweite
Parameter O_1 die aktuelle Anzahl von Feldelementen.
  Die Behandlung der Uebergabe eines offenen  Feldes  als  Wertparameter  wird
zunaechst an einem Beispiel demonstriert:

    PROCEDURE WriteS (s : ARRAY OF CHAR);
    VAR  i : CARDINAL;
    BEGIN
      FOR i := 0 TO HIGH (s) DO WriteC (s[i]); END;
    END WriteS;

Diese Prozedur wird in C zu

____________________
1 Zur Umgehung der damit verbundenen Einschraenkungen werden  die
  ,,normalen''  Felder  auf  Strukturen mit einem Vektor als Kom-
  ponente abgebildet (s. Kap. 4.4.2.5).  Fuer offene Felder  sind
  diese  Einschraenkungen  aber  unproblematisch,  da fuer sie in
  Modula-2 aehnliche Einschraenkungen gelten wie  fuer  die  Vek-
  toren in C.


                               29











    void WriteS(s, O_2)
    CHAR s[]; LONGCARD O_2;
    {
        CARDINAL i;
        OPEN_ARRAY_LOCALS
        ALLOC_OPEN_ARRAYS(O_2 * sizeof(CHAR), 1)
        COPY_OPEN_ARRAY(s, O_2, CHAR)
        {
            CARDINAL B_1 = 0, B_2 = (O_2 - 1);
            if (B_1 <= B_2)
              for (i = B_1;; i += 1) {
                  WriteC(s[i]);
                  if (i >= B_2) break;
              }
        }
        FREE_OPEN_ARRAYS
    }

  Der zweite Parameter von WriteS O_2 enthaelt wieder die aktuelle Anzahl  von
Feldelementen.  Der  erste  Parameter s enthaelt beim Prozeduraufruf zunaechst
die    Anfangsadresse    des    uebergebenen    Feldes.     OPEN_ARRAY_LOCALS,
ALLOC_OPEN_ARRAYS,  COPY_OPEN_ARRAY  und  FREE_OPEN_ARRAYS  sind  in SYSTEM_.h
definierte  Makros.   OPEN_ARRAY_LOCALS  ist  die   Definition   von   lokalen
Hilfsvariablen,  die in den uebrigen Makros benoetigt werden.  Die Aufgabe von
ALLOC_OPEN_ARRAYS ist, einen Speicherblock ausreichender Groesze fuer das  als
Wertparameter   uebergebene  Feld  zu  beschaffen.   COPY_OPEN_ARRAY  bestimmt
zunaechst die Anfangsadresse eines lokalen Vektors geeigneter Groesze und Aus-
richtung  im  von  ALLOC_OPEN_ARRAYS  beschafften  Speicherblock,  kopiert das
uebergebene Feld in diesen lokalen Vektor und weist schlieszlich die Anfangsa-
dresse  des  lokalen Vektors an den Parameter s zu.  FREE_OPEN_ARRAYS gibt den
Speicherplatz fuer den von ALLOC_OPEN_ARRAYS beschafften Speicherblock  wieder
frei.   FREE_OPEN_ARRAYS  musz  am  Ende  des  Unterprogramms  sowie vor jeder
RETURN-Anweisung innerhalb des Unterprogramms stehen.  Die  genaue  Definition
dieser   Makros   haengt   von   den   auf   der   Zielmaschine   verfuegbaren
Bibliotheksfunktionen ab. Eine Moeglichkeit waere folgende:

    #define SYSTEM_ALIGN            8
    #define SYSTEM_MASK             (~(SYSTEM_ALIGN - 1))
    #define OPEN_ARRAY_LOCALS       char *BLOCK_POINTER, *FREE_POINTER;
    #define ALLOC_OPEN_ARRAYS(size, arrays) \
        BLOCK_POINTER = FREE_POINTER = \
            malloc((unsigned)((size) + (arrays) * (SYSTEM_ALIGN - 1)));
    #define FREE_OPEN_ARRAYS        free(BLOCK_POINTER);
    #define COPY_OPEN_ARRAY(array, elems, type) \
    { \
        int ARRAY_SIZE = elems * sizeof(type); \
        \
        array = (type *)memcpy(FREE_POINTER, (char *)array, ARRAY_SIZE); \
        FREE_POINTER += (ARRAY_SIZE + (SYSTEM_ALIGN - 1)) & SYSTEM_MASK; \
    }

  Die Konstante SYSTEM_ALIGN ist maschinenabhaengig und sorgt dafuer, dasz die
Anfangsadressen   der   lokalen   Vektoren  korrekt  ausgerichtet  sind.   Die

                               30











Bibliotheksfunktion malloc beschafft Speicherplatz auf der  Halde,  free  gibt
diesen  Speicherplatz  wieder  frei.  Die  Bibliotheksfunktion memcpy(s1,s2,n)
kopiert n Zeichen von s2 nach s1 und liefert den Zeiger s1 als Ergebnis.
  An einigen Maschinen stehen auch Bibliotheksfunktionen zur  Verfuegung,  mit
denen  man  den Speicherplatz erheblich effizienter in der Aufrufschachtel des
Unterprogramms beschaffen kann1.  Bei der Rueckkehr wird dieser  Speicherplatz
dann  automatisch freigegeben. Das Makro FREE_OPEN_ARRAYS waere in diesem Fall
leer.
  Da der zuletzt fuer die Speicherung von offenen Feldern beschaffte Speicher-
block  immer  als  erster wieder freigegeben wird, koennte man die Aufrufe von
malloc und free auch durch Aufrufe  von  selbstprogrammierten  Funktionen  zur
Speicherverwaltung   ersetzen,  die  den  angeforderten  Speicher  kellerartig
verwalten und daher wahrscheinlich effizienter programmiert werden koennen als
malloc  und  free,  die  die  Anforderung  und  Freigabe  von Speicherplatz in
beliebiger Reihenfolge unterstuetzen.


4.4.4.2
         Standardprozeduren und -funktionen

  Dieser Abschnitt enthaelt die Definition der Standardprozeduren  und  -funk-
tionen  in C. Alle diese Definitionen sind in SYSTEM_.h bzw. SYSTEM_.c enthal-
ten.
  Da ABS eine ueberladene Funktion ist, existieren in C  verschiedene  Defini-
tionen  von ABS.  Abhaengig vom Typ und der Art des aktuellen Parameters, wird
in C ein Aufruf der entsprechenden Funktion  bzw.  des  entsprechenden  Makros
eingesetzt. Die verschiedenen Definitionen von ABS haben folgende Form:

    #define ABS(x)          ((x) < 0 ? -(x) : (x))
    #define ABSSC(x)        ((SHORTCARD) (x))
    #define ABSLC(x)        ((LONGCARD) (x))
    #define ABSSI(x)        ((SHORTINT) ABSLI((LONGINT) (x)))
    #define ABSR(x)         ((REAL) ABSLR(x))
    extern LONGINT ABSLI();
    extern LONGREAL ABSLR();
    LONGINT ABSLI(x)
    register LONGINT x;
    {
        return (x < 0 ? -x : x);
    }
    LONGREAL ABSLR(x)
    register LONGREAL x;
    {
        return (x < 0 ? -x : x);
    }

  Das Makro ABS, das nur benutzt wird, wenn der  Parameter  x  ein  konstanter
Ausdruck  ist,  kann  nicht  in  allen  Faellen verwendet werden, da x moegli-
cherweise ein Funktionsaufruf mit Seiteneffekten ist und in  diesem  Fall  die
doppelte Auswertung von x zu Fehlern fuehren wuerde.
____________________
1 An der SUN z.B. existiert eine solche  Bibliotheksfunktion  mit
  dem Namen alloca.


                               31











  Die Funktion CAP ist definiert als:

    extern CHAR CAP();
    CHAR CAP(ch)
    register CHAR ch;
    {
        return (ch >= 'a' && ch <= 'z' ? ch - 'a' + 'A' : ch);
    }

CAP ist nicht als Makro definiert, um eine  mehrfache  Auswertung  von  ch  zu
verhindern.
  Die Funktionen fuer Typumwandlungen CHR, FLOAT, ORD, TRUNC und VAL sind  wie
folgt definiert:

    #define CHR(x)          ((CHAR) (x))
    #define FLOAT(x)        ((REAL) (x))
    #define ORD(x)          ((CARDINAL) (x))
    #define TRUNC(x)        ((CARDINAL) (x))
    #define VAL(T,x)        ((T) (x))

  Die Umwandlung von Gleitkommawerten in ganzzahlige  Werte  ist  in  C  nicht
exakt  definiert.  In  der Regel wird aber mit der obigen Definition von TRUNC
der gewuenschte Effekt erzielt. Es ist jedoch  nicht  voellig  ausgeschlossen,
dasz in manchen Implementierungen gerundet wird.
  Die Standardfunktion SIZE, zur Bestimmung der Anzahl der von einer Variablen
oder  einem  Typ  benoetigten Speichereinheiten, wird normalerweise direkt auf
den C-Operator sizeof abgebildet.  Ist der aktuelle Parameter von SIZE  jedoch
ein  offenes  Feld, dann ergibt sich die von diesem Feld benoetigte Anzahl von
Speichereinheiten aus: sizeof(Elementtyp) * aktueller Anzahl  von  Feldelemen-
ten.
  Die Behandlung der Funktionen MAX und MIN haengt von der Art des an sie  als
Argument  uebergebenen  Typs  ab.  Fuer  einen Aufzaehlungs- oder einen Unter-
bereichstyp T ist der Wert von  MIN(T)  bzw.   MAX(T)  aus  der  Typdefinition
bekannt  und  wird  daher textuell in das erzeugte C-Programm eingesetzt. Fuer
die vordefinierten Standardtypen, auf die  diese  Funktionen  anwendbar  sind,
sind in SYSTEM_.h Definitionen von symbolischen Konstanten der Form

    #define MIN_CARDINAL    ...
    #define MAX_CARDINAL    ...
    #define MIN_BOOLEAN     FALSE
    #define MAX_BOOLEAN     TRUE
      ...

enthalten. Diese symbolischen Konstanten werden im C-Programm fuer die Aufrufe
von MIN bzw. MAX eingesetzt.
  Ist der aktuelle Parameter der Funktion HIGH kein offenes Feld, dann ist der
Wert  von  HIGH(a) bei der Uebersetzung bekannt und wird in das C-Programm als
Konstante eingesetzt. Ist der aktuelle Parameter jedoch ein offenes Feld, dann
wird  HIGH(a)  im C-Programm zum Ausdruck (O_nnn - 1). Der Parameter O_nnn der
Funktion, die a als formalen Parameter hat, gibt - wie  oben  erwaehnt  -  die
aktuelle Anzahl der Feldelemente des offenen Feldes an.




                               32











  Die Standarfunktion ODD ist folgendermaszen definiert:

    #define ODD(x)          ((BOOLEAN)((x) & 01))

  Die Standardprozeduren DEC, INC, EXCL und INCL haben folgende Definition:

    #define DEC(x)          (x)--
    #define DEC1(x,n)       x -= n
    #define INC(x)          (x)++
    #define INC1(x,n)       x += n
    #define EXCL(s,i)       s &= ~(0X1L << (i))
    #define INCL(s,i)       s |= 0X1L << (i)

  Ein Aufruf  der  Standardprozedur  HALT  wird  in  C  zu  einem  Aufruf  der
Bibliotheksfunktion  exit. Da HALT in der Regel in Fehlerfaellen benutzt wird,
wird exit, entsprechend der in C ueblichen Konvention, mit dem Argument 1 auf-
gerufen, um der Umgebung den Fehler anzuzeigen.
  Modula-2  definiert,  dasz  Aufrufe  NEW(p)  bzw.   DISPOSE(p)   der   Stan-
dardprozeduren    NEW    bzw.    DISPOSE    ersetzt   werden   durch   Aufrufe
ALLOCATE(p, TSIZE(T))  bzw.   DEALLOCATE(p, TSIZE(T)),   wobei   p   vom   Typ
POINTER TO T  sein  musz  und ALLOCATE bzw. DEALLOCATE vom Benutzer definierte
und an der Aufrufstelle sichtbare Prozeduren  mit  folgender  Definition  sein
muessen:

    PROCEDURE ALLOCATE      (VAR a: ADDRESS; size: CARDINAL);
    PROCEDURE DEALLOCATE    (VAR a: ADDRESS; size: CARDINAL);

Daher wird folgendes Modula-Programmfragment

    FROM Storage    IMPORT ALLOCATE, DEALLOCATE;
      ...
    VAR p: POINTER TO INTEGER;
      ...
    NEW (p); p^ := 1; DISPOSE (p);

in C zu

      ...
    INTEGER *p;
      ...
    Storage_ALLOCATE(&p, sizeof(INTEGER));
    *p = 1;
    Storage_DEALLOCATE(&p, sizeof(INTEGER));



4.4.5
       Lokale Moduln

  C kennt kein den lokalen  Moduln  entsprechendes  Konzept.  Daher  musz  ein
Modula-Programm,  das lokale Moduln enthaelt derart transformiert werden, dasz
keine lokalen Moduln mehr vorhanden sind. Dies wird mit folgender  Transforma-
tion erreicht:
-
    Alle Objekte, die in  einem  lokalen  Modul  deklariert  sind,  werden  zu
    lokalen  Objekten  der  Prozedur bzw. Uebersetzungseinheit, die das lokale
    Modul in ihrem Deklarationsteil enthaelt.

                               33











-
    Der Rumpf des lokalen Moduls wird zu einer parameterlosen Prozedur.  Diese
    Prozedur  wird  am  Anfang des Anweisungsteils der Prozedur oder Ueberset-
    zungseinheit aufgerufen, die den lokalen Modul in  ihrem  Deklarationsteil
    enthaelt.  Sind  mehrere  lokale  Moduln  vorhanden,  dann  erfolgen diese
    Aufrufe entsprechend der Reihenfolge der lokalen Moduln im Quelltext. Dies
    entspricht  der  in  der Sprachdefinition von Modula-2 geforderten Reihen-
    folge.
-
    Da lokale Moduln mit Hilfe von Import- bzw. Exportanweisungen eine expliz-
    ite  Kontrolle  der  Sichtbarkeit  von  Bezeichnern  erlauben, koennen bei
    dieser Transformation  moeglicherweise  Namenskonflikte  entstehen.  Diese
    werden in C durch eine Umbenennung von Bezeichnern geloest.
  Diese Transformation musz durchgefuehrt werden, bevor  die  Reihenfolge  der
Deklarationen  umgeordnet  wird  und bevor geschachtelte Prozedurdeklarationen
transformiert werden.
  Die Uebersetzung des  Moduls  Global  nach  C  soll  die  oben  beschriebene
Transformation nochmals verdeutlichen:

    MODULE Global;
    VAR  a : INTEGER;
    MODULE Local;
    EXPORT QUALIFIED a;
    VAR
      a : INTEGER;
    BEGIN
      a := 1;
    END Local;
    BEGIN
      a := Local.a;
    END Global.

In C wird Global zu:

    #include "SYSTEM_.h"
    static INTEGER a;
    static INTEGER C_1_a;
    static void Local()
    {
        C_1_a = 1;
    }
    void Global()
    {
        Local();
        a = C_1_a;
    }



4.5
     Ausdruecke

  Bei der Uebersetzung von Ausdruecken musz darauf geachtet werden,  dasz  die
Auswertungsreihenfolge  im  erzeugten C-Programm der Auswertungsreihenfolge im
Modula-Programm entspricht. Dabei ist insbesondere von  Bedeutung,  dasz  sich

                               34











der Vorrang der Operatoren in Modula-2 und C teilweise deutlich unterscheidet.
Eine korrekte Auswertungsreihenfolge musz daher bei Bedarf  durch  das  Setzen
von Klammern erzwungen werden.


4.5.1
       Operanden

  Die Abbildung von Zeichenketten und Zahlen  wurde  bereits  in  Kapitel  4.2
besprochen.
  Mengen werden in einen  C-Ausdruck  umgesetzt,  der  die  gewuenschte  Menge
liefert1. Die folgende Menge

    {1..2, i..j, j + 2}

wird in C zu

    SET_cRNG(1, 2) | SET_RANGE(i, j) | SET_ELEM(j + 2)

SET_ELEM, SET_cRNG und SET_RANGE sind in SYSTEM_.h bzw.  SYSTEM_.c  folgender-
maszen definiert:

    #define SYSTEM_MaxSet   (sizeof(unsigned long) * 8 - 1)
    #define SET_ELEM(el)    (0X1L << (el))
    #define SET_cRNG(lo,hi) \
        ((lo) <= (hi) ? ~0XL >> (lo) << (lo) + SYSTEM_MaxSet - (hi) \
         >> SYSTEM_MaxSet - (hi) : 0XL)
    #define SET_RANGE(lo, hi) \
        SET_RANGE1((CARDINAL)(lo), (CARDINAL)(hi))
    extern unsigned long SET_RANGE1();
    unsigned long SET_RANGE1(lo, hi)
    register CARDINAL lo, hi;
    {
        return (lo <= hi ? ~0XL >> lo << lo + SYSTEM_MaxSet - hi
                >> SYSTEM_MaxSet - hi : 0XL);
    }

Die Funktion SET_RANGE1 wird fuer nicht konstante Elemente verwendet, um  eine
mehrfache Auswertung von lo und hi zu verhindern.
  Alle von globalen Moduln exportierten Bezeichner werden im C-Programm in der
qualifizierten  Form  Modulname_Bezeichner  geschrieben.   Nicht  von globalen
Moduln exportierte Bezeichner werden unveraendert  nach  C  uebernommen,  sind
aber bei Bedarf zur Loesung eines Namenskonfliktes mit einem Praefix versehen.
  Die Selektion einer Verbundkomponente

    R.f

wird in C zu

    R.f

____________________
1 So definierte Mengenkonstanten und  konstante  Elemente  werden
  vom C-Uebersetzer bereits bei der Uebersetzung ausgewertet.


                               35











wenn die Komponente nicht in einem varianten Teil des Verbundes enthalten ist.
Ist die Komponente in einem varianten Teil enthalten, so erfolgt die Selektion
entsprechend der oben vorgestellten Abbildung von varianten Verbunden mit:

    R.U_xxx.V_nnn.f

  Der Zugriff auf ein Feldelement

    A[E]

wird entsprechend der oben beschriebenen Abbildung von Feldern in C zu

    A.A[E - Lwb]

wenn A kein offenes Feld ist.  Da in C  alle  Vektoren  die  untere  Grenze  0
besitzen,  musz  beim  Zugriff  auf ein Feldelement die in Modula-2 angegebene
untere Grenze Lwb des Feldes abgezogen werden, sofern diese  ungleich  0  ist.
Ist  A  ein  offenes  Feld,  so erfolgt der Zugriff entsprechend der oben vor-
gestellten Abbildung von offenen Feldern auf Vektoren mit:

    A[E]

  Die Dereferenzierung von Zeigervariablen

    P^

wird in C zu

    *P

Eine  Dereferenzierung  ist,  wegen  der  oben  beschriebenen  Abbildung   von
Referenzparametern  auf  Zeiger,  auch notwendig, wenn P ein Referenzparameter
ist.
  Der Funktionsaufruf

    F()

wird in C zu

    F()

wenn F keine Prozedurvariable ist. Ist F eine  Prozedurvariable,  so  ist,  da
Prozedurtypen  in  C  als  Zeiger  auf  Funktionen repraesentiert werden, eine
zusaetzliche Dereferenzierung notwendig:

    (*F)()

Die Klammerung von *F ist notwendig, weil in C der Vorrang von () groeszer ist
als der Vorrang von *.
  Eine Dereferenzierung gefolgt von der Selektion einer Verbundkomponente wird
auf  den  in  C  speziell  fuer diese Operationsfolge vorgesehenen Operator ->
abgebildet.




                               36











4.5.2
       Operatoren

  Die arithmetischen Operatoren werden entsprechend der folgenden Tabelle nach
C abgebildet:

                            _____________________
                             Modula-2      C
                            _____________________
                                +          +
                                -          -
                                *          *
                                /          /
                               DIV         /
                               MOD         %
                            _____________________
                           






                                     






                                                







             Tabelle 4.2: Abbildung der arithmetischen Operatoren
  Im Gegensatz zu Modula-2 ist allerdings in  der  C-Sprachbeschreibung  nicht
eindeutig  definiert,  welches  Ergebnis die Operatoren / und % liefern, falls
einer der Operanden eine negative Zahl ist.  Bei  der  Abbildung  werden  aber
solche moeglichen Unterschiede in der Arithmetik nicht beruecksichtigt.
  Da sowohl Modula-2 als auch C die Kurzauswertung logischer  Ausdruecke  ver-
langen,  koennen  die  logischen  Operatoren NOT, AND und OR direkt auf die C-
Operatoren !, && und || abgebildet werden.
  Mit der vereinfachenden Annahme, dasz alle Mengen nur Wortgroesze  (unsigned
long) haben, koennen die Mengenoperatoren in C leicht mit Hilfe der Operatoren
zur Bitmanipulation realisiert werden. Die folgende Tabelle zeigt  die  Ueber-
setzung der Mengenoperatoren:

                      _________________________________
                          Modula-2            C
                      _________________________________
                             +                |
                             -             SET_DIFF
                             *                &
                             /                ^
                             =                ==
                             #                !=
                             <=         SET_IS_SUBSET1
                             >=         SET_IS_SUBSET2
                             IN               IN
                      _________________________________
                     









                                     









                                                      










                 Tabelle 4.3: Abbildung der Mengenoperatoren

Die Makros SET_DIFF, IN, SET_IS_SUBSET1 und SET_IS_SUBSET2 sind  in  SYSTEM_.h
wie folgt definiert:

    #define SET_DIFF(s1,s2)         ((s1) & ~(s2))
    #define IN(x,s)                 ((BOOLEAN)((s) >> (x) & 0X1L))
    #define SET_IS_SUBSET1(s1,s2)   ((BOOLEAN)!((s1) & ~(s2)))
    #define SET_IS_SUBSET2(s1,s2)   ((BOOLEAN)!((s2) & ~(s1)))

  Aufgrund der oben angegebenen Abbildung der Modula-Typen nach C, koennen die
relationalen  Operatoren von Modula-2 immer direkt auf die relationalen Opera-
toren von C abgebildet werden.

                               37











  Die folgenden Ausdruecke (s. Beispiele Kap. 4.4.3)

    i DIV 3
    NOT p OR q
    (i + j) * (i - j)
    s - {8, 9, 13}
    (1 <= i) AND (i < 100)
    t^.Key = 0
    {13..15} <= s
    i IN {0, 5..8, 15}

werden in C zu

    i / 3
    !p || q
    (i + j) * (i - j)
    SET_DIFF(s, SET_ELEM(8) | SET_ELEM(9) | SET_ELEM(13))
    1 <= i && i < 100
    t->Key == 0
    SET_IS_SUBSET1(SET_cRNG(13, 15), s)
    IN(i, SET_ELEM(0) | SET_cRNG (5, 8) | SET_ELEM(15))



4.6
     Anweisungen

4.6.1
       Zuweisung

  Aufgrund der Abbildung der Typen nach C kann -  mit  einer  Ausnahme  -  die
Zuweisung direkt auf den C-Zuweisungsoperator = abgebildet werden. Die einzige
Ausnahme ist die Zuweisung von Zeichenketten, die mit der  Bibliotheksfunktion
strncpy durchgefuehrt wird. Die Funktion strncpy(s,t,n) kopiert eine Zeichenk-
ette, die - wie in C ueblich - durch ein NUL-Zeichen beendet wird von  t  nach
s.  Es werden jedoch maximal die als drittes Argument n uebergebene Anzahl von
Zeichen kopiert. Damit kann gerade die in  Modula-2  fuer  die  Zuweisung  von
Zeichenketten  geltende  Regel  ,,Zeichenketten  der Laenge n1 koennen auch an
Felder von  Zeichen  der  Laenge  n2 > n1  zugewiesen  werden.  Der  Wert  der
Zeichenkette  wird  in diesem Fall um ein NUL-Zeichen verlaengert.'' implemen-
tiert werden. Die folgenden Zuweisungen (s. Beispiele Kap. 4.4.3)

    w := v;
    F := log2;
    s := {2, 3, 5..7, 11};
    t^.Key := j;
    w[i+1].ch := "a";
    S := "hello world";

werden somit in C zu

    w = v;
    F = log2;
    s = SET_ELEM(2) | SET_ELEM(3) | SET_cRNG(5, 7) | SET_ELEM(11);
    t->Key = j;
    w.A[i+1].ch = 'a';
    (void)strncpy(S.A, "hello world", sizeof(S.A));


                               38











  Es sei an dieser Stelle noch einmal ausdruecklich darauf  hingewiesen,  dasz
auch das Feld v, wegen der Abbildung von Feldern auf Strukturen mit einem Vek-
tor als Komponente, an das Feld w als  Ganzes  zugewiesen  werden  kann.   Wie
bereits  erwaehnt, wird dabei allerdings vorausgesetzt, dasz der C-Uebersetzer
Strukturen als Ganzes zuweisen kann.
  Der Name einer Funktion wird in C, wenn er nicht  zum  Aufruf  der  Funktion
verwendet wird, als Zeiger auf die Funktion verstanden.


4.6.2
       Prozeduraufruf

  Der Aufruf einer Prozedur wird in einen Aufruf der entsprechenden C-Funktion
uebersetzt. Handelt es sich beim Bezeichner der Prozedur um eine Prozedurvari-
able, dann ist, wegen der Abbildung der Prozedurtypen  auf  Zeiger  auf  Funk-
tionen, eine Dereferenzierung beim Aufruf notwendig.
  Die Abbildung der aktuellen Parameter ist abhaengig von der Art der formalen
Parameter:
  Ist der formale Parameter ein Wertparameter (kein offenes Feld),  dann  wird
der aktuelle Parameter in den entsprechenden C-Ausdruck uebersetzt. Die Ueber-
gabe von Zeichenketten macht dabei aber aus zwei Gruenden Schwierigkeiten:
-
    Zeichenketten werden in C auf  Zeichenketten  oder  einen  initialisierten
    Vektor von Zeichen abgebildet. Felder von Zeichen werden auf eine Struktur
    mit einem Vektor von Zeichen  als  Komponente  abgebildet.   Zeichenketten
    bzw. Vektoren werden in C aber im Gegensatz zu Strukturen nicht als Ganzes
    an eine Funktion uebergeben, sondern es wird nur ein Zeiger auf den Anfang
    der Zeichenkette bzw. des Vektors uebergeben.
-
    Bei  der  Parameteruebergabe  gelten  die  gleichen  Regeln  wie  bei  der
    Zuweisung.  Das  bedeutet,  dasz  die Laenge der Zeichenkette kleiner sein
    darf, als die Laenge des als formaler Parameter angegebenen Feldes.
  Diese beiden Probleme koennen geloest werden, indem die Zeichenkette vor dem
Aufruf  der Funktion an eine temporaere Feldvariable zugewiesen und dann diese
Feldvariable als aktueller Parameter uebergeben wird.  Die Loesung ist allerd-
ings  wegen der zusaetzlichen Zuweisung nicht besonders effizient.  Der Aufruf
der Prozedur WriteString aus dem folgenden Ausschnitt eines Modula-Programms

    PROCEDURE WriteString (s : tString);
      ...
    WriteString ("hello world");

wird in C dann zu

    tString X_1;
      ...
    (void)strncpy(X_1.A, "hello world", sizeof(X_1.A));
      ...
    WriteString(X_1);

  Ist der formale Parameter ein Referenzparameter (kein  offenes  Feld),  dann
musz  der aktuelle Parameter eine Variable sein. Da Referenzparameter in C auf
Zeiger abgebildet werden, musz die Adresse  dieser  Variablen  in  C  bei  der
Parameteruebergabe mit dem Operator & bestimmt und uebergeben werden.
  Ist der formale Parameter ein offenes Feld, dann musz in C die  Adresse  des
aktuellen  Parameters  uebergeben  werden.  Dies  gilt auch dann, wenn das als

                               39











formaler Parameter angegebene offene Feld ein  Wertparameter  ist  (vgl.  Kap.
4.4.4.1.2).   Dabei  muessen,  entsprechend  der Art des aktuellen Parameters,
folgende Faelle unterschieden werden:
-
    Wenn der aktuelle Parameter eine Zeichenkette ist, dann wird in C  automa-
    tisch ein Zeiger auf das erste Zeichen dieser Zeichenkette uebergeben.
-
    Ist der aktuelle Parameter ein offenes Feld, dann  wird  in  C  wegen  der
    Abbildung  der  offenen Felder auf Vektoren automatisch ein Zeiger auf den
    Feldanfang uebergeben.
-
    Falls der aktuelle Parameter in C weder eine Zeichenkette noch ein  Vektor
    ist,  dann  musz  die Adresse des aktuellen Parameters wie ueblich mit dem
    Operator & bestimmt werden.
  Zusaetzlich zur Adresse des Feldes musz in C ein Parameter  mit  der  Anzahl
von  Feldelementen  uebergeben  werden. Falls der aktuelle Parameter ebenfalls
ein offenes Feld ist, wird der zu diesem Feld dazugehoerige Parameter mit  der
Anzahl  von  Feldelementen  uebergeben. Sonst ist die Anzahl von Feldelementen
bei der  Uebersetzung  bekannt  und  wird  als  Konstante  in  das  C-Programm
eingesetzt.
  MOCKA erlaubt - im Gegensatz zur  Sprachbeschreibung  von  Modula-2  -  auch
Zeichenketten als aktuelle Parameter, wenn das offene Feld ein Referenzparame-
ter ist. Mit der oben beschriebenen Abbildung wird auch dieser Fall abgedeckt.
  Die Uebersetzung des folgenden Ausschnitts eines Modula-Programms demonstri-
ert  die Uebergabe von offenen Feldern als Parameter noch einmal (s. Beispiele
Kap. 4.4.3):

    PROCEDURE p (VAR s1: ARRAY OF CHAR; s2: ARRAY OF CHAR);
    BEGIN
      q (s1, s2);
    END p;
      ...
    p (S, "hello world");

Dieser Ausschnitt wird in C zu

    void p(s1, O_3, s2, O_4)
    CHAR s1[]; LONGCARD O_3;
    CHAR s2[]; LONGCARD O_4;
    {
        OPEN_ARRAY_LOCALS
        ALLOC_OPEN_ARRAYS(O_4 * sizeof(CHAR), 1);
        COPY_OPEN_ARRAY(s2, O_4, CHAR);
        q(s1, O_3, s2, O_4);
        FREE_OPEN_ARRAYS
    }
      ...
    p(S.A, 256L, "hello world", 11L);



4.6.3
       IF-Anweisung

  Die if-Anweisung in C entspricht genau der IF-Anweisung  in  Modula-2,  wenn
man   bedenkt,   dasz   der  ELSIF-Teil  von  Modula-2  nur  eine  abkuerzende
Schreibweise fuer Ketten von Bedingungen ist.  Damit wird

                               40












    IF (ch >= "A") AND (ch <= "Z") THEN
      ReadIdentifier;
    ELSIF (ch >= "0") AND (ch <= "9") THEN
      ReadNumber;
    ELSE
      SpecialCharacter;
    END

in C zu

    if (ch >= 'A' && ch <= 'Z') {
        ReadIdentifier();
    } else if (ch >= '0' && ch <= '9') {
        ReadNumber();
    } else {
        SpecialCharacter();
    }



4.6.4
       CASE-Anweisung

  Die  CASE-Anweisung  wird  in  eine  switch-Anweisung  uebersetzt.  Alle  in
Modula-2   fuer   die   Fallmarken   zulaessigen  Typen  sind,  mit  der  oben
beschriebenen Abbildung der Typen nach C, auch in C fuer  den  switch-Ausdruck
und  die  Fallmarken  zulaessig. Die Listen mit Fallmarken und Bereichsangaben
werden in eine Folge von C-Fallmarken der Form case constant : umgesetzt. Kon-
stante  Ausdruecke,  die  in  Modula-2  als Fallmarken zulaessig sind, muessen
dabei bereits waehrend der Uebersetzung nach C ausgewertet  werden,  wenn  der
entsprechende  C-Ausdruck kein konstanter Ausdruck ist.  Die default-Marke der
switch-Anweisung entspricht dem ELSE-Teil der CASE-Anweisung.
  Die Anweisung

    CASE ch OF
    | "A".."Z" : ReadIdentifier;
    | "0".."9" : ReadNumber;
    ELSE
      SpecialCharacter;
    END

wird in C zu

    switch (ch) {
    case 'A' :
    case 'B' :
      ...
    case 'Z' :
        ReadIdentifier();
        break;
    case '0' :
      ...
    case '9' :
        ReadNumber();
        break;

                               41











    default :
        SpecialCharacter();
        break;
    }

  In C musz nach jeder Anweisungsfolge, die  zu  einer  Folge  von  Fallmarken
gehoert,  eine  break-Anweisung  stehen,  damit die switch-Anweisung verlassen
wird.


4.6.5
       Schleifen

  Die WHILE-, REPEAT- und LOOP-Schleife werden folgendermaszen nach  C  ueber-
setzt:

    while (...) {          do {                      for (;;) {
      ...                    ...                       ...
    }                      } while (!(...))          } EXIT_xxx:;

  Die Marke EXIT_xxx dient als Sprungziel fuer die goto-Anweisungen, in welche
die EXIT-Anweisungen innerhalb der LOOP-Schleife uebersetzt werden.
  Eine direkte Uebersetzung der FOR-Schleife

    FOR v := a TO b BY c DO ... END;

in die for-Schleife der Sprache C

    for (v = a; v <= b; v += c) { ... };    /* falls c >= 0 */
    for (v = a; v >= b; v += c) { ... };    /* falls c <  0 */

ist wegen der unterschiedlichen Semantik der beiden Schleifenkonstrukte in den
meisten  Faellen  nicht moeglich. Modula-2 verlangt, dasz Anfangs- und Endwert
der Schleife genau einmal vor dem ersten Schleifendurchlauf  ausgewertet  wer-
den.  Die  Schrittweite  c  musz  ein  konstanter Ausdruck sein. In C wird der
zweite Ausdruck der for-Schleife vor jedem Schleifendurchlauf ausgewertet. Ist
auszerdem  der  Typ  T der Schleifenkontrollvariablen v ein arithmetischer Typ
und gilt fuer den Endwert  der  Schleife  b,  dasz  b _ MAX(T) - c + 1  (falls
c > 0) bzw.  b _ MIN(T) - c - 1 (falls c < 0), dann terminiert die Schleife in
C nicht, da die Schleifenkontrollvariable am Schleifenende  vor  der  erneuten
Auswertung  der Abbruchbedingung inkrementiert wird und ein unbemerkter Ueber-
bzw. Unterlauf stattfindet.
  Daher wird die obige FOR-Schleife bei positiver Schrittweite c in  die  fol-
gende zusammengesetzte C-Anweisung uebersetzt:

    {
        T B_xxx = a, B_nnn = b;
        if (B_xxx <= B_nnn)
          for (v = B_xxx, B_nnn = FOR_LIMIT_UP(B_nnn, c, MIN(T));; v += c) {
              ...
              if (v >= B_nnn) break;
          }
    }

Bei negativer Schrittweite c wird die FOR-Schleife in C zu:


                               42











    {
        T B_xxx = a, B_nnn = b;
        if (B_xxx >= B_nnn)
          for (v = B_xxx, B_nnn = FOR_LIMIT_DOWN(B_nnn, c, MAX(T));; v += c) {
              ...
              if (v <= B_nnn) break;
          }
    }

  Diese  Uebersetzung  der  FOR-Schleife  vermeidet  die  oben  angesprochenen
Schwierigkeiten,  da  Anfangs- und Endwert der Schleife nur einmal ausgewertet
werden und die Abbruchbedingung am  Schleifenende  geprueft  wird,  bevor  die
Schleifenkontrollvariable   inkrementiert  wird.   Durch  den  Aufruf  der  in
SYSTEM_.h  definierten  Makros  FOR_LIMIT_UP  und  FOR_LIMIT_DOWN   wird   der
Schleifenendwert vor der ersten Ausfuehrung des Schleifenrumpfes geeignet kor-
rigiert, um einen Ueber-  bzw.  Unterlauf  der  Schleifenkontrollvariablen  zu
verhindern. Die beiden Makros haben folgende Definition:

    #define FOR_LIMIT_UP(last, step, min) \
        ((last) < (min) + ((step) - 1) ? (min) : (last) - ((step) - 1))
    #define FOR_LIMIT_DOWN(last, step, max) \
        ((last) > (max) + ((step) + 1) ? (max) : (last) - ((step) + 1))

  Ist der Wert der Schrittweite c  {-1, 0, 1},  dann  ist  die  Korrektur  des
Schleifenendwertes ueberfluessig und wird weggelassen.
  Wegen der damit verbundenen besseren Lesbarkeit der  C-Programme,  wird  die
FOR-Schleife  in  die  ,,normale'' for-Schleife der Sprache C uebersetzt, wenn
der Endwert der Schleife eine Konstante ist und ein Ueber- bzw.  Unterlauf der
Schleifenkontrollvariablen nicht auftreten kann.


4.6.6
       WITH-Anweisung

  Die WITH-Anweisung hat kein direktes Gegenstueck in  C.  Sie  wird  in  eine
zusammengesetzte  Anweisung uebersetzt, die am Anfang die Deklaration und Ini-
tialisierung einer Zeigervariablen enthaelt. Diese Zeigervariable wird mit der
Adresse  der  Struktur  initialisiert, die dem in der WITH-Anweisung angespro-
chenen Verbund des Modula-Programms entspricht.  Innerhalb der  WITH-Anweisung
wird  in  C  dann  ueber  diese  Zeigervariable  auf  die  Strukturkomponenten
zugegriffen.  Diese Uebersetzung erfuellt die Forderung  der  Sprachdefinition
von  Modula-2,  dasz der Selektor, welcher den in der WITH-Anweisung angespro-
chenen Verbund festlegt, nur einmal ausgewertet wird.  Damit wird die folgende
Anweisung

    WITH t^ DO
      Key := 0; Left := NIL; Right := NIL;
    END

in C zu

    {
        register tNode *W_1 = t;
        W_1->Key = 0; W_1->Left = NIL; W_1->Right = NIL;
    }

                               43














4.6.7
       RETURN-Anweisung

  Die return-Anweisung in C entspricht genau der RETURN-Anweisung in Modula-2,
wobei  allerdings  die - aus der Sprachdefinition von Modula-2 nicht eindeutig
hervorgehende - Einschraenkung gemacht wird, dasz der Ergebnistyp einer  Funk-
tion kein Feld- oder Verbundtyp sein darf1.
  Wie oben erwaehnt muessen vor jeder RETURN-Anweisung die vor dem Aufruf  der
betreffenden Prozedur bzw. Funktion P gueltigen Werte der globalen Zeigervari-
ablen, die zur Uebersetzung des Zugriffs auf lokale Variablen von P  benoetigt
werden,  wiederhergestellt  werden.   Auszerdem  musz der Speicherplatz wieder
freigegeben werden, der fuer die als Wertparameter uebergebenen offenen Felder
angefordert wurde.  Enthaelt bei einer Funktion der RETURN-Ausdruck aber einen
Zugriff auf ein offenes Feld oder den Aufruf einer  (lokalen)  Funktion,  dann
duerfte  das Zurueckschreiben der alten Werte der globalen Zeigervariablen und
die Freigabe des Speichers eigentlich erst nach der RETURN-Anweisung erfolgen,
was  nicht  moeglich  ist.  In  diesem Fall wird daher die RETURN-Anweisung zu
einer zusammengesetzten Anweisung, die am Anfang die Deklaration einer lokalen
Variablen  enthaelt, welche mit dem RETURN-Ausdruck initialisiert wird. Danach
erst werden die alten Werte der globalen  Zeigervariablen  zurueckgeschrieben,
der  Speicher fuer offene Felder freigegeben und der Wert des RETURN-Ausdrucks
an die aufrufende Prozedur zurueckgeliefert. Damit wird der  folgende  Aussch-
nitt eines Modula-Prgramms

    PROCEDURE p (a : ARRAY OF CHAR): CHAR;
    BEGIN
      ...
      RETURN a[0];
    END p;

in C zu

    CHAR p(a, O_5)
    CHAR a[]; LONGCARD O_5;
    {
        ...
        {
            CHAR R_1 = a[0];
            FREE_OPEN_ARRAYS
            RETURN R_1;
        }
    }



4.6.8
       Laufzeitpruefungen

  Durch die Angabe einer Option bei der Uebersetzung kann man Mtc dazu  veran-
lassen,  Laufzeitpruefungen  zu  erzeugen, die die Abgabe einer entsprechenden
Fehlermeldung mit Angabe der Position im C-Quellprogramm und den  Abbruch  des
C-Programms   zur  Folge  haben,  falls  in  einer  CASE-Anweisung  durch  den
____________________
1 MOCKA macht diese Einschraenkung auch.


                               44











Selektorausdruck keine Fallmarke ausgewaehlt wird und der ELSE-Teil fehlt oder
falls eine Funktion kein Ergebnis liefert.


4.7
     Modul SYSTEM

  C ist eine relativ ,,maschinennahe'' Sprache. Daher steht ein  groszer  Teil
der  in  Modula-2  vom Modul SYSTEM zur Verfuegung gestellten Hilfsmittel fuer
die maschinennahe Programmierung auch in C zur Verfuegung.
  Da C allerdings keine Koroutinen kennt, mueszte man diese in C auf geeignete
Weise  simulieren.  Da  aber  eine  Simulation sowohl aufwendig als auch inef-
fizient waere und auszerdem die Verwendung von Koroutinen, wenn es sich  nicht
um  spezielle  Systemprogramme  handelt,  relativ selten ist, unterstuetzt der
Uebersetzer die Abbildung von NEWPROCESS, TRANSFER und IOTRANSFER nicht.
  Die vom Uebersetzer unterstuetzten Objekte aus dem Modul  SYSTEM  sind:  die
Typen WORD und ADDRESS, die Funktionen ADR und TSIZE sowie die Funktionen fuer
den Typtransfer. Auszerdem  wird  noch  die  von  MOCKA  implementierte  Spra-
cherweiterung um den Typ BYTE, der synonym zum Typ WORD ist, beruecksichtigt.
  Eine Typtransferfunktion wird in C als  eine  explizite  Umwandlung  in  den
angegebenen Typ realisiert, die dadurch ausgedrueckt wird, dasz dem betreffen-
den Wert der Name des gewuenschten Datentyps in Klammern vorangestellt wird.
  Die Typen BYTE und WORD sind in SYSTEM_.h folgendermaszen definiert:

    typedef unsigned char WORD;
    typedef WORD          BYTE;

  Damit die Uebergabe eines aktuellen Parameters an eine Prozedur, in  welcher
der  entsprechende  formale  Parameter  den  Typ WORD bzw. BYTE hat, auch in C
korrekt funktioniert, muessen alle Typen, die bei der Typabbildung  von  MOCKA
die  gleiche  Groesze  wie  WORD bzw.  BYTE zugewiesen bekommen, auch in C die
gleiche Groesze haben.
  Ist  der  formale  Parameter  einer  Prozedur  vom  Typ  ARRAY OF WORD  bzw.
ARRAY OF BYTE,  dann  hat die entsprechende C-Funktion - wie bei allen offenen
Feldern - einen zusaetzlichen Parameter, der  die  aktuelle  Anzahl  von  Fel-
delementen  enthaelt.  Bei der Parameteruebergabe musz bestimmt werden, welche
Groesze in Worten bzw. Bytes der aktuelle Parameter hat. Abgesehen davon  wird
ein  offenes  Feld  mit Elementen vom Typ WORD bzw. BYTE genauso behandelt wie
jedes andere offene Feld auch. Der folgende Ausschnitt eines Modula-Programms

    PROCEDURE WriteBytes (VAR a: ARRAY OF WORD);
      ...
    WriteBytes (w);

wird in C zu

    void WriteBytes(a, O_6)
    WORD a[]; LONGCARD O_6;
      ...
    WriteBytes(&w, sizeof(w));

Bei dieser Abbildung wird angenommen, dasz sizeof(WORD) bzw. sizeof(BYTE)  den
Wert  1  haben.   Ist  der  aktuelle  Parameter ein offenes Feld, dann ist die
Groesze des aktuellen Parameters in Worten bzw.  Bytes:  sizeof(Elementtyp)  *
aktuelle Anzahl von Feldelementen.

                               45











  Der Typ ADDRESS ist definiert als:

    typedef unsigned char *ADDRESS;

  In Modula-2 ist der Typ ADDRESS kompatibel mit  allen  anderen  Zeigertypen.
Wegen  der  in  C  vorhandenen Moeglichkeit Zeiger verschiedenen Typs einander
zuzuweisen oder einen Zeiger an eine Funktion zu uebergeben, dessen  Typ  sich
vom  Typ  des  formalen  Parameters unterscheidet, erfordert diese in Modula-2
definierte  Typkompatibilitaet  bei  der  Abbildung  nach  C  keine  spezielle
Behandlung.    Allerdings   wird   bei  der  Zuweisung  in  C  eine  explizite
Typumwandlung erzeugt, um sonst vom  C-Uebersetzer  ausgegebene  Warnungen  zu
unterdruecken.
  In Modula-2 koennen alle arithmetischen Operatoren  auf  Operanden  mit  Typ
ADDRESS angewandt werden, da ADDRESS auch kompatibel mit dem Typ CARDINAL ist.
Damit koennen beliebige Adreszberechnungen durchgefuehrt werden. In C kann nur
ein  ganzzahliger  Wert  zu  einem  Zeiger  addiert oder von einem Zeiger sub-
trahiert werden und zwei Zeiger koennen subtrahiert werden. Auszerdem ist in C
Zeigerarithmetik  so  definiert, dasz der Ausdruck p+1 den Wert von p, erhoeht
um die Groesze des Objekts auf welches p zeigt, liefert.  Hat  sizeof(ADDRESS)
den Wert 1, dann ergibt sich hier allerdings kein Unterschied zur Adreszarith-
metik in Modula-2.  Wird daher im Modula-Programm der  Typ  ADDRESS  innerhalb
von  arithmetischen  Ausdruecken  in  einer in C nicht zulaessigen Kombination
verwendet, dann wird der betreffende Operand in C zuerst in den  Typ  CARDINAL
umgewandelt  und  falls  notwendig  der Wert des gesamten Ausdrucks in den Typ
ADDRESS zurueckgewandelt1.
  Die Funktion TSIZE wird, wie die Standardfunktion SIZE, auf  den  C-Operator
sizeof abgebildet.
  ADR ist in SYSTEM_.h mit Hilfe des C-Operators &  zur  Adreszbestimmung  als
folgendes Makro definiert:

    #define ADR(x)          ((ADDRESS) &(x))

Da offene Felder auf Vektoren abgebildet werden und ein  Vektorname  als  Aus-
druck  einen  Zeiger  auf das erste Element des Vektors liefert, wird fuer die
Bestimmung der Adresse eines offenen Feldes das Makro ADR1  anstelle  von  ADR
benutzt:

    #define ADR1(x)         ((ADDRESS) x)



4.8
     Uebersetzungseinheiten

4.8.1
       Definitionsmoduln

  Ein Definitionsmodul M.md wird in eine Definitionsdatei M.h uebersetzt,  die
die vom Modul M exportierten Groeszen beschreibt.  Diese Definitionsdatei wird
mit einer #include-Anweisung in alle Moduln, die M importieren und in  das  C-
Programm  M.c,  welches  die Uebersetzung des zu M.md dazugehoerigen Implemen-
tierungsmoduls ist, eingefuegt.
____________________
1 MOCKA definiert, dasz ein arithmetischer Ausdruck in  dem  min-
  destens ein Operand den Typ ADDRESS hat den Resultattyp ADRRESS
  hat.


                               46











  Alle im Definitionsmodul M.md vereinbarten Objekte werden in C in der quali-
fizierten Form M_Objektname geschrieben1.
  Konstanten- und Typdefinitionen werden wie im  Kapitel  ueber  Deklarationen
besprochen nach C umgesetzt.
  Die Definitionsdatei enthaelt eine extern-Deklaration fuer jede  exportierte
Variable.  Diese Deklaration legt die Eigenschaften wie Datentyp und Speicher-
bedarf der Variablen fest,  damit  sie  in  allen  Moduln,  die  die  Variable
benutzen,  bekannt  sind.  Mit der extern-Deklaration wird aber kein Speicher-
platz reserviert. Die  eigentliche  Vereinbarung  der  Variablen,  die  dafuer
sorgt, dasz Speicherplatz reserviert wird, ist in M.c enthalten.
  Wird in der Definition einer exportierten Variablen ein anonymer  strukturi-
erter Typ verwendet, so enthaelt in C nur die extern-Deklaration in der Defin-
itionsdatei  die  vollstaendige  Strukturdeklaration  dieses  Typs.   In   der
eigentlichen   Vereinbarung   in   M.c  wird  der  in  der  extern-Deklaration
eingefuehrte Strukturname zur Beschreibung des Typs  verwendet.  Diese  Unter-
scheidung ist notwendig, da eine doppelt vorhandene vollstaendige Strukturdek-
laration vom C-Uebersetzer als  unzulaessige  Redeklaration  der  betreffenden
Struktur  zurueckgewiesen wird. Somit wird der folgende Ausschnitt des Defini-
tionsmoduls Parser.md

    VAR ParsTab : ARRAY [0..127] OF CHAR;

in der Definitionsdatei Parser.h zu

    extern struct Parser_1 {
        CHAR A[127 + 1];
    } Parser_ParsTab;

und im Programm Parser.c zu

    struct Parser_1 Parser_ParsTab;

  Da Zeichenketten der Laenge n > 1 auf  einen  initialisierten  Zeichenvektor
abgebildet  werden,  musz eine in einem Definitionsmodul als Konstante verein-
barte Zeichenkette bei der Uebersetzung nach C wie eine  exportierte  Variable
behandelt  werden. Das bedeutet, dasz in der Definitionsdatei M.h eine extern-
Deklaration und im Programm M.c  die  eigentliche  Vereinbarung  und  Initial-
isierung der Konstante enthalten ist.
  Fuer jede von M exportierte Prozedur ist ebenfalls  eine  extern-Deklaration
vorhanden,  die  den Namen und den Ergebnistyp der fuer die Prozedur erzeugten
C-Funktion in allen Moduln bekannt macht, die die Prozedur importieren.
  Der Definitionsmodul Tree.md

    DEFINITION MODULE Tree;
    CONST  NoTree   = NIL;
    TYPE
      tTree         = POINTER TO tNode;
      tNode         = RECORD
____________________
1   Ausnahme:  Die  Komponentennamen  einer  Struktur  werden  in
  unqualifizierter  Form  geschrieben, da sie immer bereits durch
  den Namen der Struktur, die sie enthaelt, qualifiziert sind.


                               47











                        Key   : INTEGER;
                        Left  ,
                        Right : tTree;
                      END;
    VAR  Root       : tTree;
    PROCEDURE MakeNode (Key: INTEGER; Left, Right: tTree): tTree;
    END Tree.

wird in C zur Definitionsdatei Tree.h

    #define Tree_NoTree     NIL
    typedef struct Tree_1 *Tree_tTree;
    typedef struct Tree_1 {
        INTEGER    Key;
        Tree_tTree Left, Right;
    } Tree_tNode;
    extern  Tree_tTree Tree_Root;
    extern  Tree_tTree Tree_MakeNode();



4.8.2
       FOREIGN-Moduln

  MOCKA erlaubt es, dasz in C geschriebene Prozeduren im Modula-Programm  auf-
gerufen werden. Diese Prozeduren muessen in sogenannten FOREIGN-Modul deklari-
ert sein, die als Definitionsmoduln  fungieren1.   Bei  der  Uebersetzung  von
Modula-2  nach  C  wird  ein FOREIGN-Modul im Prinzip wie ein Definitionsmodul
behandelt. Der einzige Unterschied ist, dasz alle dort definierten  Prozeduren
im erzeugten C-Programm nicht mit dem Modulnamen qualifiziert werden.


4.8.3
       Implementierungs- und Programmoduln

  Ein Implementierungs- oder Programmodul M.mi  wird  in  ein  C-Programm  M.c
uebersetzt.  M.c enthaelt neben der Uebersetzung der im Implementierungs- oder
Programmodul enthaltenen Konstanten-, Typ-,  Variablen-  und  Prozedurdeklara-
tionen  auch  Vereinbarungen  fuer  die in der Definitionsdatei M.h in extern-
Deklarationen erwaehnten exportierten Variablen.
  SYSTEM_.h mit der Definition der Standardtypen, -prozeduren und  -funktionen
wird in jedes erzeugte C-Programm als erste Definitionsdatei eingefuegt.
  Da auch in C eine getrennte Uebersetzung  moeglich  ist,  koennen  alle  vom
Uebersetzer  fuer  Implementierungs-  bzw. Programmoduln erzeugten C-Programme
vom C-Uebersetzer getrennt uebersetzt werden.


4.8.4
       IMPORT-Anweisungen

  IMPORT-Anweisungen werden in eine Folge von #include-Anweisungen uebersetzt.

____________________
1 FOREIGN-Moduln koennen auch  Typ-  und  Konstantendeklarationen
  enthalten.


                               48











Damit eine Definitionsdatei nicht mehrfach in ein C-Programm eingefuegt wird1,
wird am Anfang jeder Definitionsdatei M.h der Makroname DEFINITION_M mit einer
#define-Anweisung definiert und die IMPORT-Anweisung

    FROM M IMPORT ...

in die Praeprozessor-Anweisungen

    #ifndef DEFINITION_M
    #include "M.h"
    #endif

uebersetzt. Damit wird erreicht, dasz die Definitionsdatei M.h nur genau  ein-
mal in eine Quelldatei eingefuegt wird.


4.8.5
       Opaque Typen

  In Modula-2 ist es erlaubt im Definitionsmodul nur den Namen eines  Typs  zu
vereinbaren,  dessen  vollstaendige  Definition  dann im Implementierungsmodul
enthalten sein musz. Diese Typen, deren Struktur den sie importierenden Moduln
unbekannt  ist,  werden  als  opaque Typen bezeichnet. Opaque Typen sind immer
Zeigertypen.
  Die Abbildung  nach  C  wird  folgendermaszen  gehandhabt:  In  der  Defini-
tionsdatei wird ein opaquer Typ als

    typedef OPAQUE Modulname_Typname;

vereinbart. Der Typ OPAQUE ist in SYSTEM_.h als

    typedef ADDRESS OPAQUE;

definiert.
  Da auf opaque Typen in Modula-2 auszerhalb des Moduls in dem  sie  definiert
sind, nur Zuweisung und Vergleich anwendbar sind, ist bei der Uebersetzung von
Moduln, die diese Typen importieren keine  spezielle  Behandlung  von  opaquen
Typen notwendig. Die im Implementierungsmodul enthaltene vollstaendige Defini-
tion des opaquen Typs wird in eine zweite typedef-Anweisung umgesetzt. Da  der
Typname  in  der  Definitionsdatei qualifiziert wird, ergeben sich dabei keine
Namenskonflikte.  Auch innerhalb des nach C  uebersetzten  Implementierungsmo-
duls  wird  die  Typdefinition aus der Definitionsdatei in allen Deklarationen
benutzt. Um jedoch eine korrekte Anwendung des opaquen Typs in Anweisungen  zu
erzwingen, wird vor jeder Dereferenzierung eine explizite Typumwandlung in den
vollstaendigen Typ eingefuegt.
  Der Definitionsmodul Lists.md

    DEFINITION MODULE Lists;
    FROM SYSTEM     IMPORT ADDRESS;
    TYPE  tList;

____________________
1 Mehrfach vorhandene  identische  Typ-  bzw.  Konstantendeklara-
  tionen innerhalb einer Quelldatei sind in C nicht zulaessig.


                               49











    PROCEDURE Insert (VAR List: tList; Elmt: ADDRESS);
      ...
    END Lists.

wird in C zur Definitionsdatei Lists.h

    #define DEFINITION_Lists
    typedef OPAQUE Lists_tList;
    extern  void Lists_Insert();
      ...

  Der Implementierungsmodul Lists.mi

    IMPLEMENTATION MODULE Lists;
    FROM SYSTEM     IMPORT ADDRESS;
    TYPE
      tList = POINTER TO tElmt;
      tElmt = RECORD
                Elmt : ADDRESS;
                Next : tList;
              END;
    PROCEDURE Insert (VAR List: tList; Elmt: ADDRESS);
    VAR  Head : tList;
    BEGIN
      Head       := MakeElmt (Elmt);
      Head^.Next := List;
      List       := Head;
    END Insert;
      ...
    END Lists.

wird in C zum Programm Lists.c

    #include "SYSTEM_.h"
    #ifndef DEFINITION_Lists
    #include "Lists.h"
    #endif
    typedef struct S_1 *tList;
    typedef struct S_1 {
        ADDRESS     Elmt;
        Lists_tList Next;
    } tElmt;
    void Lists_Insert(List, Elmt)
    Lists_tList *List; ADDRESS Elmt;
    {
        Lists_tList Head;
        Head = MakeElmt(Elmt);
        ((tList)Head)->Next = List;
        *List = Head;
    }
      ...


                               50











4.8.6
       Modulinitialisierung

  Die Modulinitialisierung wird in C  mit  folgendem  Schema  behandelt:  Fuer
jeden  Implementierungsmodul wird in C eine parameterlose Initialisierungsrou-
tine erzeugt. Diese ruft zunaechst die Initialisierungsroutinen  aller  direkt
importierten  Moduln  in  der  textuellen Reihenfolge der zugehoerigen IMPORT-
Anweisungen auf und enthaelt dann die Anweisungen aus dem  Rumpf  des  Moduls.
Um  eine korrekte und vollstaendige Initialisierung aller Moduln zu erreichen,
muessen dabei auch die IMPORT-Anweisungen aus  dem  zum  Implementierungsmodul
dazugehoerigen Definitionsmodul beruecksichtigt werden.  Diese Reihenfolge der
Initialisierung entspricht genau der  in  der  Sprachdefinition  von  Modula-2
geforderten Reihenfolge. Damit die Initialisierungsroutine nicht mehrfach aus-
gefuehrt wird, enthaelt sie eine boolesche Variable, die angibt, ob  die  Rou-
tine  bereits  aufgerufen  wurde. Nur beim ersten Aufruf wird sie ausgefuehrt.
Somit haben die Initialisierungsroutinen folgende Form:

    void BEGIN_Modulname()
    {
        static BOOLEAN has_been_called = FALSE;
        if (!has_been_called) {
            has_been_called = TRUE;
            /*
             *  Initialisierungsroutinen der
             *  importierten Moduln aufrufen.
             *
             *  Anweisungen des Modulrumpfs
             *  ausfuehren.
             */
        }
    }

  Diese Behandlung der Modulinitialisierung erfordert zur Laufzeit einen etwas
erhoehten  Aufwand,  da  ein Teil der Initialisierungsroutinen moeglicherweise
mehrfach aufgerufen wird. Der grosze Vorteil dieser  Loesung  ist  aber,  dasz
alle  Moduln  korrekt initialisiert werden, ohne dasz bei der Uebersetzung des
Programmoduls bestimmt werden musz, welche Moduln in  einem  Programm  benutzt
werden.


4.8.7
       Hauptprogramm

  Der Rumpf des Programmoduls bildet in Modula-2 das Hauptprogramm.  In C wird
er   zu   der   Funktion  BEGIN_MODULE.  Diese  ruft  zunaechst  die  Initial-
isierungsroutinen aller direkt importierten Moduln auf und enthaelt  dann  die
Anweisungen aus dem Rumpf des Programmoduls.
  Die Datei SYSTEM_.c enthaelt eine feste Definition der Funktion main, die in
C das Hauptprogramm bildet. Diese Funktion hat folgendes Aussehen:

    int    SYSTEM_argc;
    char **SYSTEM_argv;
    char **SYSTEM_envp;
    main(argc, argv, envp)
    int argc;
    char *argv[], *envp[];
    {

                               51











      SYSTEM_argc = argc;
      SYSTEM_argv = argv;
      SYSTEM_envp = envp;
      BEGIN_MODULE();
      exit(0);
    }

  Vor dem Aufruf von BEGIN_MODULE werden in main die Programmparameter  behan-
delt.  In  C  und unter UNIX koennen beim Aufruf eines Programms Argumente aus
der Kommandozeile an das Programm uebergeben werden. Das erste  Argument  argc
ist  die  Anzahl  der  Argumente,  das zweite Argument argv ist ein Zeiger auf
einen Vektor mit Zeichenketten, die die Argumente enthalten. Das dritte  Argu-
ment   envp  schlieszlich  ermoeglicht  den  Zugriff  auf  UNIX-Variablen  der
Aufrufumgebung.
  Die MOCKA-Bibliothek enthaelt ein FOREIGN-Modul, welches die Definition  von
Prozeduren  enthaelt,  welche  Modula-Programmen  den  Zugriff  auf  die  Pro-
grammparameter ermoeglichen. Die Implementierung dieses FOREIGN-Moduls ist bei
MOCKA ein Teil des Laufzeitsystems. Die obige Behandlung der Programmparameter
in der Funktion main ermoeglicht es, dieses FOREIGN-Modul in  C  zu  implemen-
tieren.
  Die  Funktion  main  wird  mit  exit(0)  beendet,  um   der   Aufrufumgebung
anzuzeigen, dasz die Ausfuehrung des Programms erfolgreich war.



5.
    Implementierung des Uebersetzers

  Bild 5.1 gibt einen kurzen Ueberblick ueber die einzelnen Phasen des  Ueber-
setzers  Mtc, die fuer die Implementierung der Phasen verwendeten Uebersetzer-
bauwerkzeuge (in Klammern  hinter  den  Namen  der  Phasen)  sowie  ueber  die
wichtigsten  intern  auftretenden  Datenstrukturen,  die der Kommunikation der



              Bild 5.1: Phasen des Uebersetzers Mtc

einzelnen Uebersetzerphasen dienen.
  Die folgenden Kapitel enthalten eine genauere Besprechung der  Aufgaben  und
Implementierung  der  einzelnen Phasen des Uebersetzers, wobei besonderer Wert
auf die Darstellung des Einsatzes der  Werkzeuge  gelegt  wird.   Grundlegende
Begriffe  und  Techniken des Uebersetzerbaus [Aho86, Waite84] werden dabei als
weitgehend bekannt vorausgesetzt.


5.1
     Lexikalische Analyse

  Der Symbolentschluessler liest das Eingabeprogramm zeichenweise und  zerlegt
es  in  eine Folge von Grundsymbolen, die an den Zerteiler weitergereicht wer-
den.  Seine Aufgaben sind im einzelnen:
-
    Erkennen der moeglichen Grundsymbole  der  Sprache  Modula-2:  Bezeichner,
    ganze Zahlen (oktal, dezimal oder hexadezimal), reelle Zahlen, Zeichenkon-
    stanten, Zeichenketten, Schluesselwoerter, Operatoren und Trennsymbole.


                               52











-
    Berechnung der Attribute der Grundsymbole:
    -
        Quelltextposition
    -
        semantische Information
-
    Ueberlesen von Kommentaren, Zwischenraeumen und Zeilenwechseln.
-
    Melden von illegalen  Zeichen  und  nicht  geschlossenen  Kommentaren  und
    Zeichenketten.
  Die Kodierung der erkannten Grundsymbole und deren Attribute werden  an  den
Zerteiler weitergereicht.


5.1.1
       Attribute der Grundsymbole

  Die Quelltextposition der Grundsymbole wird  fuer  spaetere  Fehlermeldungen
benoetigt.   Sie  setzt sich zusammen aus dem Namen der Eingabedatei sowie aus
Zeile und Spalte des Grundsymbols innerhalb der Eingabedatei. Warum  auch  der
Name  der Eingabedatei mit in die Quelltextposition aufgenommen wurde, wird im
Zusammenhang mit der Behandlung der getrennten Uebersetzung naeher erlaeutert.
  Fuer spaetere Uebersetzerphasen  wird  zusaetzliche  sematische  Information
fuer  solche  Grundsymbole  benoetigt,  die durch die zugehoerige Zeichenkette
nicht eindeutig festgelegt sind.  Die Tabelle 5.2 beschreibt  diese  Grundsym-

         _______________________________________________
            Grundsymbol       Semantische Information
         _______________________________________________
          Bezeichner
                             Eindeutige  Abbildung  der
                             zugehoerigen  Zeichenkette
                             auf eine ganze Zahl
          Dezimalzahl
                             Wert der Zahl
          Oktalzahl
                             Wert der Zahl
          Hexadezimalzahl
                             Wert der Zahl
          Zeichenkonstante
                             Zugehoeriges Zeichen
          Reelle Zahl
                             Verweis in die Konstanten-
                             tabelle
          Zeichenkette
                             Verweis in die Konstanten-
                             tabelle
         _______________________________________________
        











                          











                                                       












      Tabelle 5.2: Semantische Information der Grundsymbole

bole und die Bedeutung der zugehoerigen semantischen Information.


5.1.2
       Symbol- und Konstantentabelle

  Der Symboltabellenmodul Idents zur eindeutigen Abbildung  von  Zeichenketten
auf  ganze  Zahlen,  der Konstantentabellenmodul StringMem zur Speicherung von
Zeichenketten variabler Laenge sowie der von beiden verwendete  Modul  Strings
zur  Manipulation von Zeichenketten und zur Konvertierung von Zeichenketten in
interne Darstellungen, wie z.B. ganze Zahlen, wurden aus der Bibliothek  Reuse
[Grosch87a] entnommen.


5.1.3
       Spezifikation des Symbolentschluesslers

  Der Symbolentschluessler wurde mit Hilfe des Generators Rex [Grosch87b]  aus
einer   Beschreibung  der  Grundsymbole  von  Modula-2  erzeugt.  Eine  solche
Beschreibung besteht aus einer Reihe von regulaeren  Ausdruecken,  welche  die

                               53











Grundsymbole  beschreiben  und  Aktionen,  die  ausgefuehrt  werden,  wenn die
zugehoerigen regulaeren Ausdruecke in der Eingabe erkannt werden.  Rex  ueber-
setzt  diese  Beschreibung  in einen tabellengesteuerten Symbolentschluessler,
der im Modul Scanner enthalten ist.
  Die Aktionen bestehen in den meisten Faellen aus der Berechnung  der  Attri-
bute  des  zugehoerigen  Grundsymbols  und einer RETURN-Anweisung, mit der die
Kodierung des Grundsymbols an den Zerteiler zurueckgeliefert wird.  Zeile  und
Spalte der Grundsymbole im Quelltext werden vom generierten Symbolentschluess-
ler automatisch berechnet.
  Das folgende Beispiel zeigt einige Ausschnitte  aus  der  Spezifikation  des
Symbolentschluesslers:

    #STD#      "(*"         :- {NestingLevel := 1; yyStart (Comment);}
    #Comment#  "(*"         :- {INC (NestingLevel);}
    #Comment#  "*)"         :- {DEC (NestingLevel);
                                IF NestingLevel = 0 THEN yyStart (STD); END;}
    #Comment#  "(" | "*" | - {*(\t\n} + :- {}
    #STD# ARRAY             : {Attribute.Pos.File   := SourceFileName;
                               Attribute.Pos.Line   := Line;
                               Attribute.Pos.Column := Column;
                               RETURN TokArray;}
    #STD# letter (letter | digit) * : {
                               GetWord (Word);
                               Attribute.Ident      := MakeIdent (Word);
                               Attribute.Pos.File   := SourceFileName;
                               Attribute.Pos.Line   := Line;
                               Attribute.Pos.Column := Column;
                               RETURN TokIdent;}

  Fuer komplexe Aufgaben und insbesondere fuer die Behandlung von Linkskontext
stehen  sogenannte  Startzustaende  zur  Verfuegung. In der Spezifikation kann
festgelegt werden, dasz bestimmte Muster  nur  in  bestimmten  Startzustaenden
erkannt  werden.  Zu Beginn ist der Symbolentschluessler immer im Startzustand
STD.  Startzustaende  koennen  mit  speziellen  Anweisungen  in  den  Aktionen
gewechselt  werden.  Diese Moeglichkeit wird im obigen Beispiel fuer die Bear-
beitung von Kommentaren benutzt. Die Variable NestingLevel ist  notwendig,  da
Kommentare  in Modula-2 geschachtelt sein koennen und geschachtelte Kommentare
nicht durch einen regulaeren Ausdruck beschrieben werden koennen.   Die  Funk-
tion  MakeIdent  aus  dem  Modul  Idents  bildet  die vom Symbolentschluessler
erkannte Zeichenfolge eines Bezeichners eindeutig auf eine ganze Zahl ab.


5.2
     Syntaktische Analyse und Baumaufbau

  Die Aufgabe des Zerteilers ist es, die syntaktische Struktur  des  Quellpro-
gramms  zu  analysieren,  dessen  syntaktische Korrektheit zu ueberpruefen und
einen abstrakten Strukturbaum aufzubauen.


5.2.1
       Zerteilerspezifikation

  Fuer die Erstellung eines Zerteilers standen die beiden Zerteilergeneratoren
Ell und Lalr [Vielsack88] zur Verfuegung. Verglichen mit Lalr hat Ell die fol-
genden Vor- und Nachteile:

                               54











Vorteile:
-
    Die von Ell unterstuetzte L-Attributierung1, mit  der  parallel  zur  Zer-
    teilung Attributwerte berechnet werden koennen, ist maechtiger als die von
    Lalr unterstuetzte S-Attributierung2.  Auszerdem kann  die  Attributierung
    bei Ell im Gegensatz zu Lalr 3 symbolisch  durchgefuehrt  werden  und  ist
    damit weniger fehleranfaellig.
-
    Ein von Ell erzeugter Zerteiler ist etwa doppelt so schnell  wie  ein  von
    Lalr erzeugter.
Nachteile:
-
    Der gravierendste Nachteil von Ell ist, dasz die von Ell akzeptierte Spra-
    chklasse  ELL(1)  weniger  maechtig ist als die von Lalr akzeptierte Spra-
    chklasse LALR(1).
-
    Von Lalr erzeugte  Zerteiler  sind  in  der  Regel  kleiner  als  von  Ell
    erzeugte.
  Da bereits eine  ELL(1)-Grammatik  fuer  Modula-2  vorlag,  gaben  die  oben
genannten  Vorteile von Ell den Ausschlag fuer die Entscheidung Ell zu verwen-
den.
  Die  Eingabe  fuer  Ell  besteht  aus  einer  kontextfreien   Grammatik   in
erweiterter  BNF, die die Struktur der Eingabesprache beschreibt. Jede Produk-
tion der Grammatik kann eine Reihe von semantischen Aktionen enthalten, welche
ausgefuehrt  werden,  sobald  der  Zerteiler  die zugehoerigen Grammatikregeln
analysiert.
  Ell erzeugt aus der kontextfreien Grammatik einen  Zerteiler  (enthalten  im
Modul  Parser),  der nach dem Verfahren des rekursiven Abstiegs arbeitet.  Die
semantischen Aktionen werden an die entsprechenden Stellen  in  den  Quelltext
des  Zerteilers  kopiert.  Der  erzeugte  Zerteiler  besitzt eine automatische
Fehlerbehandlung, die mit einem ruecksetzungsfreien Fehlerkorrekturalgorithmus
arbeitet.  Ist die vom Symbolentschluessler gelieferte Folge von Grundsymbolen
nicht syntaktisch korrekt, setzt der Zerteiler nach Abgabe einer Fehlermeldung
die  Zerteilung  fort,  indem er Symbole ueberliest und/oder einfuegt, so dasz
immer ein syntaktisch korrekter Strukturbaum erzeugt wird.


5.2.2
       Spezifikation des Strukturbaums

  Eine Spezifikation der abstrakten Syntax von Modula-2 wurde mit der Spezifi-
kationssprache  des  Generators Ast [Grosch89a] erstellt.  Ast erzeugt aus der
Spezifikation der abstrakten Syntax den Modul Tree, der  Typdeklarationen  zur
Implementierung des Strukturbaums und Prozeduren zum Aufbau von Baumknoten und
zur Umkehr von Knotenlisten enthaelt.
____________________
1 Bei der L-Attributierung sind sowohl vererbte als auch  synthe-
  tisierte  Attribute moeglich.  Dabei darf innerhalb einer Gram-
  matikregel X0:X1...Xn.  ein Attribut des Symbols Xi (1_i_n) nur
  von vererbten Attributen des Symbols X0 oder von Attributen der
  Symbole X1 bis Xi-1 abhaengen.
2 Bei der  S-Attributierung  sind  nur  synthetisierte  Attribute
  zulaessig.
3 Lalr  benutzt die Pseudovariablen $$ bzw. $n, um auf das Nicht-
  terminal der linken Seite bzw.  das  n-te  Symbol  der  rechten
  Seite einer Produktion zuzugreifen.


                               55











  Die Struktur und die Eigenschaften der  Knoten,  aus  denen  ein  abstrakter
Strukturbaum  besteht,  werden  in  einer  Ast-Spezifikation  mit  sogenannten
Knotentypen beschrieben. Jeder Knoten gehoert zu einem  bestimmten  Knotentyp.
Der Typ beschreibt die Kindknoten (Unterbaeume) und die Attribute des Knotens.
Knotentypen koennen als Erweiterung von anderen Knotentypen definiert  werden;
letztere  werden als Basistypen bezeichnet, erstere als abgeleitete Typen. Die
abgeleiteten Typen erben die Kindknoten und Attribute des Basistyps und  koen-
nen  wiederum  erweitert werden. Ueberall dort, wo ein Knoten eines bestimmten
Basistyps erwartet wird, ist auch ein Knoten zulaessig,  dessen  Typ  aus  dem
Basistyp abgeleitet wurde.
  Folgender Ausschnitt der Ast-Spezifikation beschreibt die  abstrakte  Syntax
eines Teils der Anweisungen von Modula-2:

    Stmts         = <
      Stmts0      = .
      Stmt        = Next: Stmts REVERSE <
        Assign    = Designator Expr .
        Call      = Designator Actuals .
        If        = Cond: Expr Then: Stmts Elsifs Else: Stmts .
        Case      = Expr Cases Else: Stmts [Default: BOOLEAN] .
        While     = Cond: Expr Stmts .
        ...
      >.
    >.

  Die Knotentypen Assign, Call, usf. sind Erweiterungen des  Knotentyps  Stmt,
welcher  wiederum eine Erweiterung des Knotentyps Stmts ist. Attribute sind in
eckigen Klammern eingeschlossen. Die Spezifikation von Kindknoten besteht  aus
dem zugehoerigen Knotentyp und einem optionalen Selektornamen. Die Knotentypen
Assign, Call, usf. erben den Kindknoten mit  Namen  Next  von  ihrem  Basistyp
Stmt.   Die  abstrakte Syntax enthaelt im Gegensatz zur konkreten Syntax keine
eigenen Knotentypen fuer Listen. Stattdessen  enthaelt  jeder  Knotentyp  fuer
Listenelemente  einen  Kindknoten Next, der auf das naechste Element der Liste
verweist.  Die Angabe REVERSE wird von Ast zur Erzeugung der Prozedur fuer die
Umkehr von Knotenlisten benoetigt.
  Beim Entwurf der abstrakten Syntax wurde darauf geachtet, dasz die Struktur-
baeume  moeglichst einfach und kompakt aufgebaut sind.  Dadurch wird nicht nur
der Speicherbedarf der Strukturbaeume reduziert,  sondern  auch  deren  Verar-
beitung  beschleunigt,  da bei der Traversierung weniger Knoten besucht werden
muessen.  Anhang A enthaelt die vollstaendige Ast-Spezifikation der abstrakten
Syntax von Modula-2, wie sie fuer den Uebersetzer verwendet wurde.


5.2.3
       Baumaufbau

  Zum Aufbau des Strukturbaums waehrend der Zerteilung wird der von Ell  ange-
botene  Mechanismus  zur  L-Attributierung, die von Ast generierten Prozeduren
fuer den Baumaufbau und die Prozedur ReverseTree zur Umkehr  von  Knotenlisten
benutzt.
  Das folgende Beispiel zeigt einen  Ausschnitt  der  kontextfreien  Grammatik
fuer Fallmarken mit semantischen Aktionen fuer den Baumaufbau:





                               56











    Labels          /* Tree: synthesized                    */
                    :
      { Label1.Tree := mLabels0 (); }
                      Label || ','
      { Labels0.Tree := ReverseTree (Label1.Tree); }
                    .
    Label           /* Tree: inherited and synthesized      */
                    : Expr
                        ( '..' Expr
        { Label0.Tree := mLabelRange (Label0.Tree, Expr1.Tree, Expr2.Tree); }
                        |
        { Label0.Tree := mLabel (Label0.Tree, Expr1.Tree); }
                        )
                    .

  Baumknoten werden aufgebaut durch Aufrufe der von Ast fuer diesen Zweck gen-
erierten  Prozeduren. Ast generiert fuer jeden Knotentyp eine solche Prozedur.
Die Kindknoten und Attribute des Knotens werden als Parameter  uebergeben  und
ein Zeiger auf den neu angelegten Knoten wird zurueckgeliefert.  Die Nichtter-
minale der kontextfreien Grammatik besitzen ein  Attribut  Tree,  welches  den
Teilbaum  beschreibt,  dessen  Wurzel das Nichtterminal ist.  Die kontextfreie
Grammatik  enthaelt  noch  verschiedene   Nichtterminale   fuer   Listen   und
Listenelemente.  Im  Baum  existieren  aber  nur  noch  Knotentypen  fuer  die
Listenelemente mit einem Verweis auf das jeweils naechste Element. Daher  wird
bei  der  Zerteilung  einer  Liste der bisher aufgebaute Strukturbaum fuer die
Liste, der aus verketteten Listenelementen besteht, als vererbtes Attribut  an
das  Nichtterminal  fuer  die  Listenelemente  uebergeben und dort beim Aufbau
eines neuen Listenelements als Verweis auf das naechste Listenelement  verwen-
det.   Dabei wird die Liste zunaechst in der verkehrten Reihenfolge aufgebaut.
Dies wird aber in der Grammtikregel fuer die Liste  nach  der  Zerteilung  der
Liste  durch  einen Aufruf der von Ast generierten Prozedur ReverseTree korri-
giert.


5.3
     Behandlung der getrennten Uebersetzung

  Die getrennte Uebersetzung ermoeglicht es, Programme in  kleinere  Teile  zu
zerlegen,  die vom Uebersetzer einzeln uebersetzt werden koennen. Die wichtig-
sten Ziele einer solchen Zerlegung sind:
-
    Aufteilung  eines  Programmsystems  in   ueberschaubare   und   moeglichst
    abgeschlossene  Einheiten (Moduln), die eine definierte Schnittstelle nach
    auszen besitzen und deren interne Implementierung  nach  auszen  verborgen
    bleibt.
-
    Arbeitsteilige Erstellung von Programmsystemen.
-
    Reduktion des Uebersetzungsaufwands.
-
    Entwicklung von Programmbibliotheken mit wiederverwendbarer Software.
  Bei einer getrennten  Uebersetzung  sollte  der  Uebersetzer  zur  Erzielung
hoeherer  Zuverlaessigkeit  nach Moeglichkeit Korrektheitspruefungen ueber die
Grenzen von Uebersetzungseinheiten hinweg vornehmen1.
____________________
1 Eine haeufige Fehlerquelle bei der Entwicklung von C-Programmen
  ist,  dasz in C solche Pruefungen vom Uebersetzer nicht automa-
  tisch vorgenommen werden.

                               57











  Modula-2 unterstuetzt die  oben  genannten  Forderungen  durch  sein  Modul-
konzept,  insbesondere durch die Trennung von globalen Moduln in Schnittstelle
(Definitionsmodul)  und  Implementierung  (Implementierungsmodul).   Soll   in
Modula-2  eine Uebersetzungseinheit uebersetzt werden, dann muessen dem Ueber-
setzer die Schnittstellen  aller  von  der  Uebersetzungseinheit  importierten
Moduln bekannt sein. Auch bei der Uebersetzung von Modula-2 nach C muessen die
Schnittstellen der importierten Moduln bekannt sein,  da  fuer  eine  korrekte
Uebersetzung  semantische Informationen ueber die importierten Objekte notwen-
dig sind.
  Eine Loesung fuer dieses Problem, die auch  von  MOCKA  implementiert  wird,
ist,  bei der Uebersetzung eines Definitionsmoduls eine sogenannte Symboldatei
anzulegen, die einen Ausschnitt der Definitionstabelle des  Uebersetzers  dar-
stellt und eine Beschreibung aller vom zugehoerigen Modul exportierten Objekte
enthaelt.  Diese Symboldatei wird dann bei der  Uebersetzung  von  abhaengigen
Moduln  benutzt,  indem  die dort enthaltene Information wieder in die Defini-
tionstabelle eingetragen wird.
  Eine alternative Loesung ist, bei jedem Uebersetzungsvorgang  den  Quelltext
aller  Schnittstellen von (transitiv) importierten Moduln von neuem einzulesen
und zu analysieren.
  Vergleicht man die beiden Loesungen ergibt sich folgendes:
-
    Ein Uebersetzer, welcher die Loesung mit den Symboldateien verwendet,  ist
    schneller   und  der  gesamte Uebersetzungsaufwand reduziert sich, da eine
    Schnittstelle nur einmal uebersetzt und nur einmal eine (binaere)  Symbol-
    datei  angelegt werden musz; bei der Uebersetzung aller abhaengigen Ueber-
    setzungseinheiten musz dann nur jeweils die einmal  angelegte  Symboldatei
    neu  eingelesen  werden,  was  sicher  weniger  Aufwand verursacht als den
    Quelltext  der  Schnittstelle  jedesmal  von  neuem  einzulesen   und   zu
    analysieren.
-
    Der Programmieraufwand fuer die Loesung mit den Symboldateien ist deutlich
    hoeher,  da  Dateiformate fuer die Symboldateien definiert und Operationen
    programmiert werden muessen, die a) die Information aus der Definitionsta-
    belle lesen und auf die Symboldatei schreiben und b) die Symboldatei lesen
    und die Information in die Definitionstabelle  eintragen.  Dieser  zusaet-
    zliche  Programmieraufwand  entfaellt fuer die zweite Loesung, da Einlesen
    und Analyse der Schnittstellen sowieso ein Teil des Uebersetzers sind.
-
    Zur Unterstuetzung des Benutzers sollte ein  Uebersetzer,  der  die  erste
    Loesung realisiert, ueberpruefen, ob alle fuer die Uebersetzung einer bes-
    timmten Uebersetzungseinheit benoetigten Symboldateien vorhanden  und  auf
    dem  neuesten  Stand,  d.h.  konsistent mit dem Quelltext des zugehoerigen
    Definitionsmoduls, sind und bei Bedarf zuerst die  (Neu-)Uebersetzung  der
    zugehoerigen  Definitionsmoduln  in  eine  Symboldatei  anstoszen1.   Dies
    entfaellt bei der zweiten Loesung automatisch, da sowieso alle benoetigten
    Definitionsmoduln eingelesen werden2.
____________________
1 Ist eine derartige automatische  Unterstuetzungsfunktion  nicht
  implementiert,  musz der Benutzer selbst die Modulabhaengigkei-
  ten analysieren, musz sich selbst um  die  Uebersetzungsreihen-
  folge  und  die  Konsistenz  der  erzeugten  Symboldateien bzw.
  Objektprogramme  kuemmern.  Eine  u.U.  recht  aufwendige   und
  fehleranfaellige  Arbeit,  die unbedingt vom Uebersetzer ueber-
  nommen werden sollte.
2 Allerdings wird dadurch nicht verhindert,  dasz  die  erzeugten
  Objekt-  bzw  C-Programme  moeglicherweise  gegenseitig  inkon-
  sistent sind!


                               58











  Da Mtc nicht fuer die Programmentwicklung gedacht ist und folglich ein  fer-
tig  entwickeltes  Modula-Programm  auch  nur  einmal nach C uebersetzt werden
musz, ist es nicht kritisch, wenn der Uebersetzer aufgrund eines  wiederholten
Einlesens  und  einer  wiederholten Analyse von Schnittstellen etwas langsamer
ist. Daher gab der deutlich geringere Aufwand  fuer  die  Implementierung  der
zweiten Loesung den Ausschlag, diese im Uebersetzer Mtc zu realisieren.
  Zur Realisierung der oben  skizzierten  Loesung  im  Uebersetzer  Mtc  wurde
zunaechst die Definition des Strukturbaums erweitert. Ein Strukturbaum besteht
nicht nur aus einer Uebersetzungseinheit, sondern aus einer Liste  von  Ueber-
setzungseinheiten:

    ROOT            = CompUnits .
    CompUnits       = <
      CompUnits0    = .
      CompUnit      = [Kind: SHORTCARD] [Ident: tIdent] [Pos: tPosition]
                      Next: CompUnits REVERSE <
        DefMod      = Import Decls .
        ProgMod     = Import Decls Stmts .
      >.
    >.

  Da die Uebersetzungseinheiten aus verschiedenen Quelldateien  stammen,  wird
jetzt  auch klar, warum, wie im Kapitel ueber die lexikalische Analyse bereits
erwaehnt, die Quelltextposition auch den Namen der Quelldatei enthalten musz.
  Der Aufbau dieser Liste von  Uebersetzungseinheiten,  d.h.  der  Aufbau  des
Strukturbaums  in  seiner  endgueltigen  Form  und  somit  die  Behandlung der
getrennten Uebersetzung, uebernimmt der Modul DefMods.  Der vom Zerteiler auf-
gebaute Strukturbaum fuer die aktuelle Uebersetzungseinheit bildet die Eingabe
fuer diesen Modul.   Innerhalb  von  DefMods  werden  die  Importlisten  aller
bereits  eingelesenen  Uebersetzungseinheiten traversiert und fuer alle impor-
tierten und bisher noch nicht eingelesenen (Definitions-)Moduln der  Zerteiler
aufgerufen,  welcher  das Einlesen der Definitionsmoduln steuert und Struktur-
baeume fuer sie aufbaut1. Ist die aktuelle Uebersetzungseinheit ein  Implemen-
tierungsmodul,  musz  auch der zugehoerige Definitionsmodul eingelesen werden.
Aus dem Teilbaum der aktuellen Uebersetzungseinheit und aus den vom  Zerteiler
gelieferten  Teilbaeumen  der  benoetigten Definitionsmoduln wird schlieszlich
der vollstaendige  Strukturbaum  aufgebaut  und  an  die  semantische  Analyse
weitergereicht.
  Vergleicht man den Umfang der fuer die Behandlung der  getrennten  Ueberset-
zung  notwendigen  Programmteile  von Mtc und MOCKA, bestaetigen sich die oben
gemachten Aussagen des Vergleichs  hinsichtlich  des  Programmieraufwands  der
beiden  Loesungen  eindrucksvoll.  Allein der Modul DfFiles von MOCKA, der die
Symboldateien liest und beschreibt sowie deren Daten  aus  der  Definitionsta-
belle  liest  und  dort wieder eintraegt, umfaszt ca. 1450 Zeilen Modula-Code.
Dazu kommt dann noch zusaetzlich die von MOCKA  implementierte  Steuerung  der
Nachuebersetzung  bzw. der Uebersetzungsreihenfolge. Im Gegensatz dazu umfaszt
der Modul DefMods von Mtc, der die gesamte getrennte  Uebersetzung  behandelt,
nur ca. 250 Zeilen Modula-Code.
____________________
1 Entsprechend der von MOCKA implementierten Konvention wird  ein
  Definitionsmodul M in einer Datei mit Namen M.md erwartet. Beim
  Aufruf von Mtc koennen auch Bibliotheken angegeben werden,  die
  dann nach den benoetigten Definitionsmoduln durchsucht werden.


                               59











5.4
     Semantische Analyse

  Normalerweise ist es die Aufgabe der  semantischen  Analyse,  die  Bedeutung
bzw. die Eigenschaften des Quellprogramms, welche zur statischen Semantik1 der
Sprache gehoeren, zu bestimmen und zu ueberpruefen, ob diese Eigenschaften den
Regeln der statischen Semantik der Sprache, wie sie von  der  Sprachdefinition
festgelegt  werden,  genuegen. Wie in der Einleitung bereits naeher erlaeutert
und begruendet, soll Mtc  die  semantische  Korrektheit  der  Eingabeprogramme
nicht  ueberpruefen.  Daher  kann  die  semantische Analyse im Uebersetzer Mtc
darauf beschraenkt werden, die Eigenschaften des Modula-Programms  zu  bestim-
men,  soweit  sie fuer eine korrekte Uebersetzung nach C bekannt sein muessen.
Aus diesem Grund sind die  zentralen  Aufgaben  der  semantischen  Analyse  im
Uebersetzer Mtc der Aufbau einer Definitionstabelle, die Bezeichneridentifika-
tion und die Typbestimmung in Ausdruecken.


5.4.1
       Spezifikation der semantischen Analyse mit einer Attributgrammatik  und
       abstrakten Datentypen

  Die semantische Analyse wurde mit einer Attributgrammatik spezifiziert.  Der
Generator  Ag  [Grosch89b] erzeugt aus dieser Attributgrammatik einen Attribu-
tauswerter   (enthalten   im   Modul   Semantics),    der    mit    rekursiven
Besuchsprozeduren,  welche  den  Strukturbaum  traversieren  und die Attribute
berechnen, implementiert ist.
  Ag arbeitet eng mit Ast zusammen. Die in Kapitel 5.2.2 beschriebene Spezifi-
kation  der  abstrakten Syntax ist nur der erste Teil einer Attributgrammatik,
deren zweiter Teil  aus  der  Deklaration  von  Attributen  und  aus  Attribu-
tierungsregeln besteht, die die Werte dieser Attribute festlegen.
  Attribute und Attributierungsregeln werden den  Knotentypen  der  abstrakten
Syntax  zugeordnet.  Als  Typen  fuer  die Attribute sind alle Typen der Ziel-
sprache Modula-2, in welcher der Attributauswerter implementiert ist,  zulaes-
sig.  Die  Berechnung  der  Attribute wird ebenfalls mit Anweisungen der Ziel-
sprache Modula-2, wie z.B. Zuweisung oder bedingter  Anweisung,  ausgedrueckt,
aus denen Ag die Attributabhaengigkeiten und eine geeignete Auswertungsreihen-
folge ableitet.  Da die  Anweisungen  auch  Aufrufe  von  externen  Funktionen
enthalten  koennen,  wird  eine  Verwendung  von  in  der Zielsprache Modula-2
implementierten abstrakten Datentypen in der Attributgrammatik  moeglich,  die
in  getrennt  uebersetzbaren  Moduln definiert sind.  Die Attributberechnungen
koennen auch Seiteneffekte enthalten. Es ist  auszerdem  moeglich  kuenstliche
Attributabhaengigkeiten  zu  definieren,  um eine bestimmte Auswertungsreihen-
folge zu erzwingen, oder um bei einer Attributgrammatik die von Ag  geforderte
Eigenschaft  OAG  [Kastens80]  herbeizufuehren,  falls  sie  diese  noch nicht
besitzt.
  Der in Kapitel 5.2.2 beschriebene Erweiterungsmechanismus fuer die Attribute
und  Kindknoten  von  Knotentypen  gilt  auch  fuer  die Attributberechnungen.
Abgeleitete Knotentypen erben die Attributberechnungen ihrer Basistypen. Durch
Angabe  einer  speziellen  Attributberechnung  fuer den abgeleiteten Knotentyp
kann die vererbte Attributberechnung aber ueberschrieben werden.
____________________
1 Zur statischen Semantik einer Sprache gehoeren alle Eigenschaf-
  ten  eines  Programms,  die ohne eine Ausfuehrung des Programms
  abgeleitet werden koennen. Die dynamische Semantik  eines  Pro-
  gramms  dagegen umfaszt alle Eigenschaften, die nur durch seine
  Ausfuehrung bestimmt werden koennen.


                               60











5.4.2
       Abstrakte Datentypen

  Dieses Kapitel enthaelt eine kurze Beschreibung der  wichtigsten  abstrakten
Datentypen, die in der Attributgrammatik verwendet wurden.


5.4.2.1
         Spezifikation der Definitionstabelle und Bezeichneridentifikation

  Ast wurde im Uebersetzer Mtc nicht nur fuer die Implementierung  des  Struk-
turbaums  verwendet,  sondern auch fuer die Implementierung des Definitionsta-
bellenmoduls Defs.
  Fuer jedes im Modula-Programm deklarierte  Objekt  sowie  fuer  alle  vorde-
finierten  Objekte wird eine Objektbeschreibung angelegt, die alle vorhandenen
Informationen ueber das Objekt enthaelt.  Der Knotentyp Object1 definiert  die
Struktur der Objektbeschreibungen:

    Object          = [Ident: tIdent] <
      Const1        = -> [Value: tValue] .
      EnumLiteral1  = Type [Index: SHORTCARD] .
      Field1        = Type .
      Module1       = ExportList: Objects -> Objects Locals: Objects .
      Proc1         = Type -> [IsExported: BOOLEAN] Locals: Objects .
      ProcHead1     = Type .
      TypeDecl1     = -> Type .
      Var1          = Type [IsVAR: BOOLEAN] .
      ...
    >.

  Die Kindknoten bzw. Attribute, die rechts des Symbols -> stehen, werden  als
,,non-input''  Attribute  bezeichnet.  Die  Werte dieser Attribute werden beim
Aufbau  der  Objektbeschreibungen  noch  nicht  festgelegt;  es  wird   jedoch
Speicherplatz  fuer  sie reserviert, so dasz ihr Wert zu einem spaeteren Zeit-
punkt nachgetragen werden kann.  Das Attribut ExportList  ist  ein  Ausschnitt
der  vollstaendigen  Exportliste Objects eines Moduls und enthaelt nur die von
diesem Modul exportierten  Typnamen.  Die  Behandlung  einiger  Attribute  als
,,non-input''  Attribute  und  die ,,doppelte'' Exportliste sind notwendig, da
beim Aufbau der Objekt- und Typbeschreibungen zyklische  Abhaengigkeiten  auf-
treten,  die  durch einen schrittweisen Aufbau dieser Beschreibungen behandelt
werden.
  Betrachtet man den folgenden Ausschnitt eines Modula-Programms,  dann  sieht
man  sofort,  dasz  die  Typbaeume der abstrakten Syntax in Modula-2 fuer eine
Beschreibung der Typen innerhalb der  Definitionstabelle  nur  wenig  geeignet
sind:

    TYPE t1 = INTEGER; t2 = t1;
    VAR  v1 : t1; v2 : t2;
      ...
    v1 := v2;

  Die Typen der Variablen v1 und v2 sind identisch; aus den Typbaeumen fuer t1
und  t2  ist  dies  aber  nicht  direkt ablesbar.  Daher werden fuer die Typen
____________________
1 In der abgebildeten Definition der Objektbeschreibungen  fehlen
  die Attribute fuer die Codeerzeugung (s. Kap.  5.5)


                               61











Typbeschreibungen aufgebaut, deren Struktur - abgesehen  von  einigen  Verein-
fachungen  -  mit der Struktur der Typbaeume uebereinstimmt, in denen aber die
Typnamen durch die Typbeschreibung dieser Typen ersetzt sind.   Neben  Knoten-
typen  fuer die Typkonstruktoren von Modula-2 existieren auch Knotentypen fuer
die Repraesentation von Grund- und Standardtypen sowie  fuer  eine  Reihe  von
speziellen Typen, die nur intern im Uebersetzer verwendet werden und die keine
direkte Entsprechung in der Sprachdefinition von Modula-2 haben.
  Die Aufgabe der Bezeichneridentifikation ist es, jedem angewandten Auftreten
eines    Bezeichners    das    zugehoerige   Objekt   bzw.   die   zugehoerige
Objektbeschreibung zuzuordnen.  Die Sprachdefinition von Modula-2  legt  durch
ihre  Gueltigkeitsbereichsregeln  fest,  wie  die  Zuordnung  zu  treffen ist.
Modula-2 ist eine blockstrukturierte Sprache in der  die  Gueltigkeitsbereiche
der  Bezeichner  geschachtelt sind. Eine Definition eines Bezeichners in einem
inneren Block verdeckt die Definition dieses Bezeichners  in  einem  aeuszeren
Block.   In  Modula-2  kommt  zur  Blockstruktur  noch das Modulkonzept hinzu,
welches eine explizite Kontrolle der Gueltigkeitsbereiche von Bezeichnern  mit
Hilfe  von Import- und Exportanweisungen ermoeglicht.  Innerhalb der Attribut-
grammatik werden den Knotentypen der abstrakten Syntax bei  Bedarf  sogenannte
Umgebungsattribute  zugeordnet,  welche die an der jeweiligen Stelle gueltigen
Definitionen repraesentieren.  Die Struktur der Umgebungsattribute wird in der
Ast-Spezifikation durch den Knotentyp Env beschrieben:

    Env = Objects HiddenEnv: Env .

Objects sind die im aktuellen Block definierten  Objekte,  HiddenEnv  enthaelt
die in aeuszeren Bloecken definierten Objekte.
  Die Identifikation in der Attributgrammatik erfolgt  durch  den  Aufruf  der
ebenfalls im Modul Defs definierten Funktion

    Identify : Ident x Env -> Object .

die  jedem  Bezeichner  mit  Hilfe  des   gueltigen   Umgebungsattributs   das
zugehoerige Objekt zuordnet.


5.4.2.2
         Auswertung konstanter Ausdruecke und Repraesentation ihrer Werte

  Wie in Kapitel 4 erlaeutert, muessen fuer die Uebersetzung nach C die  Werte
einer Reihe von konstanten Ausdruecken bekannt sein. Zu diesem Zweck existiert
der Modul Values, welcher Typdeklarationen zur Repraesentation der  Werte  von
konstanten  Ausdruecken  und eine Operation fuer ihre Auswertung enthaelt. Den
Objektbeschreibungen der Konstanten  in  der  Definitionstabelle  und  einigen
Baumknoten  wie  z.B. den Fallmarken wird ein Attribut zugeordnet, welches den
Wert des zugehoerigen konstanten Ausdrucks repraesentiert. Die Funktion

    CompConst : Tree x Env -> Value .

die in der Attributgrammatik aufgerufen wird, berechnet aus dem Baum fuer  den
konstanten  Ausdruck  und der aktuell gueltigen Umgebung, die fuer den Zugriff
auf die Werte von benannten Konstanten benoetigt wird, den Wert des konstanten
Ausdrucks.
  Um den Aufwand fuer die Implementierung des  Moduls  Values  zu  reduzieren,
arbeitet  Values  nicht  interpretativ, sondern mit einer direkten Ausfuehrung
der Operationen. Die meisten moeglichen Fehler, wie etwa Division durch  Null,
werden  aber  durch  entsprechende  Abfragen abgefangen.  Arithmetische Ueber-
laeufe werden allerdings nicht erkannt. Eine Auswertung von  Ausdruecken,  die

                               62











ganzzahlige  Konstanten  im Bereich MAX(INTEGER)+1 .. MAX(CARDINAL) enthalten,
ist nicht moeglich. CompConst liefert in diesem Fall  aber  einen  definierten
Wert zurueck, der dies anzeigt.


5.4.2.3
         Operationen auf Typen

  Die Definition der Typbeschreibungen und die Prozeduren  fuer  ihren  Aufbau
sowie  Prozeduren  fuer  den  Zugriff  auf in den Typbeschreibungen enthaltene
Informationen sind Teil des Moduls Defs.
  Der Modul Types enthaelt alle weiteren Informationen  ueber  die  Typen  von
Modula-2.   Dabei handelt es sich insbesondere um Operationen fuer die Typbes-
timmung in Ausdruecken.
  Auszerdem enthaelt Types auch die meisten Details ueber  die  Abbildung  der
Typen  von  Modula-2  nach  C, wie sie fuer die Codeerzeugung, insbesondere im
Zusammenhang mit der Erzeugung von expliziten Typumwandlungen, benoetigt  wer-
den.   Die  in  Kapitel  4.4.1 erwaehnte Tabelle, die fuer eine Auswertung der
Standardfunktionen SIZE, TSIZE, MIN und MAX benoetigt wird, ist ebenfalls Teil
des Moduls Types.


5.4.3
       Die Attributgrammatik

  Die folgende Beschreibung der Attributgrammatik ist  nur  eine  auszugsweise
Darstellung einiger interessanter Aspekte dieser Attributgrammatik.  Eine aus-
fuehrliche Darstellung der Spezifikation der semantischen Analyse  mit  Attri-
butgrammatiken  und die Loesung von typischen Problemen in diesem Zusammenhang
kann in [Waite84] gefunden werden.


5.4.3.1
         Aufbau der Definitionstabelle und Berechnung von Umgebungsattributen

  In Modula-2 existieren eine Reihe von Regeln, die den Aufbau von Objekt- und
Typbeschreibungen  und  die  Berechnung von Umgebungsattributen erschweren und
die dazu fuehren, dasz die Objekt- und Typbeschreibungen nicht in einem einzi-
gen Schritt aufgebaut werden koennen, da dies zu zyklischen Abhaengigkeiten in
der Attributgrammatik fuehren wuerde.
  Neben den ,,rekursiven'' Typdeklarationen (s. Kap. 4.3) ist  hier  insbeson-
dere  die  Tatsache zu nennen, dasz in den Deklarationen eines Blocks Typnamen
verwendet werden koennen, die im gleichen Block  textuell  spaeter  deklariert
sind. Der Aufbau von Objektbeschreibungen fuer die in einem Block deklarierten
Objekte erfordert daher ein Umgebungsattribut zur Identifikation dieser Typna-
men.  Fuer  die Berechnung dieses Umgebungsattributs werden aber umgekehrt die
Objektbeschreibungen der in diesem Block deklarierten Objekte benoetigt.
  Die  Loesung  dieses  Problems  besteht  darin,  die   Objekt-   bzw.   Typ-
beschreibungen  schrittweise  aufzubauen und fuer die Deklarationen eine Reihe
von aufeinanderfolgenden Umgebungsattributen zu berechnen, die  jeweils  etwas
mehr Informationen ueber die deklarierten Objekte enthalten.
  Da die meisten  der  oben  genannten  Probleme  durch  die  Typdeklarationen
entstehen,  werden  zuerst vorlaeufige Objektbeschreibungen fuer die benannten
Typen und vollstaendige Typbeschreibungen fuer alle Typknoten  der  abstrakten
Syntax aufgebaut, die in den Objektbeschreibungen verwendet werden koennen.
  Zunaechst wird fuer die Deklarationen aller Bloecke  ein  Attribut  Objects1
berechnet,  welches  eine Liste von Objektbeschreibungen fuer Typen darstellt,

                               63











die im Prinzip als einzige Information die im entsprechenden Block  deklarier-
ten  Typnamen  enthaelt.  In  diese Objektliste werden fuer die Behandlung des
Modulkonzepts noch zusaetzlich Objektbeschreibungen der Moduln mit einer  vor-
laeufigen  Exportliste  aufgenommen,  die alle vom Modul exportierten Typnamen
umfaszt.  Die Behandlung des Modulkonzepts wird in einem der folgenden  Absch-
nitte  noch  naeher  erlaeutert.   Diese  Objektlisten  werden zu einem ersten
Umgebungsattribut Env1 kombiniert, welches in Typdeklarationen  die  Zuordnung
von  Objektbeschreibungen zu den Typnamen ermoeglicht.  Mit der Berechnung der
beiden Attribute Objects2 und Env2 wird  der  Prozess  des  Aufbaus  von  Typ-
beschreibungen  vervollstaendigt. Wie das im Detail funktioniert, wird im nae-
chsten Kapitel beschrieben.
  Jetzt  erst  kann  eine  Objektliste  Objects3  aufgebaut  werden,  die  die
vollstaendigen  Objektbeschreibungen  der  Typen,  Variablen,  Prozeduren  und
Moduln mit der kompletten Exportliste enthaelt.  Fuer die Konstanten fehlt  in
Objects3 noch der Wert der Konstanten, da hier ein aehnliches Problem wie fuer
die Typen auftritt. Zur Auswertung der Konstanten a in der folgenden  Deklara-
tion

    CONST b = 1;
    CONST a = b * 2;

wird der Wert der Konstanten b benoetigt. Hier sind in Modula-2  die  Probleme
im  Gegensatz  zu  den Typen nicht so grosz, da fuer die in Konstantendeklara-
tionen verwendeten Konstantennamen immer gelten musz, dasz  diese  Namen  tex-
tuell vor dieser Deklaration definiert sein muessen. Zyklische Abhaengigkeiten
der Konstantendeklarationen koennen daher in Modula-2 nicht auftreten.
  Mit der Objekliste Objects3 wird die Umgebung Env3 aufgebaut,  die  bis  auf
die Werte der Konstanten vollstaendig ist.
  Mit Hilfe der beiden Attribute Objects4In und Objects4Out wird  schlieszlich
fuer die Deklarationen aller Bloecke eine weitere Objektliste aufgebaut, wobei
die zu den Konstantendeklarationen dazugehoerigen konstanten Ausdruecke in der
textuellen  Reihenfolge  der Deklarationen mit Hilfe der Umgebung Env3 und der
Funktion CompConst ausgewertet werden. Die Werte der Konstanten  werden  dabei
in deren Objektbeschreibungen uebernommen.
  Mit der Objektliste Objects4Out kann jetzt die vollstaendige  Umgebung  Env4
berechnet  werden,  die  in  den Anweisungen fuer die Bezeichneridentifikation
verwendet wird.
  Vorstehend war die Rede  von  schrittweisem  Aufbau  der  Objekt-  und  Typ-
beschreibungen.   In  der Attributgrammatik werden selbstverstaendlich jeweils
neue Attribute berechnet, die den bei diesem schrittweisen Aufbau entstehenden
Teilergebnissen   entsprechen.   Durch  die  Moeglichkeit  von  kontrollierten
Seiteneffekten und dem Einsatz von Zeigertypen (abstrakte Datentypen) fuer die
Attributwerte, koennen aber vorhandene Beschreibungen erweitert werden.  Damit
entfaellt die Notwendigkeit mehrere Objekt- bzw.  Typbeschreibungen  fuer  das
gleiche  Objekt bzw. den gleichen Typ aufbauen und eventuell noch eine gemein-
same  Repraesentation  fuer  diese  finden  zu  muessen.  Auszerdem  wird  die
Implementierung  hinsichtlich  Laufzeit  und  Speicherbedarf  effizienter. Der
Nachteil dieser Loesung ist allerdings, dasz man sich wegen der  Seiteneffekte
ueber  die  Attributabhaengigkeiten  und  die  Auswertungsreihenfolge Gedanken
machen musz und eventuell geeignete Attribute und Attributabhaengigkeiten ein-
fuehren musz, die nur die Aufgabe haben, eine bestimmte Auswertungsreihenfolge
der Attribute  und  damit  eine  korrekte  Reihenfolge  der  Seiteneffekte  zu
erzwingen.


                               64











5.4.3.2
         Aufbau von Typbeschreibungen

  Allen Typknoten der abstrakten Syntax wird  in  der  Attributgrammatik  eine
Typbeschreibung  als  abgeleitetes  Attribut zugeordnet. Um die oben genannten
zyklischen Abhaengigkeiten der Typbeschreibungen behandeln zu koennen, erfolgt
deren Aufbau in zwei Schritten.  Das Attribut Type2 ist die vollstaendige Typ-
beschreibung;  ein  weiteres  Attribut  Type1   ist   eine   vorlaeufige   und
unvollstaendige  Typbeschreibung, welche waehrend des Aufbaus der vollstaendi-
gen Typbeschreibungen als Zwischenergebnis auftritt.
  Folgender Ausschnitt der  Attributgrammatik  demonstriert  den  Prozesz  des
Aufbaus von Typbeschreibungen (vgl. Anh. A):

    Type    = { Type2 AFTER Env2;                              } .
    Pointer = { Type1  := mPointer1 ();
                Type2  := mPointer2 (Type1, TargetType:Type2); } .
    TypeId0 = { Object := Identify (Ident, Env1);
                Type1  := mQualident1 (Object);
                Type2  := GroundType (Type1);                  } .

  Die oben  beschriebene  Umgebung  Env1  ermoeglicht  es,  den  Typnamen  die
zugehoerigen  Objektbeschreibungen  zuzuordnen, die allerdings noch keine Typ-
beschreibung fuer den Typ enthalten.  Qualident1 bildet eine vorlaeufige  Typ-
beschreibung  fuer  Typnamen, die einen Verweis auf die Objektbeschreibung des
Typnamens  enthaelt.   Fuer  andere  Typknoten  wird  eine  vorlaeufige   Typ-
beschreibung  angelegt,  die zwar der endgueltigen Typbeschreibung entspricht,
die aber nur die Information enthaelt, um welche Art von Typ es sich  handelt.
Die  uebrigen Informationen ueber den Typ, wie z.B. bei Zeigertypen der Bezug-
styp, werden als ,,non-input'' Attribute behandelt.
  In einem vollstaendigen Durchlauf durch  alle  Deklarationen  des  Programms
werden  die  vorlaeufigen  Typbeschreibungen Type1 in die Objektbeschreibungen
der benannten Typen aufgenommen (Berechnung des Attributs Objects2).  Objects2
wird  fuer die Berechnung eines zweiten ,,Umgebungsattributs'' Env2 verwendet,
dessen einzige Funktion es ist,  Attributabhaengigkeiten  zu  definieren,  die
garantieren,  dasz  die  vollstaendigen Typbeschreibungen Type2 erst berechnet
werden, wenn alle vorlaeufigen Typbeschreibungen in  die  Objektbeschreibungen
der benannten Typen eingetragen wurden. Wegen der kuenstlichen Attributabhaen-
gigkeit Type2 AFTER Env2 wird Type2 erst nach Env2 berechnet.
  Mit Hilfe der im Modul Defs definierten Funktion GroundType  kann  man  dann
aus  der  vorlaeufigen  Typbeschreibung  eines  Typnamens die endgueltige Typ-
beschreibung dieses Typs bestimmen. GroundType ist  folgendermaszen  definiert
(vereinfacht ohne Fehlerbehandlung):

    PROCEDURE GroundType    (Type: tType): tType;
    BEGIN
      IF Type^.Kind = Qualident1 THEN
        RETURN GroundType (Type^.Qualident1.Object^.TypeDecl1.Type);
      END;
      RETURN Type;
    END GroundType;

  Durch rekursive Aufrufe werden die Typ-  bzw.  Objektbeschreibungen  solange
traversiert  bis  eine  Typbeschreibung fuer einen Typnamen gefunden wird, die
keine vorlaeufige Typbeschreibung der Form Qualident1 ist  (Typgleichsetzungen
koennen ueber eine beliebige Anzahl von Stufen geschrieben werden). GroundType
liefert die so gefundene Typbeschreibung fuer den  Typnamen  an  den  Aufrufer

                               65











zurueck.
  Der  Aufbau  der   vollstaendigen   Typbeschreibung   Type2   erfolgt   dann
schlieszlich  dadurch,  dasz  die  noch  fehlenden Informationen, wie z.B. bei
Zeigertypen die Typbeschreibung des Bezugstyps TargetType:Type2, in  die  vor-
laeufige  Typbeschreibung  Type1  eingetragen wird.  Diese vollstaendigen Typ-
beschreibungen koennen dann bei der Berechnung des Attributs Objects3  in  die
Objektbeschreibungen  der  benannten Typen aufgenommen und als Typbeschreibung
in den Objektbeschreibungen der Variablen, Prozeduren, usf. verwendet werden.


5.4.3.3
         Behandlung des Modulkonzepts

  Zusaetzlich zur Blockstruktur ermoeglicht Modula-2 mit dem Modulkonzept eine
explizite  Kontrolle  des  Gueltigkeitsbereichs  von Bezeichnern durch Import-
bzw. Exportanweisungen. Eine wichtige Sonderregel in diesem Zusammenhang  ist,
dasz  mit  dem Import- bzw. Export eines Aufzaehlungstyps auch automatisch die
zugehoerigen Aufzaehlungsliterale importiert bzw. exportiert werden. Die  vor-
definierten  Objekte  von  Modula-2  muessen nicht explizit importiert werden,
sondern sind automatisch in jedem  Modul  sichtbar.  Bei  der  Behandlung  von
Implementierungsmoduln musz auszerdem beachtet werden, dasz alle im zugehoeri-
gen Definitionsmodul definierten Konstanten, Typen und Variablen im  Implemen-
tierungsmodul ebenfalls automatisch sichtbar sind.
  Der folgende Ausschnitt der Attributgrammatik zeigt, wie die oben  genannten
Regeln in der Attributgrammatik behandelt werden (vgl. Anh. A):

    ProgMod = { Import:Env2 := Env3;
                DefObjects3 := Filter (GetExport2 (Identify (Ident, Env3)));
                Decls:Env3  :=
                  mEnv (UNION (UNION (UNION (Predefs, Import:Objects2),
                        Decls:Objects3), DefObjects3), NoEnv);            } .
    From    = { Object2     := Identify (Ident, Env2);
                ImpIds:Env2 := mEnv (GetExport2 (Object2), NoEnv);
                Objects2    := UNION (ImpIds:Objects2, Next:Objects2);    } .
    ImpIds1 = { Object2     := Identify (Ident, Env2);
                Type        := GetType (Object2);
                Objects2    := {
              IF (Object2^.Kind = TypeDecl1   ) AND
                 (Type^.Kind    = Enumeration1) THEN
                Objects2    :=
                  mElmt (Ident, Object2, UNION (Type^.Enumeration1.Objects,
                         Next:Objects2));
              ELSE
                Objects2    := mElmt (Ident, Object2, Next:Objects2);
              END;          };                                            } .

  Das Attribut DefObjects3 ist eine Objektliste, welche die im  zum  Implemen-
tierungsmodul  dazugehoerigen  Definitionsmodul  definierten Konstanten, Typen
und Variablen enthaelt. Die Berechnung erfolgt dadurch, dasz in  der  Umgebung
des  Implementierungsmoduls  zunaechst  durch  einen  Aufruf  von Identify die
Objektbeschreibung des (Definitions-)Moduls bestimmt und aus dieser  dann  die
Liste  der exportierten Objekte entnommen wird. Da diese Exportliste zunaechst
noch die Definition von Prozedurkoepfen und opaquen  Typen  enthaelt,  die  im
Implementierungsmodul redeklariert werden muessen, wird mit Hilfe der im Modul
Defs definierten Funktion Filter eine neue Objektliste  aufgebaut,  die  diese
nicht mehr enthaelt.

                               66











  In einer Importanweisung der Form

    FROM Module IMPORT Object1, ... , Objectn;

ist die fuer den Bezeichner Module gueltige Umgebung, die Umgebung des Moduls,
der  die  Importanweisung  enthaelt.  Die  Umgebung der Bezeichner Object1 bis
Objectn ergibt sich aus der Liste der Objekte, die von Module exportiert  wer-
den.  Diese Tatsache wird im obigen Ausschnitt der Attributgrammatik durch die
Attributierungsregeln zur Berechnung der  Umgebungsattribute  Import:Env2  und
ImpIds:Env2 reflektiert.
  Die importierten Objekte werden in der Objektliste Objects2  gesammelt.  Die
Attributierungsregeln fuer den Knotentyp ImpIds1 zeigen dabei, wie der impliz-
ite Import von Aufzaehlungsliteralen behandelt wird.
  Die Umgebung Env3 der Deklarationen des Implementierungsmoduls  ergibt  sich
schlieszlich  aus  einer  Vereinigung  der vordefinierten Objekte Predefs, der
explizit importierten Objekte Import:Objects2, der  Objekte  aus  dem  Defini-
tionsmodul DefObjects3 und aus den lokal deklarierten Objekten Decls:Objects3.
Die Tatsache, dasz die aeuszere Umgebung eines  Moduls  vollstaendig  verdeckt
wird,  ist  aus der Verwendung der leeren Umgebung NoEnv als aeuszere Umgebung
des Moduls im Aufruf von mEnv zu entnehmen.


5.4.3.4
         Typbestimmung in Ausdruecken

  Den Ausdruecken wird ein abgeleitetes Attribut Type zugeordnet, welches  den
Typ des Ausdrucks beschreibt. Die Berechnung dieses Attributs erfolgt, wie der
folgende Beispielausschnitt der Attributgrammatik zeigt (vgl.   Anh.  A),  mit
Hilfe  der  in Types definierten Operationen auf Typen und den in Defs enthal-
tenen Operationen fuer den Zugriff auf Objekt- und Typbeschreibungen.

    Binary    = { Type := ResultType (Operator, Lop:Type, Rop:Type);  } .
    RealConst = { Type := TypeREAL;                                   } .
    Qualid0   = { Type := GetType (Object);                           } .
    Subscript = { Type := GetElemType (Designator:Type);              } .
    Deref     = { Type := GetTargetType (Designator:Type);            } .
    FuncCall  = { Type := {
                IF Designator:Type^.Kind = StdProcType1 THEN
                  Type := StdResultType (Designator:Type, Actuals:Types);
                ELSIF Designator:Type^.Kind = ProcType1 THEN
                  Type := GetResultType (Designator:Type);
                ELSE /* may be a type transfer function  */
                  Type := Designator:Type;
                END;   };                                             } .

  Die in Types definierte Funktion StdResultType ermittelt aus dem  Typ  einer
Standardprozedur  und  den  Typen  der aktuellen Parameter den Resultattyp des
Aufrufs dieser  Standardprozedur.  Die  Typen  der  aktuellen  Parameter  sind
notwendig,  da  ein  Teil  der Standardprozeduren wie z.B. ABS, MIN und MAX in
Modula-2 ueberladen sind.
  Die Typen der Ausdruecke werden fuer die Codeerzeugung  benoetigt,  um  z.B.
den korrekten C-Operator fuer ueberladene Modula-Operatoren einsetzen zu koen-
nen.




                               67











5.5
     Berechnung von Attributen fuer die Codeerzeugung

  Fuer die Durchfuehrung der Codeerzeugung muessen weitere Informationen ueber
das Quellprogramm abgeleitet werden, die ueber die in der semantischen Analyse
berechneten Attribute hinausgehen und die fuer eine korrekte Uebersetzung nach
C  benoetigt  werden.  Diese  Attributberechnungen  sind ebenfalls Teil der im
vorigen Kapitel beschriebenen Attributgrammatik.
  Zur besseren Gliederung der Attributgrammatik ermoeglicht  Ag  deren  Unter-
teilung  in  sogenannte  Moduln,  die  es  erlauben, logisch zusammengehoerige
Attributdeklarationen und die zugehoerigen Attributberechnungen auch  textuell
zusammenzufassen.   Daher  sind  die Attributberechnungen fuer die semantische
Analyse und die Berechnung von Attributen fuer die Codeerzeugung textuell ein-
deutig  getrennt.  Diese Trennung erleichtert eine eventuelle Wiederverwendung
des Front-Ends von Mtc.
  Die Trennung der Attributberechnungen in semantische Analyse und  Berechnung
von Attributen fuer die Codeerzeugung ist auf den ersten Blick teilweise etwas
willkuerlich, da z.B. die in der semantischen  Analyse  bestimmten  Typen  der
Ausdruecke  auch  fuer  die Codeerzeugung benoetigt werden. Die Unterscheidung
wurde aber auf folgender Basis getroffen: Alle Attribute, die  auch  benoetigt
wuerden,  falls  man  die  semantische Korrektheit der Modula-Programme ueber-
pruefen wollte, werden zur semantischen Analyse gezaehlt. Alle anderen  Attri-
bute,  die  ausschlieszlich  fuer  eine  Uebersetzung  nach  C notwendig sind,
zaehlen zu den Attributen fuer die  Codeerzeugung.  Im  Folgenden  sollen  die
wichtigsten dieser Attribute uebersichtsartig vorgestellt werden.
  Fuer die Operatoren der Sprache  Modula-2  ist  eine  Operatoridentifikation
notwendig,  da eine Reihe von Operatoren in Modula-2 ueberladen sind und daher
auf unterschiedliche C-Operatoren abgebildet werden muessen. Die  Knotentypen,
welche  die  Operatoren  als Attribute enthalten (vgl. Anh. A), erhalten daher
ein Attribut COperator, welches den zugehoerigen  C-Operator  beschreibt.  Die
Berechnung  dieses  Attributs  erfolgt  mit Hilfe des Modula-Operators und den
Typen der Operanden des zugehoerigen Ausdrucks.
  Wie in Kapitel 4 erlaeutert, musz fuer  eine  Reihe  von  Modula-Ausdruecken
bekannt  sein,  ob diese Ausdruecke in C konstant sind. Sie erhalten daher ein
boolesches Attribut IsCConst.
  Fuer die  Uebersetzung  des  Zugriffs  auf  lokale  Variablen  von  statisch
umfassenden  Prozeduren nach C (s. Kap. 4.4.4) existieren die folgenden Attri-
bute:
-
    Das boolesche Attribut IsGlobalPtr wird jedem  Bezeichner  in  Ausdruecken
    oder  Anweisungen  zugeordnet. Das Attribut ist wahr, falls der Bezeichner
    eine lokale Variable einer statisch umfassenden  Prozedur  bezeichnet  und
    daher der Zugriff in C mit Hilfe einer globalen Zeigervariablen realisiert
    werden musz.
-
    Das  Attribut  LocalPtrs,  welches  jeder  Deklaration  einer  Prozedur  p
    zugeordnet  wird,  ist  eine  Liste  aller lokalen Variablen von p, die in
    lokal zu p deklarierten Prozeduren benutzt werden.  Es wird benoetigt,  um
    fuer  die  nach C uebersetzte Prozedur p den entsprechenden Code fuer eine
    Realisierung des Zugriffs auf diese lokalen Variablen zu erzeugen.
-
    Programm- und Implementierungsmoduln wird ein Attribut GlobalPtrs zugeord-
    net,  welches  eine  Vereinigung  der Attribute LocalPtrs ist und fuer die
    Erzeugung der oben erwaehnten globalen Zeigervariablen benutzt wird.
  Die Uebersetzung der varianten Teile  der  Verbunde  nach  C  erfordert  die
Berechnung  von  zusaetzlichen  Komponentenselektoren  (s.  Kap. 4.4.2.7). Die
entsprechenden  Selektoren  werden  den  varianten  Teilen  der  Verbunde   im

                               68











Strukturbaum  zugeordnet und auch in die Objektbeschreibungen der zugehoerigen
Verbundkomponenten uebernommen, um  Zugriffe  auf  diese  Komponenten  korrekt
uebersetzen zu koennen.


5.5.1
       Umbenennung von Bezeichnern

  In Kapitel 4 wurde ausfuehrlich dargelegt, welche Bezeichner  im  C-Programm
fuer  die  Modula-Objekte verwendet werden. Es wurden im wesentlichen 2 Faelle
unterschieden:
-
    Der Bezeichner eines von einem globalen Modul exportierten Objekts wird in
    C in der qualifizierten Form Modulname_Bezeichner geschrieben.
-
    Alle uebrigen Bezeichner werden direkt aus dem  Modula-Programm  uebernom-
    men,  werden aber bei Bedarf zur Vermeidung von Namenskonflikten mit einem
    Praefix C_nnn_ versehen.
  In der Attributgrammatik wird  fuer  jedes  im  Modula-Programm  deklarierte
Objekt  ein Attribut CIdent berechnet, welches den C-Bezeichner dieses Objekts
darstellt. Dieser Bezeichner musz auch in die  Objektbeschreibung  uebernommen
werden,  um  bei  jedem angewandten Auftreten des Bezeichners den richtigen C-
Bezeichner einsetzen zu koennen.
  Zur Entdeckung und Vermeidung von moeglichen Namenskonflikten existiert  der
Modul UniqueIds, welcher die Verwaltung der im C-Programm verwendeten unquali-
fizierten Bezeichner entsprechend den Gueltigkeitsbereichsregeln der Sprache C
uebernimmt.   Qualifizierte  Bezeichner der Form Modulname_Bezeichner brauchen
nicht von UniqueIds verwaltet zu werden, da fuer sie auf Grund der  Eindeutig-
keit  von  globalen  Modulnamen  keine Namenskonflikte entstehen koennen.  Die
wichtigsten Operationen des Moduls UniqueIds sind:

    NameConflict : Ident x IdentClass x Idents -> BOOLEAN .
    DeclareIdent : Ident x IdentClass x Idents -> Idents .
    EnterProc    : Idents -> Idents .
    LeaveProc    : Idents -> Idents .

  NameConflict ueberprueft, ob die Verwendung eines bestimmten Bezeichners  zu
einem  Namenskonflikt mit einem bereits verwendeten Bezeichner fuehren wuerde.
DeclareIdent  deklariert  einen  Bezeichner  als  im   C-Programm   verwendet.
EnterProc  und  LeaveProc  werden  zu  Beginn  und  am Ende der Behandlung der
lokalen Deklarationen einer Prozedur aufgerufen.
  Die Bezeichner werden entsprechend ihrer Art bzw.  der Art des  zugehoerigen
Objekts in folgende Klassen eingeteilt (vgl. Kap. 4):
-
    Schluesselwoerter: UniqueIds behandelt  eine  Reihe  von  Bezeichnern  als
    Schluesselwoerter  (Bezeichner  fuer vom Uebersetzer vordefinierte Objekte
    und Schluesselwoerter der Sprache C).   NameConflict  liefert  fuer  einen
    Schluesselwortbezeichner  immer wahr, was dazu fuehrt, dasz der Bezeichner
    auf jeden Fall durch einen Praefix umbenannt wird.
-
    Konstanten-  und  Typbezeichner,  die  im   C-Programm   innerhalb   einer
    Quelldatei nur genau einmal auftreten duerfen.
-
    Prozedurbezeichner: alle Prozedurbezeichner sind in C globale Bezeichner.
-
    Bezeichner von Verbundkomponenten.
-
    Variablenbezeichner, die nicht in lokalen Moduln deklariert sind.
-
    Variablenbezeichner, die in lokalen Moduln deklariert sind.


                               69











  Die Variablen, die in einem in Modula-2 lokal zu einer Prozedur deklarierten
Modul  enthalten  sind,  werden  in C zu lokalen Variablen dieser Prozedur. Im
folgenden Beispiel

    PROCEDURE p;
      ...
    PROCEDURE q;
      MODULE l;
        ...
        VAR p: INTEGER;
        ...
      END l;
    BEGIN
      p;
    END q;

musz bei der Uebersetzung nach C die lokale Variable p (in C lokal zu  q  dek-
lariert)  umbenannt werden, da sonst der globale Prozedurbezeichner p im Rumpf
von q verdeckt wuerde. Aus diesem Grund werden in lokalen  Moduln  deklarierte
Variablen  von UniqueIds immer behandelt, als wuerde in C fuer diese Variablen
sowohl eine lokale Deklaration in der entsprechenden Prozedur  als  auch  eine
globale  Deklaration existieren.  Diese Behandlung fuehrt dazu, dasz im obigen
Beispiel die Variable p umbenannt wird,  da  im  gleichen  Gueltigkeitsbereich
bereits der Prozedurbezeichner p deklariert wurde.  Bei einer Behandlung von p
ausschlieszlich als lokale Variable von q wuerde kein Namenskonflikt entdeckt,
da  UniqueIds nur Informationen ueber die Deklaration der Bezeichner und nicht
auch ueber deren Anwendung enthaelt.  Fuer in Modula-2 lokal in einer Prozedur
deklarierte  Variablen kann das Problem nicht auftreten, da sowohl in Modula-2
als auch in C identische globale Bezeichner durch diese  Deklaration  verdeckt
werden.
  Die meisten Operationen des Moduls UniqueIds haben einen  Seiteneffekt.   In
der  Attributgrammatik  garantieren  die  beiden  Attribute  IdsIn und IdsOut,
welche die jeweils aktuelle  Menge  von  C-Bezeichnern  repraesentieren,  dasz
diese  Seiteneffekte  in  der  richtigen  Reihenfolge  ausgefuehrt  werden und
insbesondere, dasz der C-Bezeichner CIdent zum richtigen  Zeitpunkt  berechnet
wird.   Der  grosze  Vorteil  dieser  Loesung mit Seiteneffekten ist, dasz die
Operationen des Moduls UniqueIds sehr zeit- und speichereffizient programmiert
werden   koennen.    Insbesondere   ist  der  Aufwand  fuer  NameConflict  und
DeclareIdent in der Groeszenordnung O(1).


5.6
     Codeerzeugung

  Eingabe fuer  die  Codeerzeugung  ist  der  attributierte  Strukturbaum  des
Modula-Programms,  der  alle  fuer  die Uebersetzung nach C notwendigen seman-
tischen Informationen enthaelt. Die  Ausgabe  der  Codeerzeugung  ist  ein  C-
Programm bzw. eine C-Definitionsdatei fuer die aktuelle Uebersetzungseinheit.
  Durch Angabe einer Option  kann  man  Mtc  dazu  veranlassen,  auch  Defini-
tionsdateien  fuer  alle transitiv importierten Definitionsmoduln zu erzeugen.
Diese Option ist insbesondere dann nuetzlich, wenn man - z.B. fuer  Testzwecke
-  zunaechst  nur  einen  einzelnen Implementierungs- oder Programmodul nach C
uebersetzen und diesen dann vom C-Uebersetzer  in  ein  Objektprogramm  ueber-
setzen  lassen  moechte.   Fuer diese Uebersetzung benoetigt der C-Uebersetzer
die Definitionsdateien  aller  transitiv  importierten  Definitionsmoduln,  da
diese  mit #include-Anweisungen in das C-Programm eingefuegt werden. Durch die
oben genannte Option wird es  ueberfluessig  diese  Definitionsmoduln  einzeln

                               70











nach  C  zu  uebersetzen;  insbesondere  braucht man nicht muehsam abzuleiten,
welche (Definitions-)Moduln denn tatsaechlich importiert werden.


5.6.1
       Spezifikation des Codegenerators

  Der Codegenerator, der im Modul Code enthalten ist, wurde mit Hilfe des Gen-
erators  Estra [Vielsack89] aus einer formalen Spezifikation der Codeerzeugung
generiert. Estra ist ein Werkzeug fuer die Spezifikation  und  Implementierung
der  Transformation  von attributierten Baeumen. Im Folgenden wird kurz darauf
eingegangen,  wie  eine  solche  Spezifikation  und  die  daraus   abgeleitete
Implementierung  im Prinzip aussehen. Die Spezifikation der Codeerzeugung wird
nicht im Detail eroertert, da es sich dabei lediglich um eine Umsetzung der in
Kapitel  4  verbal beschriebenen Abbildung von Modula-2 nach C in eine formale
Spezifikation fuer Estra handelt.
  Die Beschreibung der Transformation besteht im wesentlichen aus zwei Teilen:
Einer  Baumgrammatik,  welche  die  Struktur  der  zu transformierenden Baeume
beschreibt und einer oder mehreren Funktionen, die die  Abbildung  der  Baeume
beschreiben. Eine Funktion besteht aus der Festlegung des Definitionsbereichs,
aus einer Angabe  von  synthetisierten  und  vererbten  Attributen  sowie  aus
Vorschriften  wie  die  Transformation  durchgefuehrt werden soll. Der Defini-
tionsbereich legt fest, auf welche Knotentypen die Funktion anwendbar ist. Die
Vorschriften,  die  die  Abbildung  im Einzelnen festlegen, bestehen aus einem
Muster, welches  angibt  auf  welche  Teilbaeume  die  betreffende  Vorschrift
angewandt  werden  kann  und  aus  Anweisungen, die festlegen wie der Teilbaum
behandelt werden soll. Diese  Anweisungen  koennen  insbesondere  Aufrufe  von
Funktionen  fuer  die  Transformation  von Unterbaeumen enthalten. Die Anwend-
barkeit bestimmter Vorschriften kann durch Bedingungen eingeschraenkt  werden.
Damit  wird  es  moeglich,  die vom Attributauswerter berechneten semantischen
Informationen fuer die  Festlegung  der  Transformation  zu  beruecksichtigen.
Fuer eine Aufloesung von Mehrdeutigkeiten dient die Angabe von Kosten fuer die
Anwendung von Vorschriften. Werden diese Kosten  durch  eine  Konstante  fest-
gelegt,  so  ergeben  sich  die  Kosten der Anwendung einer Vorschrift aus der
Summe dieser Konstanten und den Kosten der Funktionsaufrufe fuer die Transfor-
mation der Unterbaeume, die in den Anweisungen enthalten sind. Wird dies nicht
gewuenscht, so besteht auch die Moeglichkeit die Kosten durch  einen  Ausdruck
der  Quellsprache  (in  geschweiften  Klammern)  direkt  festzulegen.  Bei der
Transformation wird immer die kostenguenstigste Vorschrift angewandt.
  Folgender Ausschnitt der Funktion fuer die Spezifikation  der  Codeerzeugung
fuer Ausdruecke soll obenerwaehntes noch einmal erlaeutern:

    FUNCTION CodeExpr  Prec: SHORTCARD  ->  /Expr, Elems/
      ...
    Subscript   (Qualid0 (), Index: Expr)
                CONDITION { IsOpenArray (Qualid0.Object) }
                COSTS { 1 }
    {
        CodeExpr (Qualid0, pSubscript); @[@ CodeExpr (Index, pMinPrec); @]@
    }
      ...

  Das vererbte Attribut Prec ist der C-Vorrang des Operators im  Vaterausdruck
und wird benoetigt, um die Ausdruecke in C korrekt zu klammern.  Da die Index-
operation in C den hoechsten Vorrang hat, ist in obigem  Beispiel  eine  Klam-
merung nicht notwendig. Die Bedingung in der Vorschrift schraenkt ihre Anwend-
barkeit auf offene Felder ein (vgl. Kap.  4.5.1). Die  Anweisungen  legen  die

                               71











Abbildung  des  Zugriffs auf offene Felder fest und enthalten Funktionsaufrufe
fuer die Transformation der Unterbaeume.  @[@ ist eine  Anweisung  fuer  einen
Praeprozessor,  der  fuer  eine  bessere  Lesbarkeit der Spezifikation und zur
Vereinfachung der Schreibweise fuer Anweisungen zur Ausgabe von C-Programmtext
mit  Hilfe  des Zeileneditors sed implementiert wurde, die in WriteC (f, '[');
umgesetzt wird.
  Da die meisten Attribute bereits  vom  Attributauswerter  berechnet  werden,
wird  von  der  von Estra angebotenen Moeglichkeit fuer die Attributierung nur
wenig  Gebrauch  gemacht.  Eine  unterschiedliche  Transformation   bestimmter
Knotentypen, abhaengig vom Ort des zugehoerigen Teilbaums, wie z.B. die unter-
schiedliche   Abbildung   von   Deklarationen   in   Definitionsmoduln    bzw.
Implementierungs-  und  Programmoduln  (s.  Kap.  4.8) oder auch die mehrfache
Transformation eines Teilbaums auf unterschiedliche Art  und  Weise,  wie  sie
z.B.  fuer  die Umordnung der Deklarationen (s. Kap. 4.3) benoetigt wird, wird
dadurch erreicht, dasz fuer  jede  dieser  unterschiedlichen  Transformationen
eine  eigene  Funktion  existiert, die dann an den entsprechenden Stellen auf-
gerufen wird.
  Die Spezifikation des Codegenerators wird von Estra in eine  Implementierung
umgesetzt.  Diese  Implementierung fuehrt die Transformation in zwei Schritten
durch. Zunaechst wird  in  einem  vorbereitenden  Schritt  festgelegt,  welche
Vorschriften  fuer  die  Transformation des vorhandenen Baums anzuwenden sind.
Dazu wird bei einem Bottom-Up-Baumdurchlauf geprueft, welche Muster auf welche
Knoten  (Teilbaeume) passen und ob die zugehoerigen Bedingungen erfuellt sind.
Fuer  jede  existierende  Funktion  wird  aus  den  anwendbaren   Vorschriften
diejenige  mit  den  geringsten  Kosten ausgewaehlt und im Knoten zusammen mit
ihren Kosten festgehalten. Die eigentliche  Durchfuehrung  der  Transformation
erfolgt  im zweiten Schritt durch Anwendung der ersten Funktion auf die Wurzel
des Baums. Die Transformation erfolgt  dann  unter  Beruecksichtigung  der  im
ersten   Schritt  festgelegten  Vorschriften  durch  Ausfuehrung  der  in  den
Anweisungen dieser Vorschriften enthaltenen Funktionsaufrufe  fuer  die  Teil-
baeume.


5.6.2
        Nachoptimierung des Codegenerators

  Estra ist ein im Rahmen einer Diplomarbeit entwickelter Prototyp. Die  Spez-
ifikation  des  Codegenerators  von  Mtc war die erste groeszere Anwendung von
Estra und es lagen aus diesem Grund bisher noch keine praktischen  Erfahrungen
mit  groszen  Anwendungen  vor.  Nachdem  eine  erste (Teil-)Spezifikation der
Codeerzeugung vorlag, ergaben Tests, dasz der von Estra aus dieser  Spezifika-
tion  erzeugte  Codegenerator  einen  extrem  hohen Speicherbedarf besasz, der
trotz der heutigen relativ groszen Hauptspeichergroeszen  fuer  grosze  Einga-
beprogramme  einen  Trashing-Effekt  zur  Folge hatte. Der hohe Hauptspeicher-
bedarf ergibt sich daraus, dasz der Codegenerator  bei  der  Vorbereitung  der
Transformation (s. Kap. 5.6.1) in jedem Knoten fuer jede existierende Funktion
die anwendbare Vorschrift (4 Byte) und die  Kosten  fuer  diese  Anwendung  (4
Byte)  ablegt.  Die  erste Version der Spezifikation der Codeerzeugung bestand
aus ca. 40 Funktionen, d.h. fuer jeden Baumknoten wurden etwa 320 Byte  dynam-
ischer Speicher angefordert.
  Um die Codeerzeugung nicht doch noch aus praktischen Gruenden  ,,von  Hand''
programmieren  zu  muessen, war es notwendig, diesen Speicherbedarf durch eine
Veraenderung der Spezifikation und durch eine automatische Nachoptimierung des
von Estra erzeugten Codegenerators zu reduzieren.
  Ein erster Schritt zur Reduktion des Speicherbedarfs  war,  die  Anzahl  der
Funktionen  in der Spezifikation und damit die in jedem Knoten abgelegte Menge

                               72











von Informationen zu reduzieren. Dies ist  aber  aus  den  folgenden  Gruenden
nicht unbegrenzt moeglich bzw. sinnvoll:
-
    Fuer bestimmte Knotentypen muessen verschiedene Funktionen existieren,  da
    sie  wie  oben  beschrieben  mehrfach  auf  unterschiedliche Art und Weise
    transformiert werden muessen.
-
    Eine gewuenschte Modularisierung der Spezifikation fuer  Zwecke  der  Ver-
    staendlichkeit  und  Wartbarkeit laeszt es nicht sinnvoll erscheinen, eine
    Spezifikation von mehreren tausend  Zeilen  mit  einer  einzigen  Funktion
    festzulegen, selbst wenn dies theoretisch moeglich waere.
-
    Beim Einsatz von Attributen sind in der Regel  fuer  verschiedene  Knoten-
    typen  auch  unterschiedliche  Attribute und somit verschiedene Funktionen
    notwendig.
Soweit dies logisch vertretbar erschien,  wurden  einzelne  Funktionen  zusam-
mengefaszt,  so  dasz die endgueltige Spezifikation der Codeerzeugung nur noch
aus 22 Funktionen besteht.  Allerdings hat sich die Lesbarkeit der  Spezifika-
tion durch diese Zusammenfassung verschlechtert.
  Ein Ansatz fuer eine automatische Nachoptimierung ergab sich  aus  folgender
Ueberlegung:  Die  Kosten werden von Estra dazu benutzt, die kostenguenstigste
Vorschrift auszuwaehlen. Die Kosten fuer die Transformation eines  Baumknotens
haengen  dabei im allgemeinen - wie es z.B. in Codegeneratoren fuer Maschinen-
sprache sinnvoll ist - von  den  Kosten  fuer  die  Transformation  beliebiger
Unterbaeume  ab.  Daher  muessen  die  Kosten fuer die Anwendung der einzelnen
Vorschriften im Baum abgelegt werden.  Fuer eine Abbildung des  attributierten
Strukturbaums  nach  C  kann  man aber immer bereits lokal an einem bestimmten
Knoten entscheiden, wie dieser nach C abzubilden ist, ohne dabei die Abbildung
der  Unterbaeume  bzw.  deren  Kosten beruecksichtigen zu muessen.  Die Kosten
werden fuer eine Abbildung nach C nur benoetigt, um bei der  Vorbereitung  der
Transformation  fuer  jeden  Knoten  lokal  die  kostenguenstigste  Vorschrift
auswaehlen zu koennen.  Aus diesem Grund wuerde  es  voellig  ausreichen,  die
Kosten,  anstatt  sie  im  Baum  abzuspeichern, in einer lokalen Variablen der
Besuchsprozedur  abzulegen,  die  die  Transformation  vorbereitet.  Nur   die
Vorschrift  selbst mueszte dann noch im Baum gespeichert werden, um im zweiten
Schritt die Transformation durchfuehren zu koennen.
  In der Spezifikation wurden alle Kosten so festgelegt, dasz die  Kosten  der
Transformation  eines  bestimmten  Knotens  nicht  mehr  von  den  Kosten  der
Transformation der Kindknoten (Unterbaeume) abhaengen. Mit Hilfe des Zeilened-
itors  sed  wurde der von Estra erzeugte Codegenerator - wie oben angedeutet -
automatisch nachoptimiert. Das dafuer verwendete Sed-Skript ist  relativ  ein-
fach  und umfaszt nur ca. 40 Zeilen. Besonders wichtig ist, dasz diese Nachop-
timierung ohne Eingreifen des Benutzers automatisch durchgefuehrt werden kann,
da es keinesfalls sinnvoll waere, ein von einem Uebersetzerbauwerkzeug generi-
ertes Programm noch nachtraeglich  ,,von  Hand''  nachzuoptimieren,  was  dann
selbstverstaendlich bei jeder noch so kleinen Aenderung der Spezifikation dur-
chgefuehrt werden mueszte.
  Durch die  oben  beschriebenen  Masznahmen  konnte  der  Speicherbedarf  der
endgueltigen  Version  des Codegenerators auf etwa 1/4 des Speicherbedarfs der
ersten  Version  reduziert  werden.   Der  Trashing-Effekt  tritt  daher  fuer
Modula-Programme  in  praktisch vorkommenden Groeszen nicht mehr (so stark) in
Erscheinung.  Im naechsten Kapitel wird bei der Bewertung  der  Werkzeuge  ein
Vorschlag gemacht, wie Estra unter Ausnutzung von in der Spezifikation enthal-
tenen Informationen den Speicherbedarf auf allgemeine Weise  drastisch  reduz-
ieren koennte.



                               73











5.7
     Fehlerbehandlung

  Lexikalische Fehler wurden in der  Spezifikation  des  Symbolentschluesslers
beruecksichtigt und werden daher vom Uebersetzer behandelt und gemeldet.
  Wie in Kapitel 5.2.1  besprochen,  besitzt  der  generierte  Zerteiler  eine
automatische  Fehlerbehandlung.  Dem Benutzer werden daher syntaktische Fehler
und die vom Zerteiler durchgefuehrte Fehlerreparatur gemeldet.
  Bei der Behandlung der getrennten  Uebersetzung  koennen  zwei  Fehler  auf-
treten, die vom Uebersetzer gemeldet werden:
-
    Ein fuer die Uebersetzung der aktuellen  Uebersetzungseinheit  benoetigter
    Definitionsmodul kann nicht gefunden werden.
-
    Es existieren - in Modula-2 verbotene - zyklische Abhaengigkeiten zwischen
    den Definitionsmoduln.
  Tritt waehrend der lexikalischen und  syntaktischen  Analyse  oder  bei  der
Behandlung der getrennten Uebersetzung ein Fehler auf, dann wird die Ueberset-
zung nach der entsprechenden Uebersetzerphase abgebrochen.   Da  die  aktuelle
Uebersetzungseinheit  und die Definitionsmoduln aus verschiedenen Quelldateien
stammen, enthalten die Fehlermeldungen neben der Angabe von Zeile  und  Spalte
im Quelltext auch immer den Namen der zugehoerigen Quelldatei.
  Wie bereits besprochen, soll die  semantische  Korrektheit  der  Eingabepro-
gramme  vom  Uebersetzer nicht ueberprueft werden.  Natuerlich ist es trotzdem
moeglich, dasz ein semantisch falsches Programm als  Eingabe  auftritt.  Daher
muessen moegliche semantische Fehler, wie z.B. eine bei der Bezeichneridentif-
ikation entdeckte fehlende Deklaration fuer einen Bezeichner, zumindest intern
behandelt  werden, auch wenn solche Fehler dem Benutzer nicht gemeldet werden.
Fuer die Behandlung dieser Fehler wird eine fuer Attributgrammatiken  uebliche
Technik   angewandt:  Fuer  die  Attributtypen  werden  spezielle  Fehlerwerte
eingefuehrt, welche im Fehlerfall von den entsprechenden Operationen  zurueck-
geliefert  werden. Auszerdem erfolgt der Zugriff auf semantische Informationen
wie z.B. die Typ- und Objektbeschreibungen nicht direkt, sondern  durch  spez-
ielle  Zugriffsoperationen,  die ueberpruefen, ob die Beschreibungen bestimmte
semantische Bedingungen erfuellen und die bei Nichterfuellung der  Bedingungen
entsprechende Fehlerwerte zurueckliefern.
  Fuer semantisch falsche Programme wird aber in jedem  Fall  C-Code  erzeugt.
Allerdings  sind  diese C-Programme in 95% der Faelle entweder semantisch oder
meist sogar syntaktisch  fehlerhaft  und  daher  wird  in  der  Regel  der  C-
Uebersetzer  entdecken,  dasz  die urspruenglichen Modula-Programme fehlerhaft
waren.
  Falls eines der vom Uebersetzer nicht  unterstuetzten  Modula-Konstrukte  im
Quellprogramm auftritt, wird dies von der Codeerzeugung gemeldet.


5.8
     Umfang der Implementierung des Uebersetzers

  Tabelle 5.3 zeigt den Umfang der fuer die Implementierung  des  Uebersetzers
Mtc verwendeten Spezifikationen und den Umfang der Quellmoduln, die aus diesen
Spezifikationen erzeugt wurden.






                               74











_____________________________________________________________________________________________
   Uebersetzerteil                Spezifikation                   Erzeugter Quellmodul
_____________________________________________________________________________________________
                        Formaler Teil   Quellcode   Summe   Def.-Modul   Impl.-Modul   Summe
_____________________________________________________________________________________________
 Symbolentschluessler        392           133       525         56          1320       1376
 Zerteiler                   934            87      1021         80          2918       2998
 Strukturbaum                189            51       240        579          3234       3813
 Definitionstabelle          118           985      1103        417          1549       1966
 Attributauswerter          2071           159      2230          9          3591       3600
 Codegenerator              2775          1030      3805         50          7448       7498
_____________________________________________________________________________________________
 Summe                      6479          2445      8924       1191         20060      21251
_____________________________________________________________________________________________










                     









                                                         









                                                                                            











               Tabelle 5.3: Umfang der Spezifikationen und der
                    daraus erzeugten Quellmoduln in Zeilen

Die Zahlen fuer den Codegenerator beziehen sich auf  die  nachoptimierte  Ver-
sion.  Vor der Nachoptimierung betraegt seine Groesze 7571 Zeilen.
  Tabelle 5.4 zeigt Umfang (in Zeilen) und Anzahl der Moduln,  aus  denen  Mtc
besteht,  wobei  unterschieden  wird  zwischen  aus  Spezifikationen erzeugten
Moduln, Bibliotheksmoduln und ,,von Hand'' programmierten Moduln.


           _______________________________________________________
                     Uebersetzermoduln            Anzahl   Umfang
           _______________________________________________________
            Aus Spezifikationen erzeugte Moduln      6     21251
            Bibliotheksmoduln                       18      3541
            ,,Von Hand'' programmierte Moduln       11      3871
           _______________________________________________________
            Summe                                   35     28663
           _______________________________________________________
          




                                               




                                                        




                                                                 






              Tabelle 5.4: Umfang und Anzahl der Moduln von Mtc

  Wie die beiden obigen Tabellen zeigen, besteht der  ueberwiegende  Teil  des
Uebersetzers  Mtc aus Moduln, die mit Hilfe von Werkzeugen aus Spezifikationen
erzeugt wurden und aus wiederverwendbaren Bibliotheksmoduln. Nur  ein  relativ
kleiner  Teil  des  Uebersetzers besteht aus Moduln, die ausschlieszlich ,,von
Hand'' programmiert sind. Betrachtet man den gesamten  Umfang  von  Mtc,  dann
wird  klar, dasz die Implementierung eines Programms dieses Umfangs und dieser
Komplexitaet ohne den Einsatz von Werkzeugen und  wiederverwendbarer  Software
kaum im Rahmen einer Diplomarbeit moeglich gewesen waere.



6.
    Praktische Ergebnisse

6.1
     Test und erste Einsaetze des Uebersetzers

  Da schon seit mehreren Jahren an  der  GMD  Forschungsstelle  Karlsruhe  die
Sprache Modula-2 und der Uebersetzer MOCKA eingesetzt werden, bestand an Test-
programmen fuer den Uebersetzer Mtc kein Mangel.  Anfaenglich noch  vorhandene
Schwaechen in der Abbildung von Modula-2 nach C, insbesondere solche urspruen-
glich  nicht  beruecksichtigten  Spezialfaelle,  wie  die  in  Kapitel   4.2.2
beschriebenen  Probleme  bei der Abbildung von groszen ganzzahligen Konstanten

                               75











oder  von  Zeichenkonstanten,  konnten  daher  relativ  schnell  entdeckt  und
beseitigt werden.
  Der erste grosze Test des Uebersetzers Mtc, der auch  mit  dem  Betreuer  zu
Beginn  der Diplomarbeit als Abnahmetest vereinbart worden war, war die Ueber-
setzung von Mtc selbst nach C. Dieser Test wurde von Mtc erfolgreich  absolvi-
ert,  so  dasz Mtc jetzt sowohl in der urspruenglichen Modula-Version als auch
in einer daraus erzeugten C-Version vorliegt.
  Wichtigster und anspruchsvollster Test von  Mtc  war  die  Uebersetzung  des
Modula-Uebersetzers MOCKA nach C.
  Das erste dabei auftretende Problem war, dasz MOCKA eine  Moeglichkeit  fuer
eine  bedingte Uebersetzung mit Hilfe von Uebersetzerschaltern besitzt, die in
den Quellen von MOCKA verwendet wird,  um  die  verschiedenen  MOCKA-Versionen
fuer  unterschiedliche Zielmaschinen zu verwalten. Diese bedingte Uebersetzung
wird von Mtc nicht unterstuetzt. Die MOCKA-Versionen fuer die  SUN-  und  PCS-
Workstations  muszten  daher erst aus den Quellen mit den Uebersetzerschaltern
erzeugt werden. Dies konnte allerdings automatisch mit Hilfe des Zeileneditors
sed durchgefuehrt werden.
  Das zweite auftretende Problem war, dasz von MOCKA eine im  Benutzerhandbuch
nicht  dokumentierte, aber in den Quellen benutzte Spracherweiterung vorgenom-
men wird: MOCKA erlaubt es das Zeichen _ in Bezeichnern wie  einen  Buchstaben
zu  verwenden. Daraufhin wurde die Spezifikation des Symbolentschluesslers von
Mtc so erweitert, dasz Mtc diese Spracherweiterung auch akzeptiert. Allerdings
kann  es  jetzt, da die Umbenennung von Bezeichnern davon ausgeht, dasz dieses
Zeichen in Modula-Bezeichnern  nicht  vorkommt,  in  unguenstigen  Faellen  zu
Namenskonflikten  in  den  erzeugten  C-Programmen  kommen. Bei Verwendung des
Zeichens _ in Bezeichnern gibt Mtc daher eine entsprechende Warnung aus.
  Ein weiteres Problem trat an den PCS-Workstations auf.  Der  Modul  SuValues
enthaelt Konstantendeklarationen der Form

    CONST UPBdiv8 = MaxLongCard DIV 8;
    CONST UPBmod8 = MaxLongCard MOD 8;

wobei MaxLongCard den Wert MAX(LONGCARD)  hat.  Trotz  der  in  Kapitel  4.2.2
besprochenen  Typumwandlungen  ist  der C-Uebersetzer nicht in der Lage, diese
Konstanten korrekt auszuwerten, da offensichtlich intern nur  mit  long-Werten
gerechnet  und  Ueber-  bzw.  Unterlauf  nicht erkannt wird.  Diese Konstanten
muszten daher an den PCS-Workstations in den C-Programmen  ,,von  Hand''  aus-
gewertet und eingesetzt werden. Der C-Uebersetzer der Firma SUN ist dagegen in
der Lage, diese konstanten Ausdruecke korrekt auszuwerten. Mtc gibt jetzt  bei
der  Verwendung  einer Konstanten im Bereich von MAX(INTEGER)+1..MAX(CARDINAL)
eine entsprechende Warnung ab.
  Das letzte auftretende Problem war folgender Typtransfer im Modul CgMobil:

    GenLongIntMode (SHORTINT (0FFFFH), LowWordMaskOp);

Der erste formale Parameter von GenLongIntMode hat den Typ LONGINT.  Der  Wert
des  aktuellen Parameters nach der Uebergabe ist in Modula-2 65535. Die Ueber-
setzung nach C liefert

    GenLongIntMode((SHORTINT)0XFFFF, &LowWordMaskOp);

In C ist der Wert des aktuellen Parameters  nach  der  Uebergabe  -1.  In  den
erzeugten  C-Programmen  muszte daher die Typumwandlung entfernt werden, damit
MOCKA auch in C korrekt funktioniert. Da  der  Wert  0FFFFH  (=MAX(SHORTCARD))

                               76











eigentlich  als  SHORTINT-Wert  ueberhaupt nicht darstellbar ist und auszerdem
der Typtransfer keine erkennbare Funktion hat, scheint die obige  Konstruktion
aber  prinzipiell  fragwuerdig  zu  sein und sollte aus den Modula-Quellen von
MOCKA entfernt werden.
  Nach der  Beseitigung  der  obengenannten  Probleme  lag  auch  der  Modula-
Uebersetzer  MOCKA  sowohl  auf  den PCS- als auch auf den SUN-Workstations in
einer  C-Version  vor  und  wurde  auch  bereits  fuer  die  Uebersetzung  von
zahlreichen Modula-Programmen wie z.B.  Mtc und MOCKA eingesetzt.
  Neben den beiden obengenannten  groszen  Testfaellen  wurden  noch  folgende
Modula-Programme  mit  Mtc  nach C uebersetzt: Der Minilax-Uebersetzer aus dem
Uebersetzerbaupraktikum,  die  komplette  Bibliothek  Reuse,  die  Standardbi-
bliothek  des  Uebersetzers  MOCKA  sowie  ein  mit dem Zerteilergenerator PGS
[Klein86] erzeugter Zerteiler, der starken Gebrauch  vom  Zugriff  auf  lokale
Variablen  von  statisch  umfassenden  Prozeduren macht und daher als Testfall
ausgewaehlt  wurde.   Insgesamt  wurden  vom  Verfasser  dieser   Diplomarbeit
Modula-Programme mit einem Gesamtumfang von etwa 80000 Zeilen erfolgreich nach
C uebertragen.
  Vom Betreuer dieser Diplomarbeit Dr. J. Grosch wurden auszerdem waehrend der
Anfertigung dieser schriftlichen Ausarbeitung die Uebersetzerbauwerkzeuge Rex,
Lalr und Ell erfolgreich nach C  uebertragen.   Diese  Programme  haben  einen
Umfang von etwa 35000 Zeilen Modula-Code.
  Die erzeugten C-Programme wurden bisher an den folgenden Maschinen getestet:
PCS-  und  SUN-Workstations  (MC68020-Prozessor),  DEC  VAX  8530 und DEC 3100
(MIPS-Prozessor) und sind daher als gut portabel anzusehen.


6.2
     Groesze, Laufzeit und Speicherbedarf des Uebersetzers

  Saemtliche Messungen in diesem und den folgenden Abschnitten wurden an einer
SUN-Workstation  (MC68020-Prozessor,  20 MHZ Taktfrequenz) durchgefuehrt. Alle
Angaben fuer den Uebersetzer Mtc beziehen  sich  auf  die  Modula-Version  des
Uebersetzers.
  Die Groesze des ausfuehrbaren Objektprogramms  von  Mtc,  gemessen  mit  dem
size-Kommando [UNIX79], kann Tabelle 6.1 entnommen werden.

                       _______________________________
                         Text    Data   Bss    Summe
                       _______________________________
                        294912   8192   6344   309448
                       _______________________________
                      

                              

                                     

                                            

                                                     


           Tabelle 6.1: Groesze des Objektprogramms von Mtc in Byte

  Tabelle 6.2 enthaelt Laufzeit und Leistung von Mtc fuer die Uebersetzung des
Modula-Uebersetzers  MOCKA,  der  aus  35  Moduln besteht, die insgesamt 37792
Zeilen Modula-Code umfassen. Die Laufzeit wurde gemessen mit dem time-Kommando
[UNIX79] und ist die Summe aus User- und System-Zeit.








                               77











             ____________________________________________________
              Messung   Laufzeit             Leistung
                          [s]      [Zeilen/s]   [Grundsymbole/s]
             ____________________________________________________
                 A        303         125             496
             ____________________________________________________
                 B        255         148             589
             ____________________________________________________
            



                     



                                



                                             


                                                                





             Tabelle 6.2: Laufzeit und Leistung von Mtc fuer die
                            Uebersetzung von MOCKA

Bei der Messung A wurde jeder Definitions-, Implementierungs- und Programmodul
einzeln   nach   C   uebersetzt.   Bei  der  Messung  B  wurde  Mtc  nur  fuer
Implementierungs- und Programmoduln aufgerufen und bei jedem Uebersetzungsvor-
gang  mit  Hilfe  der  in Kapitel 5.6 erwaehnten Option die Definitionsdateien
aller transitiv importierten Definitionsmoduln ausgegeben. Die Laufzeit  (Mes-
sung A) verteilt sich folgendermaszen auf die einzelnen Uebersetzerphasen:
                          Parse                  19%
                          GetDefinitionModules   29%
                          Eval                   31%
                          DoCode                 21%
Dabei ist noch erwaehnenswert, dasz - neben dem Aufruf des  Symbolentschluess-
lers  -  die  mit Abstand aufwendigste Einzeloperation, die Operation Identify
fuer die Bezeichneridentifikation ist, die ca. 10-20% der  gesamten  Ueberset-
zungszeit beansprucht.
  Im Vergleich zu Mtc ist die Laufzeit bzw. Leistung von MOCKA bei der  Ueber-
setzung  von  MOCKA  178 Sekunden bzw. 212 Zeilen pro Sekunde und die Laufzeit
bzw. Leistung des C-Uebersetzers fuer die Uebersetzung der C-Version von MOCKA
(36665 Zeilen C-Code) 408 Sekunden bzw. 90 Zeilen pro Sekunde.
  Alle Leistungsangaben wurden berechnet aus: Gesamtumfang von  MOCKA  geteilt
durch  die  Uebersetzungszeit.  Dabei wird nicht beruecksichtigt, dasz Mtc bei
jedem Uebersetzungsvorgang  auch  noch  alle  transitiv  importierten  Defini-
tionsmoduln  einliest  bzw.,  dasz  der  C-Uebersetzer  die Definitionsdateien
dieser Definitionsmoduln in das C-Quellprogramm einfuegt.
  Beruecksichtigt man, dasz Mtc im Gegensatz  zu  MOCKA  bei  jedem  Ueberset-
zungsvorgang  alle transitiv importierten Definitionsmoduln von neuem einliest
und analysiert und dasz  die  Bezeichneridentifikation  wegen  der  Verwendung
einer  Attributgrammatik  ueber  Listen erfolgt, dann ist die Leistung von Mtc
auch im Vergleich mit MOCKA sehr gut.  Insbesondere  scheint  der  Preis  fuer
eine  Vereinfachung  der  Behandlung der getrennten Uebersetzung durchaus ver-
tretbar zu sein.
  Tabelle 6.3 enthaelt den Speicherbedarf  von  Mtc  (dynamisch  angeforderter
Speicher)  fuer  die  Uebersetzung  der  groeszten  vorhandenen  Uebersetzung-
seinheit, dem Implementierungsmodul  des  Codegenerators  von  Mtc,  der  7448
Zeilen  Modula-Code umfaszt. Bei der Uebersetzung dieses Moduls werden zusaet-
zlich noch  18  Definitionsmoduln  mit  einem  Gesamtumfang  von  1992  Zeilen
eingelesen.








                               78











        _____________________________________________________________
                     Zweck                Dynamischer Speicherbedarf
        _____________________________________________________________
         Baum und Attribute                          2243
         Definitionstabelle                           328
         Vorbereitung der Codeerzeugung              4751
         Gesamter Speicherbedarf                     7484
        _____________________________________________________________
       




                                       




                                                                    





               Tabelle 6.3: Dynamischer Speicherbedarf von Mtc
         fuer die Uebersetzung des Codegenerators von Mtc in Kilobyte

  Der Speicherbedarf ist mit 793 Kilobyte pro 1000  Zeilen  Quellcode  relativ
hoch. Der groeszte Anteil entfaellt allerdings auf den Codegenerator. Ohne die
in Kapitel 5.6.2 besprochene automatische Nachoptimierung wuerde  dieser  9155
Kilobyte Speicher benoetigen. Bei der Angabe des Speicherbedarfs fuer Baum und
Attribute ist zu beruecksichtigen, dasz der von Ag erzeugte  Attributauswerter
zur   Zeit  keine  Optimierung  der  Attributspeicherung  enthaelt  und  daher
saemtliche Attribute im Baum gespeichert werden. Dasz der Speicherbedarf  sich
trotzdem  in vertretbaren Grenzen haelt, liegt im wesentlichen daran, dasz die
meisten Attribute als abstrakte Datentypen in der Zielsprache realisiert  wer-
den  und  im  Baum  nur  jeweils  Zeiger  auf  die  eigentlichen Attributwerte
gespeichert werden.  Eine entsprechende  Optimierung  der  Attributspeicherung
durch  Ag und eine bessere Darstellung der in den Knoten des Strukturbaums bei
der Vorbereitung der Codeerzeugung abgelegten Informationen durch Estra wuerde
den Speicherbedarf des Uebersetzers deutlich reduzieren.


6.3
     Qualitaet des erzeugten C-Codes

  Fuer eine Bewertung der Qualitaet des von Mtc erzeugten C-Codes  wurden  die
Modula-  und die C-Version von MOCKA miteinander verglichen.  Um eine Verfael-
schung der Meszergebnisse zu vermeiden, wurde  die  Modula-Version  von  MOCKA
ohne  Laufzeitpruefungen  uebersetzt,  d.h. auch die Modula-Version enthaelt -
wie die C-Version - keine Ueberpruefung von Bereichs- und Feldgrenzen.
  Tabelle 6.4 enthaelt  die  Groesze  der  ausfuehrbaren  Objektprogramme  der
beiden MOCKA-Versionen.

              _________________________________________________
               MOCKA-Version    Text    Data     Bss    Summe
              _________________________________________________
               Modula-2        385024    8192   62680   455896
              _________________________________________________
               C               327680   32768   66288   426736
              _________________________________________________
             


                            


                                     


                                             


                                                     


                                                              




           Tabelle 6.4: Groesze der beiden MOCKA-Versionen in Byte

  Tabelle 6.5 enthaelt Laufzeit und Leistung der  beiden  Versionen  fuer  die
Uebersetzung von MOCKA (37792 Zeilen Modula-Code).









                               79











          __________________________________________________________
           MOCKA-Version   Laufzeit             Leistung
                             [s]      [Zeilen/s]   [Grundsymbole/s]
          __________________________________________________________
           Modula-2          178         212             844
          __________________________________________________________
           C                 165         229             910
          __________________________________________________________
         



                        



                                   



                                                


                                                                   





       Tabelle 6.5: Laufzeit und Leistung der MOCKA-Versionen fuer die
                            Uebersetzung von MOCKA

  Wie den beiden Tabellen entnommen werden kann, ist die C-Version  von  MOCKA
sowohl kleiner als auch schneller wie die Modula-Version.
  Eine  leicht  durchfuehrbare  Moeglichkeit  fuer  eine  Nachoptimierung  der
erzeugten  C-Programme  auf  Quellsprachebene, die in Modula-2 nicht vorhanden
ist, ist die Moeglichkeit in  C  bestimmte  Variablen  in  der  Speicherklasse
register  (s.  Kap.  3.2) zu deklarieren. Mit einigen wenigen solcher Deklara-
tionen fuer haeufig benutzte Variablen kann u.U.  noch  eine  deutliche  Leis-
tungssteigerung der C-Programme erreicht werden.


6.4
     Implementierung eines Makefile-Generators

  Mit Hilfe der Werkzeuge Rex und Ell und des Interpreters fuer  eine  Sprache
zur  Textmusterverarbeitung awk [UNIX79] wurde der Makefile-Generator makemake
implementiert, der aus den Quellen eines  Modulaprogramms  durch  Analyse  der
Importanweisungen  eine  Beschreibung  der Abhaengigkeiten zwischen den nach C
uebersetzten Quellen erzeugt, wie sie vom UNIX-Kommando make  [UNIX79]  verar-
beitet werden kann.  Diese Beschreibung enthaelt auszerdem Kommandos, die fol-
gende Schritte veranlassen:
-
    Uebersetzung der Modula-Quellen durch Mtc nach C.
-
    Uebersetzung der erzeugten C-Quellen durch den C-Uebersetzer in Objektpro-
    gramme.
-
    Binden der Objektprogramme zu einem ausfuehrbaren Programm.
Durch einen Aufruf von make, welches die obige  Beschreibungsdatei  (Makefile)
als  Eingabe  erhaelt,  werden die Kommandos in der richtigen Reihenfolge aus-
gefuehrt und  eine  ausfuehrbare  C-Version  des  jeweiligen  Modula-Programms
erzeugt.
  Das Programm fuer den Interpreter awk konnte aus einem aehnlichen  Makefile-
Generator,  der  fuer  eine  alte  Version  des Modula-Uebersetzers MOCKA ohne
automatische  Nachuebersetzung  implementiert  worden  war,  uebernommen   und
entsprechend angepaszt werden.
  Der Makefile-Generator war fuer die Testphase  und  die  ersten  praktischen
Einsaetze  von  Mtc  eine  wichtige  Hilfe,  da z.B. fuer die Erzeugung der C-
Version von MOCKA ca. 150 Aufrufe von Mtc und  des  C-Uebersetzers  mit  einer
Vielzahl von Optionen und Parametern notwendig sind, die auszerdem noch in der
richtigen  Reihenfolge  erfolgen  muessen.  Durch  die  automatisch   erzeugte
Beschreibungsdatei  reduziert sich dieser Aufwand auf einen Aufruf des Komman-
dos make.
  Die Beschreibungdatei enthaelt uebrigens auch genuegend Abhaengigkeitsinfor-
mationen fuer eine Verwaltung der C-Quellen: Bei einer Modifikation einer oder
mehrerer C-Quellen werden durch einen Aufruf  von  make  alle  abhaengigen  C-
Programme  nachuebersetzt.   Die  Beschreibung reicht allerdings nicht aus, um
bei einer Modifikation der Modula-Quellen eine vollstaendige  Nachuebersetzung
nach  C  zu veranlassen, da fuer eine Vereinfachung der Beschreibung in dieser

                               80











nur vermerkt ist, dasz M.c von M.mi und  M.h  von  M.md  abhaengt.   Es  waere
allerdings  -  wenn  dies benoetigt werden sollte - nicht besonders aufwendig,
makemake so zu erweitern, dasz  auch  die  Abhaengigkeit  einer  Uebersetzung-
seinheit  von  allen  transitiv  importierten (Definitions-)Moduln beschrieben
wird.


6.5
     Bewertung der Uebersetzerbauwerkzeuge

  Dieser Abschnitt enthaelt einige spezielle Anmerkungen zu  den  Uebersetzer-
bauwerkzeugen sowie eine Reihe von Verbesserungswuenschen und -vorschlaegen.
  Rex und Ell ermoeglichen es, in kuerzester Zeit  einen  Symbolentschluessler
bzw.  einen Zerteiler mit automatischer Fehlerbehandlung aus einer knappen und
leicht verstaendlichen formalen  Spezifikation  zu  erstellen.  Ein  wichtiges
Merkmal  der  erzeugten Uebersetzerteile fuer den praktischen Einsatz ist ihre
hohe Laufzeiteffizienz.
  Auch der Einsatz von Ast  ist  eine  enorme  Arbeitserleichterung  fuer  den
Uebersetzerbauer:  Aus einer sehr kurzen formalen Spezifikation der abstrakten
Syntax (vgl. Anh. A) kann ein zwar relativ leicht  ,,von  Hand''  programmier-
barer  aber  umfangreicher  Modul  fuer  die Implementierung des Strukturbaums
erzeugt werden.
  Ein interessanter Aspekt in diesem Zusammenhang waere, ob  aus  einer  even-
tuell gemeinsamen Spezifikation des Zerteilers und der abstrakten Syntax nicht
auch die semantischen Aktionen fuer den Baumaufbau automatisch erzeugt  werden
koennten,  die  bei  der erstellten Zerteilerspezifikation den meisten Aufwand
erforderten.
  Insgesamt nahm die Implementierung der ersten beiden Phasen von  Mtc  (lexi-
kalische  und  syntaktische  Analyse, Baumaufbau und Behandlung der getrennten
Uebersetzung) weniger als 1/7 der gesamten Implementierungszeit in Anspruch.


6.5.1
       Ag

  Die zur Zeit vorliegende Version von Ag ist  ein  noch  in  der  Entwicklung
befindlicher Prototyp.
  Die aus der Sicht des  Verfassers  wichtigste  Verbesserung  der  Spezifika-
tionssprache  waere, eine Moeglichkeit innerhalb der Attributierungsregeln auf
Attribute von Vorgaengerknoten im Strukturbaum zugreifen  zu  koennen  (analog
INCLUDING  des  GAG-Systems  [Kastens82]).   Durch  eine  solche  Moeglichkeit
koennte die Attributgrammatik  deutlich  verkleinert  werden  und  eine  nicht
unerhebliche  Anzahl  von  Attributen  und  Attributberechnungen, die nur fuer
Attributtransfers benoetigt werden, koennte entfallen.
  Waehrend der Entwicklung der Attributgrammatik trat haeufig das Problem auf,
dasz diese nicht mehr der Klasse OAG angehoerte. In diesem Fall war es notwen-
dig, geeignete kuenstliche Attributabhaengigkeiten  einzufuehren,  die  wieder
die Eigenschaft OAG erzwangen. Da auf der einen Seite die von Ag ausgedruckten
Informationen ueber die  Attributabhaengigkeiten  sehr  umfangreich  sind  und
auszerdem  die Eigenschaft OAG nicht besonders leicht nachvollziehbar ist, war
es jedesmal nicht ganz einfach, geeignete kuenstliche  Attributabhaengigkeiten
zu  finden.  Es  waere  daher  wuenschenswert, wenn Ag - aehnlich wie das GAG-
System - in der Lage waere, diese kuenstlichen Abhaengigkeiten  zur  Erzielung
der OAG-Eigenschaft ohne Einwirkung des Benutzers automatisch einzufuehren.


                               81











  Fuer eine formale Spezifikation der statischen  Semantik  einer  Sprache  im
Rahmen der Sprachdefinition ist eine volle Funktionalitaet der Attributgramma-
tik sicher unerlaeszlich. Fuer  eine  praktische  Implementierung  der  seman-
tischen  Analyse,  die  hinsichtlich  Laufzeit und Speicherbedarf des Attribu-
tauswerters moeglichst effizient sein soll, ist der kontrollierte Einsatz  von
Seiteneffekten  manchmal nahezu unerlaeszlich. Auszerdem lassen sich zyklische
Abhaengigkeiten innerhalb von Objekt- und Typbeschreibungen, wie  sie  in  den
meisten  in  der  Praxis  verwendeten  Sprachen einfach auftreten, durch einen
schrittweisen Aufbau dieser Beschreibungen noch am einfachsten aufloesen.  Ein
Problem,  welches  durch den Einsatz von kontrollierten Seiteneffekten natuer-
lich hinzukommt ist, dasz man sich in diesem Zusammenhang Gedanken  ueber  die
Reihenfolge der Seiteneffekte machen und diese Reihenfolge eventuell durch die
Einfuehrung von geeigneten Attributen bzw.  Attributabhaengigkeiten  erzwingen
musz.
  Durch den Einsatz von in  Modula-2  implementierten  abstrakten  Datentypen,
durch  kontrollierte  Seiteneffekte  und  durch  die von Ag verwendete direkte
Implementierung  der  Besuchssequenzen  mit  rekursiven  Prozeduren   ist   es
gelungen, einen Attributauswerter aus einer Attributgrammatik zu erzeugen, der
insbesondere im Hinblick auf Laufzeiteffizienz mit ,,von Hand''  implementier-
ten Uebersetzern wie MOCKA durchaus mithalten kann.
  Die Entwicklung einer Attributgrammatik fuer  die  semantische  Analyse  ist
eine  relativ  komplexe  und  aufwendige  Aufgabe und der Teil der Arbeit, der
dabei von einem Generator wie Ag uebernommen werden  kann,  ist  im  Vergleich
z.B. zur Arbeitserleichterung bei der automatischen Erzeugung eines Zerteilers
aus einer kontextfreien Grammatik relativ  klein.  Die  fuer  die  semantische
Analyse von Mtc entwickelte Attributgrammatik ist sicher nur ein erster Ansatz
im Hinblick auf Kombination von abstrakten Datentypen und  Attributgrammatiken
einschlieszlich  dem  Einsatz von kontrollierten Seiteneffekten und koennte in
mancherlei Hinsicht verbessert werden. Die Entwicklung einer kompletten Attri-
butgrammatik fuer die semantische Analyse von Modula-2, die sowohl Forderungen
hinsichtlich Lesbarkeit, Verstaendlichkeit und Vollstaendigkeit als auch  hin-
sichtlich  Effizienz  des  daraus  erzeugten  Attributauswerters erfuellt, ist
sicher ein interessantes Forschungs- und/oder Diplomarbeitsthema.
  Eine letzte Bemerkung zu Ag gilt der Speicherung der Attributwerte.  In  der
bisherigen Version von Ag werden saemtliche Attribute im Baum gespeichert. Wie
die Messungen in Kapitel 6.2 zeigen ist dies - im Gegensatz zu anderslautenden
Feststellungen   in   der   Literatur   -   heute   aufgrund  der  gewachsenen
Hauptspeichergroeszen durchaus moeglich. Allerdings sollten dabei die  folgen-
den Punkte beruecksichtigt werden:
-
    Der Uebersetzer Mtc enthaelt keine vollstaendige semantische Analyse. Eine
    solche  vollstaendige  semantische Analyse wuerde zu einer hoeheren Anzahl
    von Attributen und damit zu einem hoeheren Attributspeicherbedarf fuehren.
-
    Bei der Implementierung  wurde  wegen  der  fehlenden  Speicheroptimierung
    stark  auf  den  Speicherbedarf  der  Attributwerte  geachtet und fuer die
    Attributtypen wann immer moeglich Typen  der  Zielsprache  mit  moeglichst
    geringem Speicherbedarf verwendet.
-
    Durch den Einsatz von in der Zielsprache implementierten abstrakten Daten-
    typen,  die  mit  Hilfe  von Zeigertypen realisiert wurden, wird erreicht,
    dasz die meisten im  Baum  gespeicherten  Attribute  nur  Zeiger  auf  die
    eigentlichen Attributwerte (Objekt- und Typbeschreibungen, Umgebungsattri-
    bute, usf.) sind.
  Somit wurde ein wesentlicher  Teil  der  Optimierung  des  Attributspeicher-
bedarfs  bereits  ,,von  Hand''  vorweggenommen.  Es ist daher fraglich, ob es
nicht doch sinnvoll  waere  trotz  der  heutigen  Hauptspeichergroeszen,  eine

                               82











Optimierung  der Attributspeicherung in Ag einzubauen.  Eine solche eventuelle
Optimierung wurde in der Attributgrammatik  bereits  vorbereitet,  indem  alle
Attribute,  die  noch  in  der  Codeerzeugung benoetigt werden, als ,,output''
Attribute [Grosch89a] gekennzeichnet wurden.


6.5.2
       Estra

  Die Erfahrungen des Verfassers bei diesem Einsatz von Estra sind sehr  posi-
tiv.  Der  Uebergang von einer direkten Implementierung zu einer Spezifikation
des Codegenerators mit Estra hat eine Reihe von Vorteilen.  Der Benutzer  wird
durch  die  Spezifikation  von  implementierungstechnischen  Details  wie  der
Traversierung  des  Baums  entlastet.   Die  Auswahl  bestimmter   Transforma-
tionsvorschriften  durch  den  Codegenerator  kann auf einem hoeheren Abstrak-
tionsniveau mit Mustern, Bedingungen und Kosten beschrieben werden.  Auszerdem
werden die Zugriffe auf in den Mustern vorkommende Teilbaeume und deren Attri-
bute von Estra  unterstuetzt  und  vereinfacht.  Insgesamt  ergibt  sich  eine
bessere  Lesbarkeit  und  Verstaendlichkeit  der  Codeerzeugung  aufgrund  des
hoeheren Abstraktionsniveaus der Spezifikation. Auszerdem wird eine  leichtere
Aenderbarkeit und Wartbarkeit des Codegenerators erreicht.
  Die Laufzeiteffizienz des erzeugten Codegenerators ist,  wie  die  Messungen
aus Kapitel 6.2 zeigen, ebenfalls gut. Allerdings faellt der Codegenerator mit
insgesamt 7571 Zeilen recht grosz aus. Hier waere vielleicht eine Moeglichkeit
zur  Modularisierung  sowohl  der  Spezifikation als auch der daraus erzeugten
Implementierung angebracht.
  Hauptkritikpunkt an Estra ist der bereits in Kapitel 5.6.2 erwaehnte und  in
den  Messungen  in  Kapitel 6.2 noch einmal deutlich dokumentierte extrem hohe
Speicherbedarf des von Estra erzeugten Codegenerators.  Dieser  Speicherbedarf
resultiert  daraus,  dasz  Estra  bei der Vorbereitung der Transformation fuer
jeden Knoten des Strukturbaums einen Informationsblock anlegt, der  fuer  jede
Funktion der Spezifikation die auf diesen Knoten anwendbare Vorschrift und die
Kosten dieser Anwendung enthaelt (vgl. Kap. 5.6.2). Es musz  aber  bereits  in
der  Spezifikation fuer jede Funktion angegeben werden, auf welche Knotentypen
diese Funktion anwendbar ist.  Betrachtet man die Spezifikation  des  Codegen-
erators von Mtc, die 22 Funktionen umfaszt, dann stellt man fest, dasz im Mit-
tel nur ca. 2 der 22 Funktionen auf jeden Knotentyp anwendbar sind. Das bedeu-
tet aber, dasz ueber 90% des dynamisch angeforderten Speichers voellig umsonst
angefordert werden, da dort nur die bereits  aus  der  Spezifikation  bekannte
Tatsache  festgehalten  wird,  dasz  die meisten Funktionen auf den jeweiligen
Knoten des Strukturbaums ueberhaupt nicht anwendbar sind.  Wuerde  Estra  fuer
jeden  Knoten nur einen Informationsblock anlegen, der Informationen ueber die
auf diesen Knoten anwendbaren Funktionen enthaelt, koennte der  Speicherbedarf
des Codegenerators auf unter 1/10 reduziert werden.



7.
    Zusammenfassung und Ausblick

  Zentraler Teil dieser Diplomarbeit bildet die Definition einer  vollstaendi-
gen  Abbildung  von  Modula-2 nach C. Insbesondere wurde auch gezeigt wie sta-
tisch geschachtelte Prozedurdeklarationen und das  Modulkonzept  von  Modula-2
nach  C abgebildet werden koennen. Modula-2 besitzt zwar ein deutlich hoeheres
Abstraktionsniveau, aber durch eine Kombination von primitiveren C-Konstrukten
koennen auch in C nicht direkt vorhandene Modula-Konstrukte realisiert werden.
Einzige Ausnahme hierbei bilden  die  Koroutinen  fuer  deren  Abbildung  kein
geeignetes C-Konstrukt existiert.

                               83











  Im Rahmen dieser Diplomarbeit wurde ebenfalls der Uebersetzer  Mtc  entwick-
elt,  der  die  oben  beschriebene  Abbildung  implementiert  und  die Modula-
Programme in lesbaren C-Code umsetzt. Etwa 3/4 des Quellcodes von Mtc  besteht
aus  Moduln,  die  mit  den an der GMD Forschungsstelle Karlsruhe entwickelten
Uebersetzerbauwerkzeugen Rex, Ell,  Ast,  Ag  und  Estra  aus  Spezifikationen
erzeugt  wurden.   Da Mtc nicht fuer die Programmentwicklung, sondern fuer die
Uebertragung von fertig entwickelten Modula-Programmen  nach  C  gedacht  ist,
wird  die semantische Korrektheit der Eingabeprogramme nicht ueberprueft.  Die
Uebersetzungsleistung von Mtc ist mit ca. 150 Zeilen in der Sekunde  an  einer
SUN-Workstation  (MC68020-Prozessor)  sehr  gut;  allerdings ist der Speicher-
bedarf mit bis zu 800 Kilobyte je 1000 Zeilen Quellprogramm relativ hoch.
  Da an der GMD Forschungsstelle Karlsruhe Modula-2 seit mehreren Jahren  fuer
die  Programmentwicklung eingesetzt wird, bestand an geeigneten Testprogrammen
fuer Mtc kein Mangel und anfaenglich noch vorhandene Schwaechen der  Abbildung
konnten  schnell aufgedeckt und beseitigt werden.  Bisher wurden u.a. folgende
Programme mit Mtc erfolgreich nach C uebertragen: der Uebersetzer Mtc  selbst,
der  Modula-Uebersetzer  MOCKA  sowie die Uebersetzerbauwerkzeuge Rex, Ell und
Lalr.  Wie erste Messungen zeigen ist  die  Qualitaet  des  erzeugten  C-Codes
ebenfalls  gut:  Die  erzeugten C-Programme sind kleiner und schneller als die
urspruenglichen Modula-Programme.
  Erste Benutzerwuensche legen den Schlusz nahe, dasz  die  in  Kapitel  4.2.4
begruendete Entscheidung, Kommentare nicht von Modula-2 nach C zu uebersetzen,
doch noch einmal ueberdacht werden sollte. Durch  eine  Beruecksichtigung  von
,,typischen''  Konventionen, die fuer die Kommentierung in der Regel unbewuszt
eingehalten werden, waere es vielleicht moeglich, eine  Loesung  zu  implemen-
tieren,  die  die  Kommentare  wenigstens in den meisten Faellen im C-Programm
richtig plaziert und nur in wenigen Faellen eine manuelle  Verschiebung  durch
den  Benutzer  erfordert.  Allerdings sollte aus diesem Grund die Uebersetzung
der Kommentare optional sein und nur auf ausdruecklichen Wunsch des  Benutzers
stattfinden.
  Die Implementierung von Mtc liesze sich sicher noch in mancher Hinsicht ver-
bessern.  Wichtigster  Punkt  waere eine Reduktion des in Kapitel 6.2 dokumen-
tierten hohen Speicherbedarfs von Mtc.  Eine bessere Darstellung  der  in  den
Knoten  des  Strukturbaums  bei  der Vorbereitung der Codeerzeugung abgelegten
Informationen durch Estra und eine Optimierung der  Attributspeicherung  durch
Ag wuerde den Speicherbedarf des Uebersetzers deutlich reduzieren.
  Ein weiterer Punkt waere eine interpretative Auswertung von konstanten  Aus-
druecken,  die es auch ermoeglicht, Ueberlaeufe zu erkennen und konstante Aus-
druecke mit Operanden im Bereich  MAX(INTEGER)+1..MAX(CARDINAL)  auswerten  zu
koennen.
  Der hohe Aufwand fuer die Bezeichneridentifikation, der auf  eine  Implemen-
tierung  der  Umgebungsattribute  mit Listen zurueckzufuehren ist (fuer grosze
Programme ca. 20% der  gesamten  Uebersetzungszeit),  koennte  moeglicherweise
durch  eine  Implementierung  der Umgebungsattribute mit Hilfe von Suchbaeumen
reduziert werden.
  Die Uebersetzerbauwerkzeuge Rex, Ell und Ast sind weitgehend ausgereift  und
eignen  sich wegen der enormen Arbeitserleichterung fuer den Uebersetzerbauer,
aber auch wegen der hohen Laufzeiteffizienz  der  erzeugten  Uebersetzerteile,
fuer  einen  Einsatz  auch  in  der  Konstruktion von Uebersetzern mit Produk-
tionsqualitaet.
  Die Prototypen Ag und Estra bieten erste  interessante  Ansaetze  fuer  eine
Spezifikation  der  semantischen  Analyse  und  der  (Zwischen-)Codeerzeugung,
insbesondere  sind  die  erzeugten  Uebersetzerteile  sehr  laufzeiteffizient.
Allerdings  besteht  nach  Ansicht des Verfassers dieser Diplomarbeit noch ein

                               84











Entwicklungsbedarf sowohl hinsichtlich Ausdruckskraft der Spezifikationen  als
auch hinsichtlich des Speicherbedarfs der erzeugten Uebersetzerteile bevor ein
Einsatz dieser Werkzeuge auch auszerhalb von Forschungsprojekten moeglich ist.























































                               85











Anhang A: Abstrakte Syntax von Modula-2


TREE
IMPORT  {
FROM StringMem  IMPORT tStringRef;
FROM Idents     IMPORT tIdent;
FROM Errors     IMPORT tPosition;
}
EXPORT  {
CONST
  Definition            =  1;           (* compilation unit kind        *)
  Foreign               =  2;
  Implementation        =  3;
  Program               =  4;
  NotEqual              =  1;           (* operators                    *)
  Times                 =  2;
  Plus                  =  3;
  Minus                 =  4;
  Divide                =  5;
  Less                  =  6;
  LessEqual             =  7;
  Equal                 =  8;
  Greater               =  9;
  GreaterEqual          = 10;
  And                   = 11;
  Div                   = 12;
  In                    = 13;
  Mod                   = 14;
  Not                   = 15;
  Or                    = 16;
  Decimal               =  1;           (* integer constant kind        *)
  Octal                 =  2;
  Hexadecimal           =  3;
}
GLOBAL  {
FROM StringMem  IMPORT tStringRef;
FROM Idents     IMPORT tIdent;
FROM Errors     IMPORT tPosition;
}
RULE
ROOT            = CompUnits .
CompUnits       = <
  CompUnits0    = .
  CompUnit      = [Kind: SHORTCARD] [Ident: tIdent] [Pos: tPosition]
                  Next: CompUnits REVERSE <
    DefMod      = Import Decls .
    ProgMod     = Import Decls Stmts .
  >.
>.
Import          = <
  Import0       = .
  Import1       = Next: Import REVERSE <

                               86











    From        = [Ident: tIdent] [Pos: tPosition] ImpIds .
    Objects     = ImpIds .
  >.
>.
ImpIds          = <
  ImpIds0       = .
  ImpIds1       = [Ident: tIdent] [Pos: tPosition] Next: ImpIds REVERSE .
>.
Export          = <
  Export0       = .
  Export1       = [Qualified: BOOLEAN] ExpIds .
>.
ExpIds          = <
  ExpIds0       = .
  ExpIds1       = [Ident: tIdent] Next: ExpIds REVERSE .
>.
Decls           = <
  Decls0        = .
  Decl          = Next: Decls REVERSE <
    Var         = VarIds Type .
    Object      = [Ident: tIdent] <
      Const     = Expr .
      TypeDecl  = Type [Pos: tPosition] .
      Proc      = Formals ResultType: PrimaryType Decls Stmts .
      ProcHead  = Formals ResultType: PrimaryType [Pos: tPosition] .
      Module    = Import Export Decls Stmts .
      Opaque    = .
    >.
  >.
>.
VarIds          = <
  VarIds0       = .
  VarIds1       = [Ident: tIdent] Next: VarIds REVERSE .
>.
Formals         = <
  Formals0      = .
  Formals1      = [IsVAR: BOOLEAN] ParIds Type Next: Formals REVERSE .
>.
ParIds          = <
  ParIds0       = .
  ParIds1       = [Ident: tIdent] Next: ParIds REVERSE .
>.
Type            = <
  Array         = [IsOpen: BOOLEAN] IndexType: SimpleType ElemType: Type .
  Record        = Fields .
  SetType       = BaseType: SimpleType .
  Pointer       = TargetType: Type .
  ProcType      = FormalTypes ResultType: PrimaryType .
  SimpleType    = <
    Enumeration = EnumIds .
    Subrange    = BaseType: PrimaryType Lwb: Expr Upb: Expr .
    PrimaryType = <
      Void      = .

                               87











      TypeId    = [Ident: tIdent] [Pos: tPosition] <
        TypeId0 = .
        TypeId1 = TypeId .
      >.
    >.
  >.
>.
Fields          = <
  Fields0       = .
  Fields1       = Next: Fields REVERSE <
    RecordSect  = FieldIds Type .
    VariantSect = TagField Variants Else: Fields.
  >.
>.
FieldIds        = <
  FieldIds0     = .
  FieldIds1     = [Ident: tIdent] Next: FieldIds REVERSE .
>.
TagField        = Type: TypeId <
  TagField0     = .
  TagField1     = [Ident: tIdent] .
>.
Variants        = <
  Variants0     = .
  Variant       = Labels Variant: Fields Next: Variants REVERSE .
>.
FormalTypes     = <
  FormalTypes0  = .
  FormalType    = [IsVAR: BOOLEAN] Type Next: FormalTypes REVERSE .
>.
EnumIds         = <
  EnumIds0      = .
  EnumIds1      = [Ident: tIdent] Next: EnumIds REVERSE .
>.
Expr            = <
  Binary        = [Operator: SHORTCARD] Lop: Expr Rop: Expr .
  Unary         = [Operator: SHORTCARD] Mop: Expr .
  IntConst      = [Kind: SHORTCARD] [IntVal: CARDINAL] [Pos: tPosition] .
  RealConst     = [RealVal: tStringRef] .
  StringConst   = [StringVal: tStringRef] .
  CharConst     = [CharVal: CHAR] .
  FuncCall      = Designator Actuals .
  Set           = BaseType: Qualid Elems .
  BitSet        = Elems .
  Designator    = [Pos: tPosition] <
    Qualid      = [Ident: tIdent] <
      Qualid0   = .
      Qualid1   = Qualid .
    >.
    Subscript   = Designator Index: Expr .
    Deref       = Designator .
    Select      = Designator [Field: tIdent] .
  >.
>.

                               88











Elems           = <
  Elems0        = .
  Elems1        = Next: Elems REVERSE <
    Elem        = Elem: Expr .
    ElemRange   = Lwb: Expr Upb: Expr .
  >.
>.
Actuals         = <
  Actuals0      = .
  Actual        = Expr Next: Actuals REVERSE .
>.
Stmts           = <
  Stmts0        = .
  Stmt          = Next: Stmts REVERSE <
    Assign      = Designator Expr .
    Call        = Designator Actuals .
    If          = Cond: Expr Then: Stmts Elsifs Else: Stmts .
    Case        = Expr Cases Else: Stmts [Default: BOOLEAN] .
    While       = Cond: Expr Stmts .
    Repeat      = Stmts Cond: Expr .
    Loop        = Stmts .
    For         = Qualid From: Expr To: Expr By: Expr Stmts .
    With        = Designator Stmts .
    Exit        = .
    Return1     = .
    Return2     = Result: Expr .
  >.
>.
Elsifs          = <
  Elsifs0       = .
  Elsifs1       = Cond: Expr Stmts Next: Elsifs REVERSE .
>.
Cases           = <
  Cases0        = .
  Cases1        = Labels Stmts Next: Cases REVERSE .
>.
Labels          = <
  Labels0       = .
  Labels1       = Next: Labels REVERSE <
    Label       = Label: Expr .
    LabelRange  = Lwb: Expr Upb: Expr .
  >.
>.












                               89











Anhang B: Beispiel fuer den erzeugten C-Code


(*====== Modula-Programm ===============================================*)
(*------ Tree.md -------------------------------------------------------*)
DEFINITION MODULE Tree;
CONST NoTree    = NIL;
TYPE
  tTree         = POINTER TO tNode;
  tNode         = RECORD
                    Key         : INTEGER;
                    Count       : CARDINAL;
                    Left, Right : tTree;
                  END;
  tProcOfNode   = PROCEDURE (INTEGER, CARDINAL);
VAR Root        : tTree;
PROCEDURE Insert        (x: INTEGER; VAR t: tTree);
PROCEDURE Delete        (x: INTEGER; VAR t: tTree);
PROCEDURE InOrder       (t: tTree; p: tProcOfNode);
END Tree.
(*------ Tree.mi -------------------------------------------------------*)
IMPLEMENTATION MODULE Tree;
FROM Storage    IMPORT ALLOCATE, DEALLOCATE;
PROCEDURE Insert (x: INTEGER; VAR t: tTree);
BEGIN
  IF t = NoTree THEN
    NEW (t);
    WITH t^ DO
      Key := x; Count := 1;
      Left := NoTree; Right := NoTree;
    END;
  ELSIF x < t^.Key THEN Insert (x, t^.Left);
  ELSIF x > t^.Key THEN Insert (x, t^.Right);
  ELSE
    INC (t^.Count);
  END;
END Insert;
PROCEDURE Delete (x: INTEGER; VAR t: tTree);
  VAR s : tTree;
  PROCEDURE del (VAR t: tTree);
  BEGIN
    IF t^.Right # NoTree THEN
      del (t^.Right);
    ELSE
      s^.Key := t^.Key; s^.Count := t^.Count;
      s := t; t := t^.Left;
    END;
  END del;
BEGIN
  IF t # NoTree THEN

                               90











    IF x < t^.Key THEN Delete (x, t^.Left);
    ELSIF x > t^.Key THEN Delete (x, t^.Right);
    ELSE
      s := t;
      IF s^.Right = NoTree THEN t := s^.Left;
      ELSIF s^.Left = NoTree THEN t := s^.Right;
      ELSE del (s^.Left);
      END;
      DISPOSE (s);
    END;
  END;
END Delete;
PROCEDURE InOrder (t: tTree; p: tProcOfNode);
BEGIN
  IF t # NoTree THEN
    InOrder (t^.Left, p);
    p (t^.Key, t^.Count);
    InOrder (t^.Right, p);
  END;
END InOrder;
BEGIN
  Root := NoTree;
END Tree.
(*------ Main.mi -------------------------------------------------------*)
MODULE Main;
FROM StdIO      IMPORT ReadI, ReadNl, WriteI, WriteNl, CloseIO;
FROM Tree       IMPORT tTree, NoTree, Root, Insert, Delete, InOrder;
CONST cMax = 4;
VAR
  i : SHORTCARD;
  x : INTEGER;
  a : ARRAY [1..cMax] OF INTEGER;
MODULE TestOutput;
IMPORT WriteI; EXPORT WriteArray, WriteNode;
  VAR i : CARDINAL;
  PROCEDURE WriteArray (VAR a: ARRAY OF INTEGER);
  BEGIN
    FOR i := 0 TO HIGH (a) DO WriteI (a[i], 5); END;
  END WriteArray;
  PROCEDURE WriteNode (Key: INTEGER; Count: CARDINAL);
  BEGIN
    FOR i := Count TO 1 BY -1 DO WriteI (Key, 5); END;
  END WriteNode;
END TestOutput;
BEGIN
  FOR i := 1 TO cMax DO a[i] := ReadI (); Insert (a[i], Root); END; ReadNl;
  WriteArray (a); WriteNl;
  REPEAT
    InOrder (Root, WriteNode); WriteNl;
    x := ReadI (); ReadNl;

                               91











    Delete (x, Root);
  UNTIL Root = NoTree;
  CloseIO;
END Main.
(*====== Von Mtc erzeugtes C-Programm ==================================*)
/*------ Tree.h --------------------------------------------------------*/
#define DEFINITION_Tree
#define Tree_NoTree   NIL
typedef struct Tree_1 *Tree_tTree;
typedef struct Tree_1 {
    INTEGER Key;
    CARDINAL Count;
    Tree_tTree Left, Right;
} Tree_tNode;
typedef void (*Tree_tProcOfNode)();
extern Tree_tTree Tree_Root;
extern void Tree_Insert();
extern void Tree_Delete();
extern void Tree_InOrder();
extern void BEGIN_Tree();
/*------ Tree.c --------------------------------------------------------*/
#include "SYSTEM_.h"
#ifndef DEFINITION_Storage
#include "Storage.h"
#endif
#ifndef DEFINITION_Tree
#include "Tree.h"
#endif
Tree_tTree Tree_Root;
static void del();
static Tree_tTree *G_1_s;
void
Tree_Insert(x, t)
INTEGER x;
Tree_tTree *t;
{
  if (*t == Tree_NoTree) {
    Storage_ALLOCATE(t, sizeof(Tree_tNode));
    {
      register Tree_tNode *W_1 = *t;
      W_1->Key = x;
      W_1->Count = 1;
      W_1->Left = Tree_NoTree;
      W_1->Right = Tree_NoTree;
    }
  } else if (x < (*t)->Key) {
    Tree_Insert(x, &(*t)->Left);
  } else if (x > (*t)->Key) {
    Tree_Insert(x, &(*t)->Right);
  } else {
    INC((*t)->Count);

                               92











  }
}
static void
del(t)
Tree_tTree *t;
{
  if ((*t)->Right != Tree_NoTree) {
    del(&(*t)->Right);
  } else {
    (*G_1_s)->Key = (*t)->Key;
    (*G_1_s)->Count = (*t)->Count;
    *G_1_s = *t;
    *t = (*t)->Left;
  }
}
void
Tree_Delete(x, t)
INTEGER x;
Tree_tTree *t;
{
  Tree_tTree s;
  Tree_tTree *L_1;
  L_1 = G_1_s;
  G_1_s = &s;
  if (*t != Tree_NoTree) {
    if (x < (*t)->Key) {
      Tree_Delete(x, &(*t)->Left);
    } else if (x > (*t)->Key) {
      Tree_Delete(x, &(*t)->Right);
    } else {
      s = *t;
      if (s->Right == Tree_NoTree) {
        *t = s->Left;
      } else if (s->Left == Tree_NoTree) {
        *t = s->Right;
      } else {
        del(&s->Left);
      }
      Storage_DEALLOCATE(&s, sizeof(Tree_tNode));
    }
  }
  G_1_s = L_1;
}
void
Tree_InOrder(t, p)
Tree_tTree t;
Tree_tProcOfNode p;
{
  if (t != Tree_NoTree) {
    Tree_InOrder(t->Left, p);
    (*p)(t->Key, t->Count);
    Tree_InOrder(t->Right, p);
  }
}
void BEGIN_Tree()

                               93











{
  static BOOLEAN has_been_called = FALSE;
  if (!has_been_called) {
    has_been_called = TRUE;
    BEGIN_Storage();
    Tree_Root = Tree_NoTree;
  }
}
/*------ Main.c --------------------------------------------------------*/
#include "SYSTEM_.h"
#ifndef DEFINITION_StdIO
#include "StdIO.h"
#endif
#ifndef DEFINITION_Tree
#include "Tree.h"
#endif
#define cMax  4
static SHORTCARD i;
static INTEGER x;
static struct S_1 {
    INTEGER A[cMax - 1 + 1];
} a;
static CARDINAL C_1_i;
static void WriteArray();
static void WriteNode();
static void
WriteArray(a, O_1)
INTEGER a[];
LONGCARD O_1;
{
  {
    LONGCARD B_1 = 0, B_2 = (O_1 - 1);
    if (B_1 <= B_2)
      for (C_1_i = B_1;; C_1_i += 1) {
        StdIO_WriteI(a[C_1_i], 5);
        if (C_1_i >= B_2) break;
      }
  }
}
static void
WriteNode(Key, Count)
INTEGER Key;
CARDINAL Count;
{
  for (C_1_i = Count; C_1_i >= 1; C_1_i += -1) {
    StdIO_WriteI(Key, 5);
  }
}
static void TestOutput()
{}
void BEGIN_MODULE()

                               94











{
  BEGIN_StdIO();
  BEGIN_Tree();
  TestOutput();
  for (i = 1; i <= cMax; i += 1) {
    a.A[i - 1] = StdIO_ReadI();
    Tree_Insert(a.A[i - 1], &Tree_Root);
  }
  StdIO_ReadNl();
  WriteArray(a.A, 4L);
  StdIO_WriteNl();
  do {
    Tree_InOrder(Tree_Root, WriteNode);
    StdIO_WriteNl();
    x = StdIO_ReadI();
    StdIO_ReadNl();
    Tree_Delete(x, &Tree_Root);
  } while (!(Tree_Root == Tree_NoTree));
  StdIO_CloseIO();
}





































                               95











Anhang C: UNIX-Manualseite fuer Mtc

NAME
    mtc - Modula-2 to C Translator
SYNOPSIS
    mtc [ options ] [ file ]
DESCRIPTION
    Mtc translates Modula-2 programs into readable C code.  Mtc implements the
    language Modula-2 as defined in N. Wirth's report (3rd edition) with a few
    minor restrictions (see below) and most language extensions implemented by
    MOCKA,  the Modula-2 Compiler Karlsruhe. It produces K&R (not ANSI) C code
    with a few very common extensions like passing structures as value parame-
    ters.
    A definition or foreign module module.md is translated  into  a  C  header
    file module.h. An implementation or program module module.mi is translated
    into the corresponding C source file module.c.   Separate  compilation  is
    handled  by reprocessing all transitively imported definition modules when
    translating a compilation unit. If file is omitted mtc reads from standard
    input.
    Mtc is intended as a tool for translating finished programs from  Modula-2
    to C and not as a tool for program development.  Therefore, the translator
    does not check the semantic correctness of the Modula-2 programs.
    For each foreign module an empty implementation module corresponding to it
    has to be translated to C, because the initialization routine produced for
    the dummy implementation module is used within the modules  resp.  C  pro-
    grams which import the foreign module.
    If the library function alloca is available and the C  programs  are  com-
    piled  with  the  flag  -DStackAlloc, then the memory space for open array
    value parameters will be allocated in the stack frame of the corresponding
    procedure.  This temporary space will be freed automatically when the pro-
    cedure returns.  Otherwise, malloc and free will be used to  allocate  and
    deallocate memory space for open array value parameters.
OPTIONS
    -w
                Suppress warning diagnostics.
    -i
                Generate header files for imported modules.
    -c
                Generate type casts to make the C programs lint free.
    -r
                Generate runtime checks.
    -h
                Print help information.
    -t
                Print test output (time).
    -m
                Print test output (memory).
    -ddir
                Allow import from modules in library dir.
    -ldir
                Specify directory where mtc finds its tables.
FILES
    module.md
                    Source file of definition or foreign module module.
    module.mi
                    Source file of implementation or program module module.
    module.h
                    C header file produced for module.md.
    module.c
                    C source file produced for module.mi.
    SYSTEM_.h
                    Definition of standard constants,  types,  functions,  and
                    macros, which are used in the generated C programs.
    SYSTEM_.c
                    Main program and implementation of standard functions.
SEE ALSO
    Entwurf und Implementierung eines Uebersetzers von Modula-2 nach C  by  M.
    Martin.

                               96











    Programming in Modula-2 (3rd edition) by N. Wirth.
    MOCKA User Manual by F. Engelmann.
    The C Programming Language by B. W. Kernighan and D. M. Ritchie.
DIAGNOSTICS
    The translator reports lexical and syntactic errors, errors detected  dur-
    ing  the  handling  of  separate compilation, and restrictions of the code
    generation.  The translator does not check the semantic correctness of the
    Modula-2  programs.  The  diagnostics  produced  by mtc are intended to be
    self-explanatory.
BUGS
    Coroutines are not supported.
    Forward references within pointer declarations are limited  to  structured
    types.
    Comments are not translated from Modula-2 to C.
    In some very rare cases the translator has to  evaluate  constant  expres-
    sions,  because a literal translation is not possible. The translator will
    fail to do this, if the expression or one of its operands is  not  in  the
    range MIN(INTEGER)..MAX(INTEGER).







































                               97











Anhang D: Verzeichnis der vom Uebersetzer erzeugten Bezeichner

  Die folgende Tabelle gibt einen Ueberblick ueber  Bezeichner  und  Bedeutung
der  vom  Uebersetzer  Mtc erzeugten C-Objekte. Die Abkuerzung nnn steht dabei
fuer eine eindeutige, vom Uebersetzer vergebene Nummer.

______________________________________________________________________________
     Bezeichner                               Bedeutung
______________________________________________________________________________
   A
                           Abbildung von Feldern auf Strukturen mit  einem
                           Vektor  A  als  einziger  Komponente  (s.  Kap.
                           4.4.2.5)
   BEGIN_MODULE
                           Rumpf von Programmoduln (s. Kap. 4.8.7)
   BEGIN_Modulname
                           Initialisierungsroutine       (Rumpf)       des
                           (Implementierungs-)Moduls  Modulname  (s.  Kap.
                           4.8.6)
   B_nnn
                           Anfangs- bzw.  Endwert  von  FOR-Schleifen  (s.
                           Kap. 4.6.5)
   DEFINITION_M
                           Makroname fuer die Steuerung des Einfuegens der
                           Definitionsdatei  des Moduls M mit #include-An-
                           weisungen in alle Moduln, die M importieren (s.
                           Kap. 4.8.1 u. 4.8.4)
   EXIT_nnn
                           Sprungziel  fuer  EXIT-Anweisungen   (s.   Kap.
                           4.6.5)
   G_nnn_Name
                           Abbildung von statisch geschachtelten Prozedur-
                           deklarationen: Globaler Zeiger auf lokale Vari-
                           able Name (s. Kap. 4.4.4)
   L_nnn
                           Lokale Zeigervariable fuer  die  Kellerung  der
                           Werte  von  G_nnn_Name  bei  Rekursion (s. Kap.
                           4.4.4)
   Modulname_nnn
                           Strukturnamen fuer vom globalen Modul Modulname
                           exportierte   Verbunde  oder  Felder  (s.  Kap.
                           4.4.2.6)
   O_nnn
                           Abbildung offener Felder: Zusaetzlicher Parame-
                           ter  mit aktueller Anzahl von Feldelementen (s.
                           Kap. 4.4.4.1.2)
   R_nnn
                           Wert von RETURN-Ausdruecken (s. Kap. 4.6.7)
   S_nnn
                           Strukturnamen fuer nicht  exportierte  Verbunde
                           oder Felder (s. Kap. 4.4.2.6)
   U_nnn, V_nnn
                           Abbildung varianter Verbunde durch  Einfuehrung
                           zusaetzlicher   Strukturkomponenten   (s.  Kap.
                           4.4.2.7)
   W_nnn
                           Zeiger auf Verbunde fuer  Abbildung  von  WITH-
                           Anweisungen (s. Kap. 4.6.6)
   X_nnn
                           Feldvariable fuer  die  Parameteruebergabe  von
                           Zeichenketten (s. Kap. 4.6.2)
   dummy
                           Strukturkomponente fuer in Modula-2 leere  Ver-
                           bunde
______________________________________________________________________________








































                      







































                                                                             









































  Als C-Bezeichner fuer die  Modula-Objekte  werden  die  Bezeichner  aus  dem
Modula-Programm verwendet. Dabei werden 2 Faelle unterschieden:
-
    Der Bezeichner eines von einem globalen Modul exportierten Objekts wird in
    C in der qualifizierten Form Modulname_Bezeichner geschrieben.
-
    Alle uebrigen Bezeichner werden direkt aus dem  Modula-Programm  uebernom-
    men,  werden aber bei Bedarf zur Vermeidung von Namenskonflikten mit einem
    Praefix C_nnn_ versehen.

                               98











  Alle anderen Bezeichner, die in  den  C-Programmen  verwendet  werden,  sind
Bezeichner  fuer  vom  Uebersetzer  Mtc vordefinierte Objekte, wie z.B. die C-
Definitionen der Standardtypen und -prozeduren  der  Sprache  Modula-2.   Alle
diese  Objekte  sind  in SYSTEM_.h bzw. SYSTEM_.c definiert und ihre Bedeutung
ist aus ihrem Bezeichner ablesbar.





















































                               99











Literaturverzeichnis

[Aho86]
      A. V. Aho, R. Sethi, J. D. Ullman:  Compilers:  Principles,  Techniques,
      and Tools.  Addison Wesley, Reading. Ma, 1986.
[Donzeau79]
      V. Donzeau-Gouge, G. Kahn, B. Krieg-Brueckner, B. Lang:  Formal  Defini-
      tion of Ada (preliminary draft).  CII Honeywell Bull, Okt. 1979.
[Engelmann87]
      F.  Engelmann:  GMD  MODULA   SYSTEM   MOCKA   -   User   Manual.    GMD
      Forschungsstelle an der Universitaet Karlsruhe, Dez. 1987.
[Grosch87a]
      J. Grosch: Reusable Software - A Collection of MODULA-Modules.  Compiler
      Generation  Report  No.  4,  GMD  Forschungsstelle  an  der Universitaet
      Karlsruhe, Sept. 1987.
[Grosch87b]
      J. Grosch: Rex - A Scanner Generator.  Compiler Generation Report No. 5,
      GMD Forschungsstelle an der Universitaet Karlsruhe, Dez. 1987.
[Grosch89a]
      J. Grosch: Ast - A Generator for Abstract  Syntax  Trees  (Revised  Ver-
      sion).   Compiler  Generation Report No. 15, GMD Forschungsstelle an der
      Universitaet Karlsruhe, Aug. 1989.
[Grosch89b]
      J. Grosch: Ag - An Attribute Evaluator Generator.   Compiler  Generation
      Report  No. 16, GMD Forschungsstelle an der Universitaet Karlsruhe, Aug.
      1989.
[Kastens80]
      U. Kastens: Ordered Attributed Grammars.  Acta Informatica 13,  229-256,
      1980.
[Kastens82]
      U. Kastens, B. Hutt, E. Zimmermann: GAG: A Practical Compiler Generator.
      Springer Verlag, Heidelberg, 1982.
[Kernighan78]
      B. W. Kernighan, D. M. Ritchie: The C Programming  Language.   Prentice-
      Hall, Englewood Cliffs, N.J., 1978.
[Kernighan83]
      B. W. Kernighan, D. M. Ritchie: Programmieren in C.  Carl Hanser Verlag,
      Muenchen, Wien, 1983.
[Klein86]
      E.  Klein,  J.  Grosch:   User   Manual   for   the   PGS-System.    GMD
      Forschungsstelle an der Universitaet Karlsruhe, Aug. 1986.
[PascAda80]
      P. F. Albrecht, P. E. Garrison, S. L. Graham, R. H. Hyerle,  P.  Ip,  B.
      Krieg-Brueckner:  Source-to-Source Translation: Ada to Pascal and Pascal
      to Ada.  Symposium on the Ada Programming Language, ACM-SIGPLAN, 1980.
[PTC87]
      P. Bergsten: PTC implementation note.   Holistic  Technology  AB,  Grona
      Gatan 59, 41454 Gothenburg, Sweden, 1987.
[UNIX79]
      The UNIX Programmers Manual.  Volume 1, 2a, 2b, Bell Laboratories, 1979.
[Vielsack88]
      B. Vielsack: The Parser Generators Lalr and  Ell.   Compiler  Generation
      Report  No. 8, GMD Forschungsstelle an der Universitaet Karlsruhe, April
      1988.
[Vielsack89]
      B. Vielsack: Spezifikation und Implementierung der Transformation attri-
      butierter  Baeume.  Diplomarbeit, Universitaet Karlsruhe, Fakultaet fuer

                               100











      Informatik, Juni 1989.
[Waite84]
      W. M. Waite, G. Goos: Compiler Construction.  Springer Verlag, New York,
      1984.
[Wirth85]
      N. Wirth: Programming in Modula-2 (3rd edition).  Springer Verlag,  Ber-
      lin, Heidelberg, New York, Tokyo, 1985.



















































                               101











Inhaltsverzeichnis

1.
    Einleitung
                ...........................................     1
    1.1
         Motivation und Zielsetzung
                                     ......................     1
    1.2
         Randbedingungen
                          .................................     2
2.
    Vergleichbare Arbeiten
                            ...............................     2
    2.1
         PTC
              .............................................     2
    2.2
         PascAda
                  .........................................     3
3.
    Die Sprachen
                  .........................................     4
    3.1
         Die Quellsprache Modula-2
                                    .......................     4
    3.2
         Die Zielsprache C
                            ...............................     6
    3.3
         Vergleich
                    .......................................     7
4.
    Abbildung von Modula-2 nach C
                                   ........................     8
    4.1
         Grundlagen der Abbildung
                                   ........................     8
    4.2
         Programmrepraesentation
                                  .........................     9
         4.2.1
                Bezeichner
                            ...............................     9
         4.2.2
                Numerische Konstanten
                                       ....................     9
         4.2.3
                Zeichenketten
                               ............................    10
         4.2.4
                Kommentare
                            ...............................    11
    4.3
         Gueltigkeit und Sichtbarkeit
                                       ....................    11
    4.4
         Deklarationen
                        ...................................    14
         4.4.1
                Konstantendeklarationen
                                         ..................    14
         4.4.2
                Typdeklarationen
                                  .........................    15
                4.4.2.1
                         Typkompatibilitaet
                                             ..............    16
                4.4.2.2
                         Grundtypen
                                     ......................    16
                4.4.2.3
                         Aufzaehlungstypen
                                            ...............    17
                4.4.2.4
                         Unterbereichstypen
                                             ..............    18
                4.4.2.5
                         Felder
                                 ..........................    18
                4.4.2.6
                         Verbunde
                                   ........................    19
                4.4.2.7
                         Verbunde mit Varianten
                                                 ..........    20
                4.4.2.8
                         Mengen
                                 ..........................    21
                4.4.2.9
                         Zeiger
                                 ..........................    21
                4.4.2.10
                         Prozedurtypen
                                        ...................    22
         4.4.3
                Variablendeklarationen
                                        ...................    22
         4.4.4
                Prozedurdeklarationen
                                       ....................    23
                4.4.4.1
                         Formale Parameter
                                            ...............    27
                         4.4.4.1.1
                                    Wert-            und
                                    Referenzparameter
                                                       ....    28
                         4.4.4.1.2
                                    Offene Felder
                                                   ........    28
                4.4.4.2
                         Standardprozeduren  und  -funk-
                         tionen
                                 ..........................    31
         4.4.5
                Lokale Moduln
                               ............................    33
    4.5
         Ausdruecke
                     ......................................    34
         4.5.1
                Operanden
                           ................................    35
         4.5.2
                Operatoren
                            ...............................    37
    4.6
         Anweisungen
                      .....................................    38
         4.6.1
                Zuweisung
                           ................................    38
         4.6.2
                Prozeduraufruf
                                ...........................    39
         4.6.3
                IF-Anweisung
                              .............................    40
         4.6.4
                CASE-Anweisung
                                ...........................    41
         4.6.5
                Schleifen
                           ................................    42
         4.6.6
                WITH-Anweisung
                                ...........................    43
         4.6.7
                RETURN-Anweisung
                                  .........................    44
         4.6.8
                Laufzeitpruefungen
                                    .......................    44














    4.7
         Modul SYSTEM
                       ....................................    45
    4.8
         Uebersetzungseinheiten
                                 ..........................    46
         4.8.1
                Definitionsmoduln
                                   ........................    46
         4.8.2
                FOREIGN-Moduln
                                ...........................    48
         4.8.3
                Implementierungs- und Programmoduln
                                                     ......    48
         4.8.4
                IMPORT-Anweisungen
                                    .......................    48
         4.8.5
                Opaque Typen
                              .............................    49
         4.8.6
                Modulinitialisierung
                                      .....................    51
         4.8.7
                Hauptprogramm
                               ............................    51
5.
    Implementierung des Uebersetzers
                                      .....................    52
    5.1
         Lexikalische Analyse
                               ............................    52
         5.1.1
                Attribute der Grundsymbole
                                            ...............    53
         5.1.2
                Symbol- und Konstantentabelle
                                               ............    53
         5.1.3
                Spezifikation des Symbolentschluesslers
                                                         ..    53
    5.2
         Syntaktische Analyse und Baumaufbau
                                              .............    54
         5.2.1
                Zerteilerspezifikation
                                        ...................    54
         5.2.2
                Spezifikation des Strukturbaums
                                                 ..........    55
         5.2.3
                Baumaufbau
                            ...............................    56
    5.3
         Behandlung der getrennten Uebersetzung
                                                 ..........    57
    5.4
         Semantische Analyse
                              .............................    60
         5.4.1
                Spezifikation der  semantischen  Analyse
                mit einer Attributgrammatik und abstrak-
                ten Datentypen
                                ...........................    60
         5.4.2
                Abstrakte Datentypen
                                      .....................    61
                5.4.2.1
                         Spezifikation  der  Definition-
                         stabelle und Bezeichneridentif-
                         ikation
                                  .........................    61
                5.4.2.2
                         Auswertung   konstanter    Aus-
                         druecke   und   Repraesentation
                         ihrer Werte
                                      .....................    62
                5.4.2.3
                         Operationen auf Typen
                                                ...........    63
         5.4.3
                Die Attributgrammatik
                                       ....................    63
                5.4.3.1
                         Aufbau  der  Definitionstabelle
                         und Berechnung von Umgebungsat-
                         tributen
                                   ........................    63
                5.4.3.2
                         Aufbau von Typbeschreibungen
                                                       ....    65
                5.4.3.3
                         Behandlung des Modulkonzepts
                                                       ....    66
                5.4.3.4
                         Typbestimmung in Ausdruecken
                                                       ....    67
    5.5
         Berechnung von Attributen fuer  die  Codeerzeu-
         gung
               ............................................    68
         5.5.1
                Umbenennung von Bezeichnern
                                             ..............    69
    5.6
         Codeerzeugung
                        ...................................    70
         5.6.1
                Spezifikation des Codegenerators
                                                  .........    71
         5.6.2
                 Nachoptimierung des Codegenerators
                                                     ......    72
    5.7
         Fehlerbehandlung
                           ................................    74
    5.8
         Umfang der Implementierung des Uebersetzers
                                                      .....    74
6.
    Praktische Ergebnisse
                           ................................    75
    6.1
         Test und erste Einsaetze des Uebersetzers
                                                    .......    75
    6.2
         Groesze, Laufzeit und Speicherbedarf des Ueber-
         setzers
                  .........................................    77
    6.3
         Qualitaet des erzeugten C-Codes
                                          .................    79
    6.4
         Implementierung eines Makefile-Generators
                                                    .......    80
    6.5
         Bewertung der Uebersetzerbauwerkzeuge
                                                ...........    81
         6.5.1
                Ag
                    .......................................    81
         6.5.2
                Estra
                       ....................................    83













7.
    Zusammenfassung und Ausblick
                                  .........................    83

    Anhang A: Abstrakte Syntax von Modula-2
                                             ..............    86

    Anhang B: Beispiel fuer den erzeugten C-Code
                                                  .........    90

    Anhang C: UNIX-Manualseite fuer Mtc
                                         ..................    96

    Anhang D: Verzeichnis der vom Uebersetzer  erzeugten
    Bezeichner
                ...........................................    98

    Literaturverzeichnis
                          .................................   100




















































